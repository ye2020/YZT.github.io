<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Keil调试汇总</title>
    <url>/2023/04/07/Keil%E8%B0%83%E8%AF%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="arm-mdk-调试汇总"><a class="markdownIt-Anchor" href="#arm-mdk-调试汇总"></a> ARM- MDK 调试汇总</h1>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.7.25」</em>    <em>第一版赶在回家前写出来的，可能存在问题，或链接视频失效什么的</em><br />
<br><br />
<strong>author：</strong>  <em>Y.Z.T.</em><br />
<br></p>
<p><strong>摘要：</strong>  <em>汇总在使用keil的过程中的一些调试方法</em></p>
<p><strong>简介：</strong></p>
<p><em>1️⃣前几天看哈工程直播的时候，发现他们是用的<strong>Ozone</strong>进行开发，花了点时间去简单了解了一下；</em><br />
<br><br />
<em>2️⃣发现了<strong>Ozone</strong>的调试功能是比较强的，具备了一些<strong>keil</strong>所没有的功能（如：DebugSnapshot（快照功能））,所以谁比较闲可以试一下用（<strong>VSCode 编辑代码 + Keil 编译 + Ozone 调试</strong>）来开发。</em><br />
<br><br />
<em>3️⃣但更多的，我发现<strong>Ozone</strong> 有的功能<strong>keil</strong>也基本都有，虽然很多因为硬件限制而用不了；所以我打算汇总一下keil的调试技巧 ,毕竟keil本身的调试功能是非常强的，我们平时用的很多都是比较浅的</em><br />
<br><br />
<em>4️⃣ 本篇文章的内容来自笔者的调试经验及网络，<strong>受限于硬件</strong>笔者并未全部尝试过，仅<strong>意在抛砖引玉</strong>。借用蔡老板一句话：</em> <font face="华文行楷" color=black size=4> “不要老是说什么学这个没用，我用keil就行了，不要搞那种奇奇怪怪的开发方式，有些东西就是得尝试一下”</font></p>
</blockquote>
<span id="more"></span>
<p><font face="华文彩云" color=red size=5> 特别注意：本文档可能并不完善，欢迎各位进行补充。</font></p>
<br>
<br>
<p>相关代码、资料、本文档源文件已放入 <em><strong>GitHub</strong></em>   需要修改的可以，自行下载源文件。</p>
<p>👇</p>
<p><a href="https://github.com/ye2020/ARM-MDK-Debug-collect">项目地址</a></p>
<hr />
<h2 id="️-前言"><a class="markdownIt-Anchor" href="#️-前言"></a> ❗️ 前言</h2>
<p><strong>接下来的调试介绍大概分成以下几个部分：</strong></p>
<ul>
<li>
<pre><code>基础调试
</code></pre>
</li>
<li>
<pre><code>具体调试
</code></pre>
</li>
<li>⭐️ITM程序跟踪</li>
<li>
<pre><code> 其他调试工具
</code></pre>
</li>
</ul>
<h3 id="测试环境"><a class="markdownIt-Anchor" href="#测试环境"></a> 测试环境</h3>
<blockquote>
<p><strong>开发板：</strong>             <em>ACE实验室F4工程板   //   正点原子精英板   // ACE实验室H7通用板</em></p>
<blockquote>
<p><strong>主控芯片：</strong>	<em>STM32F407VET6  // STM32F103ZET6   // STM32H750VBT6</em></p>
</blockquote>
<blockquote>
<p><strong>CPU：</strong>			<em>Cortex-M4  // Cortex-M3   //  Cortex-M7</em></p>
</blockquote>
<blockquote>
<p><strong>最高主频：</strong>     <em>168MHZ   // 72MHZ  // 480MHZ</em></p>
</blockquote>
<br>
<p><strong>测试程序：</strong>     			  <em>[debug_testF407]</em>  / <em>[debug_testH750_v1.3.5]</em></p>
<blockquote>
<p><strong>FreeRTOS版本：</strong> <em>v10.3.1</em></p>
</blockquote>
<blockquote>
<p><strong>FreeRTOS说明：</strong>  <em>FreeRTOS为STM32CubeMX配置的未修改版本。</em></p>
</blockquote>
<br>
<p><strong>开发平台：</strong>	    <em>VSCODE、MDK-ARM</em></p>
<blockquote>
<p><strong>程序编辑：</strong>    <em>VSCODE</em></p>
</blockquote>
<blockquote>
<p><strong>程序调试：</strong>     <em>MDK-ARM     [ v 5.35.0.2]</em></p>
</blockquote>
<br>
<p><strong>调试设备：</strong>			<em>J-Link仿真器 ：    [ACE - Sentry-哨兵]</em></p>
<p>​                               <em>CAN分析仪 ：    CANalyest - III</em></p>
<p>​                               <em>DJI电池、C610电调、3508电机</em></p>
</blockquote>
<br>
<hr />
<h2 id="1️⃣-基础调试"><a class="markdownIt-Anchor" href="#1️⃣-基础调试"></a> 1️⃣ 基础调试</h2>
<p><font face="华文彩云" color=red size=5> 本节的介绍都是比较基础的，写给22级或是一些刚接触MDK的；</font></p>
<p><font face="华文彩云" color=red size=5>你们会了的自己跳到后面部分去</font></p>
<p>👇 👇</p>
<p><a href="#two">传送门</a></p>
<hr />
<br>
<h3 id="11-keil5-进入调试"><a class="markdownIt-Anchor" href="#11-keil5-进入调试"></a> 1.1 keil5 进入调试</h3>
<h4 id="111-选择调试器"><a class="markdownIt-Anchor" href="#111-选择调试器"></a> 1.1.1 选择调试器</h4>
<p><strong>点击魔术棒 <img src="https://pic.imgdb.cn/item/642ff7c9a682492fccbd228b.png" alt="im" /> -&gt; Debug</strong></p>
<p><img src="https://pic.imgdb.cn/item/642ff7fca682492fccbd9fc6.png" alt="Im2" /></p>
<p>​	                                    	<mark>这里我是用的<strong>J-Link</strong>所以选<strong>J-Link</strong></mark></p>
<hr />
<h4 id="112-配置调试器"><a class="markdownIt-Anchor" href="#112-配置调试器"></a> 1.1.2  配置调试器</h4>
<br>
<p><strong>点击setting进入调速器的设置界面</strong></p>
<p><img src="https://pic.imgdb.cn/item/642ff9afa682492fccc16f2c.jpg" alt="" /></p>
<p><font face="宋体" color=red size=4>大致介绍一下SW 和 JTAG的区别：</font></p>
<ul>
<li>SWD需要的线很少，仅需要<strong>双向数据线</strong>（SWDIO）、<strong>时钟线</strong>（SWCLK）、以及<strong>VCC</strong>和<strong>GND</strong> 四根线；</li>
<li>而且SWD在高速模式下更可靠，而且再增加一根线<strong>SWO</strong>后，可以使用<a href="#ITM">ITM</a> 在线调试，功能更加强大。</li>
<li><strong>JTAG</strong>接口一般可转接成<strong>SWD</strong>，通常能用<strong>JTAG</strong>的都能使用<strong>SWD</strong>， 除非是在调试带宽不够时，不能一般用<strong>SWD</strong>就够了</li>
</ul>
<hr />
<h4 id="113-配置flash"><a class="markdownIt-Anchor" href="#113-配置flash"></a> 1.1.3 配置flash</h4>
<p><strong>点击flash Download</strong></p>
<p><img src="https://pic.imgdb.cn/item/642ffb91a682492fccc51d11.png" alt="" /></p>
<h4 id="114-进入debug"><a class="markdownIt-Anchor" href="#114-进入debug"></a> 1.1.4 进入debug</h4>
<p><img src="https://pic.imgdb.cn/item/642ffc33a682492fccc62d1c.png" alt="im3" /></p>
<hr />
<h3 id="12-调试窗口介绍"><a class="markdownIt-Anchor" href="#12-调试窗口介绍"></a> 1.2 调试窗口介绍</h3>
<p><strong>初始化后的默认调试窗口布局如下：</strong></p>
<p><img src="https://pic.imgdb.cn/item/642ffc8ea682492fccc6d76f.png" alt="im4" /></p>
<p>1️⃣调试操作栏</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[复位|运行|停止|单步运行|单行运行|跳出函数体|运行到光标处|跳转PC指针]</span><br><span class="line">调试时代码的运行操作在此设置</span><br></pre></td></tr></table></figure>
<p>2️⃣主界面窗口设置</p>
<p><strong>[命令行|反汇编窗口|符号窗口|内核寄存器|回调栈及局部变量|变量显示|内存窗口|虚拟串口|系统分析窗口|TRACE窗口|外设寄存器]</strong></p>
<ol>
<li><strong>命令行：</strong><mark>调试操作命令</mark>及返回等消息在这里显示，也可以直接在这里操作执行一些语法命令，如断点打开关闭显示等。</li>
<li><strong>反汇编窗口：<strong>C/C++编写的代码转换为<mark>汇编语言</mark>，此窗口与代码窗口同步滚动，但并不是代码执行时的顺序</strong>(可能是编译的顺序🤔)</strong></li>
<li><strong>符号窗口：</strong> 编译后所有的<mark>函数变量及类型</mark>均在此，可通过这里查看有没有编译某些变量</li>
<li><strong>内核寄存器：</strong> 显示内核先关的<mark>寄存器数值</mark></li>
<li><strong>回调部变量：</strong> 当调试时停留在断点时，这里会显示函数的调用关系，以及压进的变量值，这个一般和断点配合反推异常调用以及查看局部变量无需使用变量查看串口</li>
<li><strong>变量显示</strong>：用于查看单片机中某个<mark>变量的值</mark>，一般多用于查看全局变量以及外设寄存器数值、表达式显示变量，也<mark>可直接操作变量值。</mark> (<strong>相当于直接改变内存</strong>🤔)</li>
<li><strong>内存窗口：</strong> 显示内存地址以及地址处内存的数据，一般可<mark>查看变量</mark>以及<mark>寄存器数据</mark>、<mark>函数地址</mark>等</li>
<li><strong>虚拟串口窗口：</strong> 通过调试查看的串口，一些需要重定向才能使用。(也可用<code>ITM_SendChar(ch)</code>函数，详见<a href="#ITM">ITM</a> )</li>
<li><strong>系统分析窗口：<strong>这里有一些代码分析的高级功能，用的最多的是<mark>软件逻辑分析仪</mark>的功能。(可用作</strong>简易示波器</strong>，和<strong>显示变量波形</strong>）</li>
<li><strong>trace窗口：</strong> 与<mark>代码跟踪</mark>有关，<mark>相对高级的功能</mark>下面有介绍<a href="#ITM">ITM</a> ，具体可参考keil5的 <a href="https://developer.arm.com/documentation/101407/0537/Debugging/Debug-Windows-and-Dialogs/Trace-Exceptions">帮助文档</a>。</li>
<li><strong>外设寄存器窗口：</strong><mark>比较常用</mark>，用来查看你打开的串口/spi/can/Tim/rcc等等寄存器的内容,当然也可<mark>直接修改操作寄存器</mark>。</li>
</ol>
<p>3️⃣在线调试启动/关闭</p>
<p>4️⃣断点设置 设置、取消、关闭、删除所有断点等操作。<br />
5️⃣内核寄存器窗口<br />
6️⃣C代码对应的汇编程序窗口 <strong>注意代码左侧灰色部分代码已编译部分，可设置断点(此部分可以查看代码是否编译或者是否被编辑器优化)</strong></p>
<p>7️⃣   C/C++代码窗口<br />
8️⃣Command窗口 调试命令行，可通过设置命令执行所有调试操作，如断点设置、变量寄存器访问、数据转换、基本计算等功能<br />
9️⃣回调栈及局部变量窗口</p>
<p>🔟 用于查看单片机中某个<mark>变量的值</mark>，一般多用于查看全局变量以及外设寄存器数值、表达式显示变量，也<mark>可直接操作变量值。</mark> (<strong>相当于直接改变内存</strong>)</p>
<br>
<p>(👇更多的可以参考一下这篇文章)</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDgyNzgyMw==&amp;mid=2247483787&amp;idx=2&amp;sn=f52924e67df948b00c42bf4993c191d6&amp;chksm=fc035d4bcb74d45d844202d624b244b6931f568266a359eea51c15d5b8578059d34e89f9c605&amp;scene=178&amp;cur_album_id=1341389839287156737#rd">keil 基础调试</a></p>
<hr />
<h3 id="13-基本调试操作"><a class="markdownIt-Anchor" href="#13-基本调试操作"></a> 1.3  基本调试操作</h3>
<h4 id="131-全速运行-打断点-查看变量"><a class="markdownIt-Anchor" href="#131-全速运行-打断点-查看变量"></a> 1.3.1  全速运行、打断点、查看变量</h4>
<p><img src="https://pic.imgdb.cn/item/643000a2a682492fccce6508.gif" alt="在这里插入图片描述" /></p>
<h4 id="132-复位-停止程序"><a class="markdownIt-Anchor" href="#132-复位-停止程序"></a> 1.3.2  复位、停止程序</h4>
<p><img src="https://pic.imgdb.cn/item/643000cba682492fcccec227.gif" alt="m2" /></p>
<h4 id="133-单行单步运行"><a class="markdownIt-Anchor" href="#133-单行单步运行"></a> 1.3.3  单行/单步运行</h4>
<p><img src="https://pic.imgdb.cn/item/64300116a682492fcccf6283.gif" alt="m3" /></p>
<hr />
<h2 id="2️⃣-具体调试"><a class="markdownIt-Anchor" href="#2️⃣-具体调试"></a> 2️⃣ 具体调试</h2>
<p><span id="two" name="two"></span></p>
<h3 id="21-寄存器直接操作"><a class="markdownIt-Anchor" href="#21-寄存器直接操作"></a> 2.1  寄存器直接操作</h3>
<h4 id="211-中断控制器"><a class="markdownIt-Anchor" href="#211-中断控制器"></a> 2.1.1 中断控制器</h4>
<p>嵌套向量中断控制器 (NVIC) 对话框（适用于 Cortex-M3、Cortex-M4 和 Cortex-M7 内核）显示所有异常的状态。对于每个异常，对话框都会显示编号、来源、名称、状态和优先级。</p>
<h5 id="2111-官方文档"><a class="markdownIt-Anchor" href="#2111-官方文档"></a> 2.1.1.1 官方文档</h5>
<p><img src="https://pic.imgdb.cn/item/643001a2a682492fccd056f8.png" alt="im5" /></p>
<p>官方文档指出我们可以<mark>选定指定中断</mark>，并控制<mark>改变异常的状态</mark></p>
<p>（👇感兴趣的可以看一下官方文档）</p>
<p><a href="https://developer.arm.com/documentation/101407/0537/Debugging/Debug-Windows-and-Dialogs/Core-Peripherals/Armv7-M-cores/Armv7-M--Nested-Vector-Interrupt-Controller">官方文档</a></p>
<br>
<h5 id="2112-中断控制器介绍"><a class="markdownIt-Anchor" href="#2112-中断控制器介绍"></a> 2.1.1.2  中断控制器介绍</h5>
<p><img src="https://pic.imgdb.cn/item/643001d8a682492fccd0a94b.png" alt="" /></p>
<p>你的中断设置的<strong>优先级是多少</strong>，<strong>是否开启了</strong>，<strong>是否挂起了</strong>，<strong>是否处于活动状态</strong>，在这里一目了然。</p>
<p>假如你想要让程序<strong>尽快进入中断</strong>程序运行，只要<strong>勾选挂起选项</strong>，这样程序运行后马上就能到<strong>中断处理函数中</strong>执行了。</p>
<p>当然这里只是简单介绍，具体内容可以自己去看文档</p>
<p>（👇感兴趣的可以看一下官方文档）</p>
<p><a href="https://developer.arm.com/documentation/101407/0537/Debugging/Debug-Windows-and-Dialogs/Core-Peripherals/Armv7-M-cores/Armv7-M--Nested-Vector-Interrupt-Controller">官方文档</a></p>
<hr />
<h5 id="2113-开启方法"><a class="markdownIt-Anchor" href="#2113-开启方法"></a> 2.1.1.3 开启方法</h5>
<p><img src="https://pic.imgdb.cn/item/643002c9a682492fccd24c75.gif" alt="m4" /></p>
<hr />
<h4 id="212-外设寄存器查看"><a class="markdownIt-Anchor" href="#212-外设寄存器查看"></a> 2.1.2  外设寄存器查看</h4>
<h5 id="2121-开启方法"><a class="markdownIt-Anchor" href="#2121-开启方法"></a> 2.1.2.1 开启方法</h5>
<p>在<code>systemview window</code> 窗口可以查看各个外设的寄存器值</p>
<br>
<p><img src="https://pic.imgdb.cn/item/6430033ea682492fccd38efa.gif" alt="m5" /></p>
<br>
<h5 id="2122-外设寄存器查看"><a class="markdownIt-Anchor" href="#2122-外设寄存器查看"></a> 2.1.2.2 外设寄存器查看</h5>
<p>图中示例了串口1的寄存器查看，同样的<mark>中断设置</mark>/<mark>时钟分频</mark>/<mark>定时器</mark>均可通过此查看。甚至可以通过数据的变动与否判断外设是否正常打开。</p>
<p><img src="https://pic.imgdb.cn/item/64300396a682492fccd461a3.png" alt="" /></p>
<h5 id="2123-直接修改寄存器值"><a class="markdownIt-Anchor" href="#2123-直接修改寄存器值"></a> 2.1.2.3  直接修改寄存器值</h5>
<p>可通过在外设寄存器窗口，直接修改寄存器的值，以控制寄存器</p>
<p><img src="https://pic.imgdb.cn/item/643003c1a682492fccd4ea8a.gif" alt="m6" /></p>
<p>视频中，可以看到，通过控制<strong>TIM8的CCR寄存器</strong>，来改变<strong>PWM的占空比</strong>。</p>
<h5 id="2124-输出io控制"><a class="markdownIt-Anchor" href="#2124-输出io控制"></a> 2.1.2.4   输出IO控制</h5>
<p><span id="外设窗口" name="外设窗口"></span></p>
<p>可以通过控制GPIO的ODR寄存器</p>
<br>
<p><img src="https://pic.imgdb.cn/item/643003f8a682492fccd58b13.webp" alt="m7" /></p>
<br>
<h5 id="2125-输入io检测"><a class="markdownIt-Anchor" href="#2125-输入io检测"></a> 2.1.2.5  输入IO检测</h5>
<p>当某个单片机IO口设置为输入时，可直接通过输入寄存器查看电平状态即使代码处于断点停止状态也可以查看(断点停止有时需要手动点击<strong>toolbox</strong>中的更新窗口按钮)，在项目中可用来<strong>检测外部开关信号</strong>等省去了万用表测电压。</p>
<p><img src="https://pic.imgdb.cn/item/64300430a682492fccd5fcf6.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h5 id="2126-直接控制串口输出"><a class="markdownIt-Anchor" href="#2126-直接控制串口输出"></a> 2.1.2.6 直接控制串口输出</h5>
<p>通过直接修改串口的数据寄存器来进行操作</p>
<p><img src="https://pic.imgdb.cn/item/6430045aa682492fccd64d23.png" alt="" /></p>
<p><font face="华文彩云" color=red size=5>类似直接通过寄存器来进行调试还有很多示例，这里仅演示其中几种，有其他比较有用的也欢迎补充。</font></p>
<hr />
<br>
<h3 id="22-测量某段代码运行时间"><a class="markdownIt-Anchor" href="#22-测量某段代码运行时间"></a> 2.2  测量某段代码运行时间</h3>
<p>方法比较多， 如利用系统内核计算（dwt）、利用其它工具如<a href="#Systemview">Systemview</a> 、利用断点等</p>
<br>
<h4 id="221-利用内核计数dwt"><a class="markdownIt-Anchor" href="#221-利用内核计数dwt"></a> 2.2.1  利用内核计数（dwt）</h4>
<h5 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h5>
<p><img src="https://pic.imgdb.cn/item/64300497a682492fccd6bf9b.png" alt="" /></p>
<br>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码运行时间（加在被测代码块之后）</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">DTW_Time_Difference_ms</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint32_t</span> old_counter;</span><br><span class="line">  <span class="type">uint32_t</span> counter,couter_current;</span><br><span class="line">  couter_current = DWT_get_time();</span><br><span class="line">  <span class="keyword">if</span>(couter_current &gt; old_counter)</span><br><span class="line">    counter = couter_current - old_counter;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    counter = couter_current + <span class="number">0XFFFFFFFF</span> - old_counter;</span><br><span class="line">  old_counter = couter_current;</span><br><span class="line">  <span class="keyword">return</span> (counter / (SystemCoreClock/<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************/</span></span><br><span class="line">&#123;</span><br><span class="line">DTW_Time_Difference_ms();</span><br><span class="line">... 被测代码</span><br><span class="line">    </span><br><span class="line">time = DTW_Time_Difference_ms();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<br>
<h5 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> <em>运行结果</em></h5>
<p><img src="https://pic.imgdb.cn/item/643004d6a682492fccd72dbf.png" alt="im8" /></p>
<p><img src="https://pic.imgdb.cn/item/64300525a682492fccd7a224.png" alt="im9" /></p>
<p><font face="华文彩云" color=red size=5>可以看到基本能实现US级的 测量</font></p>
<hr />
<br>
<h4 id="222-利用断点时间测量"><a class="markdownIt-Anchor" href="#222-利用断点时间测量"></a> 2.2.2  利用断点时间测量</h4>
<p>该方法也是基于基于内核时钟，进行计数测量的，经过笔者的测试，在大部分情况下，<strong>精度都是非常高的</strong></p>
<br>
<h5 id="2221-前置步骤"><a class="markdownIt-Anchor" href="#2221-前置步骤"></a> 2.2.2.1 前置步骤</h5>
<p>要用到断点，也即是keil本身来获取准确时间，需要先进行Trace功能的配置</p>
<p>（👇具体配置见下文）</p>
<p><a href="#Trace 配置">Trace 配置</a></p>
<br>
<h5 id="2222-测量前置"><a class="markdownIt-Anchor" href="#2222-测量前置"></a> 2.2.2.2  测量前置</h5>
<p><img src="https://pic.imgdb.cn/item/64300555a682492fccd7fcdb.png" alt="im10" /></p>
<ol>
<li>打开仿真界面</li>
<li>打开<mark>内核寄存器窗口</mark></li>
<li>将寄存器窗口保持固定在如图所示界面时钟显示（计时的时钟就是此处的Sec）</li>
<li>鼠标右键弹出菜单</li>
<li>复位<code>t1/t2</code>定时。</li>
</ol>
<p><font face="华文彩云" color=red size=5>为什么要打开寄存器窗口：</font></p>
<p>有的时候，右下角时间窗口<img src="https://pic.imgdb.cn/item/6430057aa682492fccd8447b.png" alt="(img-BEhXjcWp-1659093245270)(ARM- MDK 调试汇总.assets/image-20220726161524525.png)]" /></p>
<p>可能没有显示时间或时间不更新； 一个简单的解决方法是，切换到<strong>寄存器窗口</strong>，这样时间窗口就能正常显示了。</p>
<br>
<hr />
<h5 id="2223-测试原理"><a class="markdownIt-Anchor" href="#2223-测试原理"></a> 2.2.2.3  测试原理</h5>
<p>在<strong>寄存器窗口</strong>显示的时间是从单片机运行的<strong>第一条代码</strong> 开始的时间，这个时间是累计的。</p>
<p>而<strong>右下角时间窗口</strong></p>
<p><img src="https://pic.imgdb.cn/item/643005aaa682492fccd8a886.png" alt="im11" /></p>
<p>可以重置（Reset）时间，比如现在用t1显示的时间（t0 和 <strong>寄存器窗口</strong>显示的时间一样，不信你可以看看），只要先重置一下这个t1（最上面那个），然后运行代码后暂停，t1显示的就是这段代码的运行时间了。</p>
<br>
<hr />
<h5 id="2224-实际操作"><a class="markdownIt-Anchor" href="#2224-实际操作"></a> 2.2.2.4  实际操作</h5>
<h6 id="22241-关闭固定窗口刷新"><a class="markdownIt-Anchor" href="#22241-关闭固定窗口刷新"></a> 2.2.2.4.1 关闭固定窗口刷新</h6>
<p>(代码运行同时刷新变量窗口数据，会影响测量时间的准确性)</p>
<p><img src="https://pic.imgdb.cn/item/64300430a682492fccd5fcf6.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h6 id="22242-进行测量"><a class="markdownIt-Anchor" href="#22242-进行测量"></a> 2.2.2.4.2  进行测量</h6>
<p><mark>设置断点</mark>后，开启代码运行，下一次测量时应<mark>复位测量计时器T1/T2</mark>.</p>
<p><img src="https://pic.imgdb.cn/item/643005fba682492fccd95728.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h6 id="22243-测量结果"><a class="markdownIt-Anchor" href="#22243-测量结果"></a> 2.2.2.4.3  测量结果</h6>
<p><img src="https://pic.imgdb.cn/item/64300624a682492fccd9b5f3.png" alt="" /></p>
<p>可以看到<strong>测量结果</strong>和之前用<strong>DWT</strong>进行测量基本是一致的</p>
<hr />
<h3 id="23-高级断点调试"><a class="markdownIt-Anchor" href="#23-高级断点调试"></a> 2.3  高级断点调试</h3>
<h4 id="231-简介"><a class="markdownIt-Anchor" href="#231-简介"></a> 2.3.1 简介</h4>
<p>Keil5软件帮助文档中指明了断点有三种类型：<mark>存取断点</mark>，<mark>执行断点</mark>，<mark>条件断点</mark>。</p>
<ul>
<li><strong>存取断点：</strong> 某一个变量度或者写操作时执行断点操作。</li>
<li><strong>执行断点</strong>：执行到代码某个位置时产生断点操作。一般直接在代码左侧打的断点就是此类断点，用的最多。</li>
<li><strong>条件断点</strong>：当满足某个表达式时，如某个变量==0x01时执行断点。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/643006aba682492fccdaed3c.png" alt="im11" /></p>
<p>​                                                                          <mark>图为官方文档介绍</mark></p>
<br>
<hr />
<h4 id="232-开启方法"><a class="markdownIt-Anchor" href="#232-开启方法"></a> 2.3.2 开启方法</h4>
<p><img src="https://pic.imgdb.cn/item/643005fba682492fccd95728.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="233-窗口介绍"><a class="markdownIt-Anchor" href="#233-窗口介绍"></a> 2.3.3  窗口介绍</h4>
<p><img src="https://pic.imgdb.cn/item/643006efa682492fccdb6dfc.png" alt="im15" /></p>
<ul>
<li>
<p>仅操作1处表达式，表达式为某个函数地址时为 <strong><mark>执行断点</mark></strong> ，Count表示 <strong>执行次数</strong> 。</p>
</li>
<li>
<p>1和3处同时操作时表示为<mark>存取断点</mark>，3中<code>SIZE</code>表示存取变量的字节大小，<code>Bytes</code>与<code>Objects</code>的区别在于单一变量与结构体的不同。当存取某个变量或者结构体中某个成员时使用<code>Bytes</code>，存取某个结构体时使用<code>Objects</code>。</p>
</li>
<li>
<p>仅操作1和2为<mark>条件断点</mark>，如变量==、&gt;=某个值时执行printf指令打印变量值。注意此处的printf仅输出到调试界面的Command窗口。command指令的执行并不会使程序中断停止，相当于此处为软件断点。</p>
</li>
</ul>
<p><strong>图中官方示例的各断点的定义的意义：</strong></p>
<p><img src="https://pic.imgdb.cn/item/64300720a682492fccdbd1aa.png" alt="im16" /></p>
<p><img src="https://pic.imgdb.cn/item/6430078ea682492fccdcba13.png" alt="" /></p>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ol>
<li>除直接在代码左侧设置执行断点外，其余断点需要通过断点管理窗口来实现。</li>
<li>断点管理窗口中的断点需要停止代码执行才能正确设置。</li>
</ol>
<br>
<hr />
<h4 id="234-断点操作"><a class="markdownIt-Anchor" href="#234-断点操作"></a> 2.3.4 断点操作</h4>
<h5 id="2341-存取断点"><a class="markdownIt-Anchor" href="#2341-存取断点"></a> 2.3.4.1 存取断点</h5>
<h6 id="23411-存取断点定义"><a class="markdownIt-Anchor" href="#23411-存取断点定义"></a> 2.3.4.1.1  <strong>存取断点定义</strong></h6>
<p>可以在Watch中右键添加断点。</p>
<p><img src="https://pic.imgdb.cn/item/643007a8a682492fccdcf073.png" alt="im17" /></p>
<p>如果想知道某个变量在什么地方被访问，假定有一个变量a，可以按以下进行配置：</p>
<p><img src="https://pic.imgdb.cn/item/643007c8a682492fccdd335c.png" alt="im18" /></p>
<p>因为 Count 值设置为 1，所以<mark>每一次读取a的值</mark>，程序都会停止。</p>
<br>
<hr />
<h6 id="23412-运行结果"><a class="markdownIt-Anchor" href="#23412-运行结果"></a> 2.3.4.1.2  <strong>运行结果</strong></h6>
<p>在对<strong>变量a</strong> 进行读取的时候，程序自动停止运行</p>
<p><img src="https://pic.imgdb.cn/item/64300772a682492fccdc7e98.gif" alt="在这里插入图片描述" /></p>
<p>如果是写操作（Write）访问时，会发现从复位程序开始运行后，程序会停止在某个地方。</p>
<p>因为<mark>全局变量</mark>会在进入 main 函数之前被初始化。</p>
<p>还可以更改<code>Count</code> 的值，如把count 改成2， 则当a被<strong>写入两次</strong>时，程序会停止。</p>
<p><img src="https://pic.imgdb.cn/item/6430080ea682492fccddbd99.png" alt="" /></p>
<hr />
<h5 id="2342-结构体断点"><a class="markdownIt-Anchor" href="#2342-结构体断点"></a> 2.3.4.2 结构体断点</h5>
<p>实际结构体断点也是属于<mark>存取断点</mark>的一种，因为要写的比较多，单独列出来</p>
<p><font face="华文彩云" color=red size=5>注意：这部分我测试的时候感觉有点问题，没完全解决</font></p>
<h6 id="23421-设置结构断点"><a class="markdownIt-Anchor" href="#23421-设置结构断点"></a> 2.3.4.2.1  设置结构断点</h6>
<p>1️⃣ <font face="华文彩云" color=red size=5>出现的问题</font></p>
<p>试了一下，直接在<code>watch</code>窗口 将<strong>整个结构变量</strong>设为断点会报错(包括该变量里的其他结构体成员，如<strong>pitch.c</strong>)</p>
<p><img src="https://pic.imgdb.cn/item/643008c5a682492fccdf1154.gif" alt="在这里插入图片描述" /></p>
<p><img src="https://pic.imgdb.cn/item/643008e4a682492fccdf4be1.png" alt="im20" /></p>
<p>​																	<mark>试着解决了一下 ，没解决</mark></p>
<hr />
<p>2️⃣ <font face="华文彩云" color=red size=5>简单的解决方法</font></p>
<p>可以采用更加通用的方法：</p>
<p><img src="https://pic.imgdb.cn/item/64300914a682492fccdf9c6c.png" alt="im21" /></p>
<p>可以看到结构体变量各个成员的<strong>地址</strong>是不同的，比如我们<code>gimbal_control.auto.c</code> 的地址是<code>0x20004A10</code> （由此我们知道也可以通过这</p>
<p>个来看出一个结构体变量的地址是多少），所以设置后的结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/6430094fa682492fccdff1ca.gif" alt="在这里插入图片描述" /></p>
<p><font face="华文彩云" color=red size=5>注意：经测试好像是不支持指针操作，不太确定</font></p>
<p>比如有这样三个结构体：<code>gimbal_pitch_control_t</code>、<code>gimbal_control_t</code>、</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">gimbal_control_t</span> gimbal_control;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> position;</span><br><span class="line">    <span class="type">int16_t</span> speed;</span><br><span class="line">    <span class="type">int16_t</span> given_current;</span><br><span class="line">    <span class="type">uint8_t</span> temperate;</span><br><span class="line">    <span class="type">int16_t</span> last_position;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span> angle;</span><br><span class="line">    <span class="type">int16_t</span> speed_filt;</span><br><span class="line">    <span class="type">int16_t</span> first_Flag;</span><br><span class="line">    <span class="type">int32_t</span> yaw_angle;</span><br><span class="line">    <span class="type">int32_t</span> pitch_angle;</span><br><span class="line">    <span class="type">int32_t</span> actual_Position;  <span class="comment">//真实位置</span></span><br><span class="line">&#125; <span class="type">motor_measure_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  //申明<span class="title">pitch</span>轴电机变量</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">motor_measure_t</span> *pitch_motor_measure;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> accel_up;</span><br><span class="line">    <span class="type">float</span> accel_down;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int8_t</span> init_flag;    <span class="comment">//初始化成功标志</span></span><br><span class="line">    <span class="type">float</span> Auto_record_location;                      <span class="comment">// 实际位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">first_order_filter_type_t</span> LowFilt_Pitch_Data;    <span class="comment">//P轴低通滤波器</span></span><br><span class="line">    <span class="type">sliding_mean_filter_type_t</span> Slidmean_Pitch_Data;  <span class="comment">//P轴滑动滤波器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">first_order_filter_type_t</span> LowFilt_auto_pitch;    <span class="comment">//自瞄P轴低通滤波器</span></span><br><span class="line">    <span class="type">sliding_mean_filter_type_t</span> Slidmean_auto_pitch;  <span class="comment">//自瞄P轴滑动滤波器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span> filt_output; <span class="comment">//P轴滤波值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span> output;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">gimbal_pitch_control_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> RC_ctrl_t *gimbal_RC;     <span class="comment">//底盘使用的遥控器指针</span></span><br><span class="line">    Vision_Auto_Data_t *auto_c;     <span class="comment">//申明自瞄变量</span></span><br><span class="line"></span><br><span class="line">    VisionStatus_E VisionStatus;    <span class="comment">// 敌人出现状态</span></span><br><span class="line">    <span class="type">const</span> Fire_task_t *Fire_task_control;</span><br><span class="line">   </span><br><span class="line">    gimbal_behaviour_e gimbal_behaviour;</span><br><span class="line"></span><br><span class="line">    <span class="type">gimbal_pitch_control_t</span> pitch_c;   <span class="comment">//申明pitch轴电机变量</span></span><br><span class="line">    <span class="type">gimbal_yaw_control_t</span> yaw_c;       <span class="comment">//申明yaw轴电机变量</span></span><br><span class="line">    <span class="type">motor_measure_t</span> motor_chassis[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> Gimbal_all_flag;  <span class="comment">//全部初始化完成标志</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="type">gimbal_control_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要调用pitch轴的电机数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gimbal_control.pitch_c.pitch_motor_measure-&gt;position</span><br></pre></td></tr></table></figure>
<p>会导致报错：</p>
<p><img src="https://pic.imgdb.cn/item/64300974a682492fcce034bc.png" alt="im22" /></p>
<hr />
<h5 id="2343-条件断点"><a class="markdownIt-Anchor" href="#2343-条件断点"></a> 2.3.4.3  条件断点</h5>
<p>有些时候，我们并不关注地址访问情况，而对变量的数据内容感兴趣，比如变量<code>test_param.test1 == 10</code>的时候停下来。就可以这样设置：</p>
<p><img src="https://pic.imgdb.cn/item/6430098fa682492fcce06ce2.png" alt="在这里插入图片描述" /></p>
<p><strong>运行结果：</strong></p>
<p><img src="https://pic.imgdb.cn/item/643009b7a682492fcce0bc82.gif" alt="在这里插入图片描述" /></p>
<hr />
<h5 id="2344-添加命令"><a class="markdownIt-Anchor" href="#2344-添加命令"></a> 2.3.4.4  添加命令</h5>
<p>可以在命令行增加命令，例如，程序运行100次后，将flag置1，以达到<mark>控制程序运行的目的</mark></p>
<p><img src="https://pic.imgdb.cn/item/643009f7a682492fcce135b2.png" alt="im23" /></p>
<p><img src="https://pic.imgdb.cn/item/64300a36a682492fcce197d7.gif" alt="在这里插入图片描述" /></p>
<p>通过Command命令还能做到很多事情，比如打印信息什么的</p>
<p>例如：写入变量a 50次后打印信息：</p>
<p><img src="https://pic.imgdb.cn/item/64300a5da682492fcce1d640.png" alt="im24" /></p>
<p><img src="https://pic.imgdb.cn/item/64300a85a682492fcce21216.gif" alt="在这里插入图片描述" /></p>
<p>（👇详见下文）</p>
<p><a href="#Command ">Command 窗口操作</a></p>
<br>
<hr />
<h3 id="24-watch变量查"><a class="markdownIt-Anchor" href="#24-watch变量查"></a> 2.4  watch变量查</h3>
<h4 id="241-常规操作"><a class="markdownIt-Anchor" href="#241-常规操作"></a> 2.4.1 常规操作</h4>
<p>右键添加到变量观察窗口，或者直接选中后拖拉变量到窗口。</p>
<p>观察的对象比较广泛：</p>
<p><mark>全局/局部变量</mark>、<mark>寄存器</mark>、<mark>函数地址</mark>、<mark>数组结构体</mark>等，对于局部变量只能在变量的<mark>有效局部内</mark>才能显示具体数值。</p>
<p><img src="https://pic.imgdb.cn/item/64300adaa682492fcce29bf5.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="242-表达式操作"><a class="markdownIt-Anchor" href="#242-表达式操作"></a> 2.4.2 表达式操作</h4>
<p>表达式可进行简单的数学运算，甚至可以当做一个简单的进制转换、计算器来使用。如下所示，动态显示random的值减去70000，0xf777转换为十进制。</p>
<br>
<p><img src="https://pic.imgdb.cn/item/64300c3ba682492fcce489e5.gif" alt="m21" /></p>
<br>
<hr />
<h4 id="243-直接修改变量的值"><a class="markdownIt-Anchor" href="#243-直接修改变量的值"></a> 2.4.3 直接修改变量的值</h4>
<p>可以直接在变量窗口<strong>修改变量的值</strong>，相当于直接在修改内存。 在<strong>调pid</strong>的时候比较有用， 直接修改，不用退出编译。</p>
<p>（当然这只是<strong>临时</strong>的，不重新编译的话，下次进入debug还会是原来的值）</p>
<br>
<p><img src="https://pic.imgdb.cn/item/64300c9da682492fcce51369.gif" alt="在这里插入图片描述" /></p>
<hr />
<hr />
<h3 id="25-call-stack-locals回调栈局部变量窗口"><a class="markdownIt-Anchor" href="#25-call-stack-locals回调栈局部变量窗口"></a> 2.5  （Call Stack + Locals）回调栈局部变量窗口</h3>
<h4 id="251-常规用法"><a class="markdownIt-Anchor" href="#251-常规用法"></a> 2.5.1 常规用法</h4>
<p>打断点后，通过回调栈窗口可以看到当前函数的调用情况以及内部变量的值。</p>
<p><img src="https://pic.imgdb.cn/item/64300cbaa682492fcce551bf.png" alt="im23" /></p>
<p>当程序封装太多层时可参照如下方式进行一层一层跳转分析。</p>
<p><img src="https://pic.imgdb.cn/item/64300ce2a682492fcce59824.png" alt="im24" /></p>
<br>
<hr />
<h4 id="252-查看进入hardfault函数的位置"><a class="markdownIt-Anchor" href="#252-查看进入hardfault函数的位置"></a> 2.5.2  查看进入Hardfault函数的位置</h4>
<p>当存在<mark>Hardfault等错误</mark>以及程序死循环时，可以通过<mark>断点</mark>或<mark>停止按钮</mark>停止程序运行，在<mark>回调栈窗口</mark>查看调用</p>
<p>hardfault的位置，位置不是很准确，但是能反应大概位置，然后通过局部变量的值进行判断<mark>异常位置</mark>。下边演示</p>
<p>了数组越界引起了异常，大概定位到了前后的位置，其它的错误定位可以再研究一下。</p>
<br>
<p><img src="https://pic.imgdb.cn/item/64300d08a682492fcce5d850.gif" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h3 id="26-command-窗口操作"><a class="markdownIt-Anchor" href="#26-command-窗口操作"></a> 2.6 Command 窗口操作</h3>
<p><span id="Command" name="Command"></span></p>
<p><font face="华文彩云" color=red size=5>keil的命令调试功能很强大，用的好能解决很多问题</font></p>
<br>
<p>比如，通过执行命令函数或表达式直接实现查看与修改变量、对象、寄存器及内存。</p>
<p>（👇详见官方文档）</p>
<p><a href="https://developer.arm.com/documentation/101407/0537/Debug-Commands">command 命令</a></p>
<br>
<p>这里贴几张官方文档的图：</p>
<h4 id="261-断点命令"><a class="markdownIt-Anchor" href="#261-断点命令"></a> 2.6.1 断点命令</h4>
<p><img src="https://pic.imgdb.cn/item/64300e2aa682492fcce7810f.png" alt="im24" /></p>
<p><img src="https://pic.imgdb.cn/item/64300e2aa682492fcce78110.png" alt="在这里插入图片描述" /></p>
<h4 id="262-一般命令"><a class="markdownIt-Anchor" href="#262-一般命令"></a> 2.6.2 一般命令</h4>
<p><img src="https://pic.imgdb.cn/item/64300e2ba682492fcce781ea.png" alt="在这里插入图片描述" /></p>
<p><img src="https://pic.imgdb.cn/item/64300f06a682492fcce8d355.png" alt="im25" /></p>
<h4 id="263-内存命令和程序命令"><a class="markdownIt-Anchor" href="#263-内存命令和程序命令"></a> 2.6.3  内存命令和程序命令</h4>
<p><img src="https://pic.imgdb.cn/item/64300f37a682492fcce92398.png" alt="im26" /></p>
<p><img src="https://pic.imgdb.cn/item/64300f51a682492fcce96951.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="264-使用示例"><a class="markdownIt-Anchor" href="#264-使用示例"></a> 2.6.4 使用示例</h4>
<p><img src="https://pic.imgdb.cn/item/64300f69a682492fcce9a7f4.png" alt="在这里插入图片描述" /></p>
<p><font face="华文彩云" color=red size=5>注意：当退出调试模式之后，KEIL 将自动保存 Command 数据到文件中（也就是说在此之前你是看不到这些调试数据的）</font></p>
<p><img src="https://pic.imgdb.cn/item/64300f80a682492fcce9db8a.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="265-自定义toolbox按键"><a class="markdownIt-Anchor" href="#265-自定义toolbox按键"></a> 2.6.5 自定义TOOLBOX按键</h4>
<p>有些时候我们并不满足监控数据，还想<strong>定义一些自己的按键</strong>，比如当我按下按钮时，系统电源关闭，再按下按钮时系统电源开启等。</p>
<p>这个功能其实使用前面所说的<a href="#外设窗口">外设窗口</a> 也是完成能完成要求的，麻烦的是，如果使用外设窗口，要控制 IO 口，那你每次都得找到对应的 IO 口才行，很是麻烦，但是使用按键就会简单许多。</p>
<h4 id="2651-定义按键"><a class="markdownIt-Anchor" href="#2651-定义按键"></a> 2.6.5.1 定义按键</h4>
<h6 id="26511-可以通过建立ini文件"><a class="markdownIt-Anchor" href="#26511-可以通过建立ini文件"></a> 2.6.5.1.1 可以通过建立ini文件</h6>
<p>（👇ini文件详见）</p>
<p><a href="#ini">ini 文件</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Kill BUTTON * <span class="comment">//删除全部按键</span></span><br><span class="line">DEFINE BUTTON <span class="string">&quot;Power OFF&quot;</span>, <span class="string">&quot;GPIOB-&gt;ODR |= (0x01 &lt;&lt; 7)&quot;</span>  <span class="comment">//按键置1</span></span><br><span class="line">DEFINE BUTTON <span class="string">&quot;Power ON&quot;</span>, <span class="string">&quot;GPIOB-&gt;ODR &amp;= ~(0x01 &lt;&lt; 7)&quot;</span>  <span class="comment">//按键置1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>保存后导入</strong></p>
<p><img src="https://pic.imgdb.cn/item/64300fafa682492fccea1cec.png" alt="在这里插入图片描述" /></p>
<p><strong>之后进入 Debug 模式即可，在这里你可以看到你定义的按键：</strong></p>
<p><img src="https://pic.imgdb.cn/item/64300fd8a682492fccea7922.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h6 id="26512-通过命令窗口"><a class="markdownIt-Anchor" href="#26512-通过命令窗口"></a> 2.6.5.1.2 通过命令窗口</h6>
<p>之前说过 <strong>.ini 文件</strong> 和手工在 <strong>Command 窗口</strong>输入命令没啥区别，只是使用文件的话可以将常用命令保存下来。</p>
<p>所以直接在命令窗口写入命令也行</p>
<p><img src="https://pic.imgdb.cn/item/64300feda682492fccea9c37.png" alt="在这里插入图片描述" /></p>
<h6 id="26513-按键删除"><a class="markdownIt-Anchor" href="#26513-按键删除"></a> 2.6.5.1.3 按键删除</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Kill Button <span class="number">3</span>   <span class="comment">//移除第3个按钮  （参数为* 的话会删除所有按键）</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="26514-运行结果"><a class="markdownIt-Anchor" href="#26514-运行结果"></a> 2.6.5.1.4 运行结果</h6>
<p><img src="https://pic.imgdb.cn/item/64301012a682492fcceace84.gif" alt="在这里插入图片描述" /></p>
<p>可以看到通过自定义按键 <strong>控制io口输出</strong>，控制灯的亮灭。</p>
<hr />
<p><font face="华文彩云" color=red size=5>注意：命令调试也存在缺点</font></p>
<ul>
<li>KEIL 命令调试不支持指针，这个已经多次强调了，要实现指针的功能，只能间接使用。</li>
<li>对程序运行造成一定的影响（事实上这个不关 KEIL 的事，是调试系统本身的问题）</li>
</ul>
<p>调试器可以说是第三方监视器，虽然几乎没有侵入性（事实上对 CPU 还是有影响的），但是它还是会窃取 CPU 时钟的，而且在执行断点的时候，虽然由 ini 文件定义的函数由 KEIL 执行了，实际上上执行这些函数也是需要时间的，那这个时间怎么来，就是通过暂停 CPU 后去执行这些代码，这个你可以通过 DWT 计数器看出来，因为只有 CPU 执行了 DWT 才会计数，但是你会发现在执行这些代码时，DWT 是没有进行计数的（在 KEIL 函数的前后获取 DWT 计数，可以发现计数值不变）</p>
<p>也就是说 CPU 和 KEI 是在交替使用系统时钟的。平常来看，由于 KEIL 执行速度很快，看不出来问题，但到中断的时候却会出现问题。</p>
<br>
<hr />
<h2 id="3️⃣-itm程序跟踪"><a class="markdownIt-Anchor" href="#3️⃣-itm程序跟踪"></a> 3️⃣  ITM程序跟踪</h2>
<p><span id="ITM" name="ITM"></span></p>
<h3 id="31-itm简介"><a class="markdownIt-Anchor" href="#31-itm简介"></a> 3.1 ITM简介</h3>
<p><strong>ITM：</strong> Instrumentation Trace Macrocell，指令跟踪宏单元</p>
<p>ITM是一应用驱动的跟踪源，它支持printf类的调试手段来跟踪操作系统(OS)和应用事件，并发布判定的系统信息。ITM以包的形式发布跟踪信息，它由以下部分组成：<br />
● 软件跟踪：软件可以通过直接写ITM激发寄存器来发布包信息。<br />
● 硬件跟踪：ITM会发布由DWT产生的信息包。<br />
● 时间戳：时间戳被发布到相应的包上。ITM包含一个21位的计数器以产生时间戳。Cortex-M3的时钟或串行线观测器(Serial Wire Viewer)的位时钟率给计数器提供时钟。<br />
由ITM发送的信息包输出到TPIU(Trace Port Interface Unit)，TPIU再添加一些额外的包(参考TPIU)，然后输出完整的包序列给调试器。</p>
<p>使用ITM能做到，在keil上显示各个中断的运行时间，进入时间；打印变量波形；打印虚拟串口数据等；</p>
<p><mark>简单添加几张效果图</mark>：</p>
<p>1️⃣中断时间戳：</p>
<p><img src="https://pic.imgdb.cn/item/64301075a682492fcceb79b0.png" alt="在这里插入图片描述" /></p>
<p>2️⃣ 打印变量波形：</p>
<p><img src="https://pic.imgdb.cn/item/64301088a682492fcceb9f07.png" alt="在这里插入图片描述" /></p>
<p>3️⃣ 打印虚拟串口：</p>
<p><img src="https://pic.imgdb.cn/item/64301098a682492fccebba47.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h3 id="32-trace配置"><a class="markdownIt-Anchor" href="#32-trace配置"></a> 3.2  Trace配置</h3>
<p><span id="Trace 配置" name="Trace 配置"></span></p>
<h4 id="321-硬件准备"><a class="markdownIt-Anchor" href="#321-硬件准备"></a> 3.2.1 硬件准备</h4>
<h5 id="3211-仿真器准备"><a class="markdownIt-Anchor" href="#3211-仿真器准备"></a> 3.2.1.1 仿真器准备</h5>
<p>一个<strong>J-Link仿真器</strong>或是<strong>ST-LINK</strong>、有<strong>J-Trace</strong>更好，直接一步到位。</p>
<p>不管是什么仿真器，只要能引出VCC、GND、TMS/SWDIO、TCK/SWCLK、JTDO这5根线的话就可以尝试一下。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>连接网络</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>VCC</td>
<td>电源正，3.3V</td>
</tr>
<tr>
<td>2</td>
<td>GND</td>
<td>电源负</td>
</tr>
<tr>
<td>3</td>
<td>SWO</td>
<td>SW跟踪功能</td>
</tr>
<tr>
<td>4</td>
<td>SWDIO</td>
<td>SW数据输入输出</td>
</tr>
<tr>
<td>5</td>
<td>SWCLK</td>
<td>SW时钟信号</td>
</tr>
</tbody>
</table>
<br>
<p>这里我用的是J-Link：</p>
<p><img src="https://pic.imgdb.cn/item/64301314a682492fccf1659b.png" alt="" /></p>
<p><mark>通过平常的SWD四线接口，再加上一根SWO的飞线</mark></p>
<h5 id="3212-开发板准备"><a class="markdownIt-Anchor" href="#3212-开发板准备"></a> 3.2.1.2 开发板准备</h5>
<p>准备一个有引出 <strong><mark>PB3</mark></strong> 引脚的板子</p>
<p><img src="https://pic.imgdb.cn/item/64301315a682492fccf1686e.png" alt="在这里插入图片描述" /></p>
<p>​										<mark>图为数据手册</mark></p>
<br>
<p><font face="华文彩云" color=red size=5>我看了周围我能用的板子汇总如下：</font></p>
<p>1️⃣</p>
<p><img src="https://pic.imgdb.cn/item/64301356a682492fccf1cfe4.png" alt="" /></p>
<blockquote>
<p><strong>开发板：</strong> ACE实验室H7通用开发板</p>
<blockquote>
<p><strong>有无引出PB3：</strong>  否</p>
</blockquote>
<blockquote>
<p><strong>能否飞线：</strong>        否</p>
</blockquote>
<p><strong>说明：</strong> 因为采用50pin 0.5mm的贴片排针，故无法飞线。</p>
</blockquote>
<br>
<p>2️⃣</p>
<p><img src="https://pic.imgdb.cn/item/64301356a682492fccf1cf9f.png" alt="im26" /></p>
<blockquote>
<p><strong>开发板：</strong> ACE实验室F4系列开发板</p>
<blockquote>
<p><strong>有无引出PB3：</strong>  否</p>
</blockquote>
<blockquote>
<p><strong>能否飞线：</strong>        能</p>
</blockquote>
<p><strong>说明：</strong> 可从最小系统板飞线，也可从拓展板底部飞线</p>
</blockquote>
<br>
<img src="https://pic.imgdb.cn/item/64301388a682492fccf22237.png" alt="在这里插入图片描述" style="zoom:67%;" />
<p><font face="华文彩云" color=red size=5>最终我是选择了用F4的板子，飞线进行测试，之后可以让硬件在设计的时候就引出来PB3</font></p>
<p>3️⃣</p>
<p><img src="https://pic.imgdb.cn/item/643013a2a682492fccf24f3d.png" alt="在这里插入图片描述" /></p>
<blockquote>
<p><strong>开发板：</strong> 正点原子精英板</p>
<blockquote>
<p><strong>有无引出PB3：</strong>  有</p>
</blockquote>
<blockquote>
<p><strong>能否飞线：</strong>        能</p>
</blockquote>
<p><strong>说明：</strong> 调起来怪怪的，能用但不想用，也没必要，而且还要外接电源供电</p>
</blockquote>
<br>
<p>4️⃣</p>
<p><img src="https://pic.imgdb.cn/item/643013c1a682492fccf2887b.png" alt="在这里插入图片描述" /></p>
<blockquote>
<p><strong>开发板：</strong> RM官方开发板C型</p>
<blockquote>
<p><strong>有无引出PB3：</strong>  无</p>
</blockquote>
<blockquote>
<p><strong>能否飞线：</strong>        否</p>
</blockquote>
<p><strong>说明：</strong> PB3被用于SPI1_CLK ,也无法复用😭</p>
</blockquote>
<hr />
<h4 id="322-软件配置"><a class="markdownIt-Anchor" href="#322-软件配置"></a> 3.2.2 软件配置</h4>
<h5 id="3221-cubemx配置"><a class="markdownIt-Anchor" href="#3221-cubemx配置"></a> 3.2.2.1 CUBEMX配置</h5>
<p>选择异步跟踪模式，此时PB3将会自动定义为SWO端口。</p>
<p><img src="https://pic.imgdb.cn/item/64301576e03e90d874574b8e.png" alt="在这里插入图片描述" /></p>
<h5 id="3222-keil软件设置"><a class="markdownIt-Anchor" href="#3222-keil软件设置"></a> 3.2.2.2 KEIL软件设置</h5>
<p><strong>在debug 的Trace窗口进行配置：</strong></p>
<p>确保用的是<mark>SW模式</mark> :</p>
<p><img src="https://pic.imgdb.cn/item/6430158fa682492fccf36b81.png" alt="在这里插入图片描述" /></p>
<hr />
<h3 id="33-keil调试的ini文件用法"><a class="markdownIt-Anchor" href="#33-keil调试的ini文件用法"></a> 3.3  keil调试的ini文件用法</h3>
<p><span id="ini" name="ini"></span></p>
<p><font face="华文彩云" color=red size=5>通过ini文件，可以动态的分析调试，也可以还原bug发生的情景。</font></p>
<p>（感觉很有用，但我自己只是简单测试，就不乱说了，后面附上文章自己看）</p>
<br>
<hr />
<h4 id="331-ini-文件使用"><a class="markdownIt-Anchor" href="#331-ini-文件使用"></a> 3.3.1 ini 文件使用</h4>
<p>ini文件可解释为一个配置文件，相当于一个 <strong>.C文件</strong> ，这个文件的执行本质与仿真时的<strong>命令行</strong>执行一致(如果觉得不麻烦可以在命令行中敲所有的命令而不用加载ini文件).</p>
<p><strong><mark>ini文件的加载主要在两个地方：</mark></strong></p>
<p>1️⃣ 点击调试时会加载图片所示的ini文件:</p>
<p><img src="https://pic.imgdb.cn/item/6430163ce03e90d87457c76e.png" alt="在这里插入图片描述" /></p>
<br>
<p>2️⃣ 调试时使用专用管理器调用</p>
<p><img src="https://pic.imgdb.cn/item/643017aaa682492fccf42d9a.png" alt="" /></p>
<p><img src="https://pic.imgdb.cn/item/643019890d2dde577798531b.png" alt="" /></p>
<p>调用ini主要用来生成一些配置，如打开<strong>itm端口</strong>、<strong>生成log</strong>、<strong>设置断点</strong>等功能，下边介绍一下小功能。</p>
<br>
<hr />
<h4 id="332-新建按钮"><a class="markdownIt-Anchor" href="#332-新建按钮"></a> 3.3.2 <strong>新建按钮</strong></h4>
<p>使用任何编辑器新建后缀为.ini的文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE BUTTON <span class="string">&quot;显示random值&quot;</span>, <span class="string">&quot;printf (\&quot;random=%04XH\\n\&quot;,random)&quot;</span></span><br><span class="line">DEFINE BUTTON <span class="string">&quot;置位&quot;</span>, <span class="string">&quot;GPIOF-&gt;ODR |= (1&lt;&lt;9)&quot;</span></span><br><span class="line">DEFINE BUTTON <span class="string">&quot;复位&quot;</span>, <span class="string">&quot;GPIOF-&gt;ODR &amp;= ~(1&lt;&lt;9)&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样即可实现按钮的多个定义。</p>
<br>
<hr />
<h4 id="333-功能函数"><a class="markdownIt-Anchor" href="#333-功能函数"></a> 3.3.3 功能函数</h4>
<p>命令行不能直接调用函数，与之前讲过的一样，这里的功能函数仅用来调试使用，可以定义一些打印输出，修改变量、外设寄存器值等操作。</p>
<p>使用任何编辑器新建后缀为.ini的文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FUNC <span class="type">void</span> <span class="title function_">clearValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> random =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">FUNC <span class="type">void</span> <span class="title function_">LEDON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> GPIOF-&gt;ODR |= (<span class="number">1</span>&lt;&lt;<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line">DEFINE BUTTON <span class="string">&quot;CLEAR&quot;</span>,<span class="string">&quot;clearValue();&quot;</span></span><br><span class="line">DEFINE BUTTON <span class="string">&quot;LED&quot;</span>,<span class="string">&quot;LEDON();&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上内容为定义了两个函数清除变量<strong>clearValue</strong>和打开LED灯<strong>LEDON</strong>，然后将两个函数做成<strong>toolbox</strong>按钮。</p>
<br>
<hr />
<h4 id="334-不复位在线调试"><a class="markdownIt-Anchor" href="#334-不复位在线调试"></a> <strong>3.3.4 不复位在线调试</strong></h4>
<h6 id="3341-使用swd4线连接目标板jtag接口会产生复位"><a class="markdownIt-Anchor" href="#3341-使用swd4线连接目标板jtag接口会产生复位"></a> 3.3.4.1 使用SWD4线连接目标板(Jtag接口会产生复位)</h6>
<h6 id="3342-外部工程目录下创建一个noresetdbgini配置文件内容为"><a class="markdownIt-Anchor" href="#3342-外部工程目录下创建一个noresetdbgini配置文件内容为"></a> 3.3.4.2 外部工程目录下创建一个noresetDBG.ini配置文件，内容为：</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOAD %L INCREMENTAL</span><br></pre></td></tr></table></figure>
<p>没有这个也可以不复位调试，但打不了断点</p>
<p><img src="https://pic.imgdb.cn/item/643019ae0d2dde577798bc75.png" alt="" /></p>
<br>
<hr />
<h6 id="3343-取消勾选load-application-at-startup加载调试初始化配置"><a class="markdownIt-Anchor" href="#3343-取消勾选load-application-at-startup加载调试初始化配置"></a> 3.3.4.3 取消勾选<code>Load Application at Startup</code>，加载调试初始化配置</h6>
<p><img src="https://pic.imgdb.cn/item/643019c20d2dde577798fc01.png" alt="" /></p>
<p><em>(2也可省略，直接在仿真后的command窗口输入效果是一样的)</em></p>
<br>
<p><img src="https://pic.imgdb.cn/item/643019e40d2dde5777994369.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h6 id="3344-取消调试器连接后的复位这个建议不连接板子只插烧写器进行设置否则会造成复位一次"><a class="markdownIt-Anchor" href="#3344-取消调试器连接后的复位这个建议不连接板子只插烧写器进行设置否则会造成复位一次"></a> 3.3.4.4 取消调试器连接后的复位(这个建议不连接板子，只插烧写器进行设置，否则会造成复位一次)</h6>
<p><img src="https://pic.imgdb.cn/item/64301a14e03e90d874595240.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h6 id="3345-调试时目标更新也取消勾选这一步在f407上调试发现不操作也能实现可有可无的样子"><a class="markdownIt-Anchor" href="#3345-调试时目标更新也取消勾选这一步在f407上调试发现不操作也能实现可有可无的样子"></a> 3.3.4.5 调试时目标更新也取消勾选(这一步在F407上调试发现不操作也能实现，可有可无的样子)</h6>
<p><img src="https://pic.imgdb.cn/item/64301a14e03e90d874595240.png" alt="在这里插入图片描述" /></p>
<h6 id="3346-效果测试"><a class="markdownIt-Anchor" href="#3346-效果测试"></a> 3.3.4.6 效果测试:</h6>
<p><img src="https://pic.imgdb.cn/item/64301a850d2dde57779cc239.gif" alt="在这里插入图片描述" /></p>
<br>
<p><img src="https://pic.imgdb.cn/item/64301abd0d2dde57779e1d61.gif" alt="在这里插入图片描述" /></p>
<p>（👇详见下文）</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDgyNzgyMw%3D%3D&amp;chksm=fc035d33cb74d425b8daf8e162aa4f24b2993698426823b7c77f25e38d7c7fa6730f202f995f&amp;idx=1&amp;mid=2247483891&amp;scene=21&amp;sn=569d5e4f49cfff2b59da5b68b707fe51#wechat_redirect">KEIL 调试的ini文件有什么用</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDgyNzgyMw==&amp;mid=2247484451&amp;idx=1&amp;sn=73a0e08b6fbe15982fecd70c56f1ef66&amp;chksm=fc0358e3cb74d1f56616fc0d8d5148ee3382280bb95de908b4adff1eddcdb3cf446c307c32b1&amp;scene=178&amp;cur_album_id=1341389839287156737#rd">BUG 终结者，现场抓获！|颠覆认知</a></p>
<br>
<hr />
<h3 id="34-打印变量波形"><a class="markdownIt-Anchor" href="#34-打印变量波形"></a> 3.4  打印变量波形</h3>
<p>keil本身是有逻辑分析仪的，你们应该都知道，但一般我们调车的时候<strong>打印波形</strong>都是用的<font face="宋体" color=red size=5>J-Scope</font>，因为正常我</p>
<p>们不配置<a href="#ini">ITM</a>的话，波形是不会刷新的，就一直卡在那里。</p>
<h4 id="341-使用方法"><a class="markdownIt-Anchor" href="#341-使用方法"></a> 3.4.1 使用方法</h4>
<p>直接将变量添加至<code>analyzer</code>窗口就行</p>
<p><font face="华文彩云" color=red size=5>注意：最多只能有四个变量</font></p>
<br>
<p><img src="https://pic.imgdb.cn/item/64301b400d2dde5777a145da.gif" alt="" /></p>
<br>
<hr />
<h4 id="342-与j-scope的区别"><a class="markdownIt-Anchor" href="#342-与j-scope的区别"></a> 3.4.2 与J-Scope的区别</h4>
<ul>
<li>
<p><mark>J-Scope</mark>： 采样频率高，波形更加准确，可以将不同波形放在一起对比； 例如，将pitch轴的<strong>实际曲线</strong>和设<strong>定</strong></p>
<p><strong>曲线</strong>对比，可以直观的看出当前的<strong>闭环控制效果</strong></p>
</li>
<li>
<p><mark>逻辑分析仪：</mark>  方便快捷，直接将变量拖入即可显示，前提是已经配置好了；缩放范围大，可更直观的看出整</p>
<p>体的趋势； 可查看io端口的电平变化。</p>
</li>
</ul>
<br>
<hr />
<h4 id="343-使用示例"><a class="markdownIt-Anchor" href="#343-使用示例"></a> 3.4.3 使用示例：</h4>
<p>通过逻辑分析仪 <strong>打印电机速度曲线</strong>：</p>
<br>
<p><img src="https://pic.imgdb.cn/item/64301bd20d2dde5777a44f0d.gif" alt="在这里插入图片描述" /></p>
<hr />
<br>
<h3 id="35-虚拟串口"><a class="markdownIt-Anchor" href="#35-虚拟串口"></a> 3.5 虚拟串口</h3>
<p>直接用虚拟串口<strong>打印信息</strong>，不再需要占用串口来打印信息：</p>
<p>利用这个函数，<strong>直接调用</strong>就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  \brief   ITM Send Character</span></span><br><span class="line"><span class="comment">  \details Transmits a character via the ITM channel 0, and</span></span><br><span class="line"><span class="comment">           \li Just returns when no debugger is connected that has booked the output.</span></span><br><span class="line"><span class="comment">           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.</span></span><br><span class="line"><span class="comment">  \param [in]     ch  Character to transmit.</span></span><br><span class="line"><span class="comment">  \returns            Character to transmit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">ITM_SendChar</span> <span class="params">(<span class="type">uint32_t</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (((ITM-&gt;TCR &amp; ITM_TCR_ITMENA_Msk) != <span class="number">0UL</span>) &amp;&amp;      <span class="comment">/* ITM enabled */</span></span><br><span class="line">      ((ITM-&gt;TER &amp; <span class="number">1UL</span>               ) != <span class="number">0UL</span>)   )     <span class="comment">/* ITM Port #0 enabled */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (ITM-&gt;PORT[<span class="number">0U</span>].u32 == <span class="number">0UL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __NOP();</span><br><span class="line">    &#125;</span><br><span class="line">    ITM-&gt;PORT[<span class="number">0U</span>].u8 = (<span class="type">uint8_t</span>)ch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数相当于串口字节发送函数，只不过串口字节发送函数是通过串口传输的，这里就通过JTDO这根线传输。然后你可能需要使用printf函数打印，那么重定向即可</p>
<p><img src="https://pic.imgdb.cn/item/64301bed0d2dde5777a4ca4a.png" alt="在这里插入图片描述" /></p>
<p><strong>查看输出：</strong></p>
<p><img src="https://pic.imgdb.cn/item/64301c130d2dde5777a566eb.gif" alt="在这里插入图片描述" /></p>
<hr />
<h3 id="36-统计进入中断的数据"><a class="markdownIt-Anchor" href="#36-统计进入中断的数据"></a> 3.6 统计进入中断的数据</h3>
<br>
<h4 id="351-trace-exceptions简介"><a class="markdownIt-Anchor" href="#351-trace-exceptions简介"></a> 3.5.1 Trace Exceptions简介</h4>
<p><strong>Trace Exceptions</strong>窗口显示有关跟踪的异常和中断的统计数据，如<strong>在此中断中花费的最短和最长时间</strong>、 <strong>上次输入此异常的时间</strong>等。</p>
<br>
<p><mark>这是官方文档的介绍：</mark></p>
<p><img src="https://pic.imgdb.cn/item/64301c580d2dde5777a666ce.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="352-event-counters简介"><a class="markdownIt-Anchor" href="#352-event-counters简介"></a> 3.5.2 Event Counters简介</h4>
<p>事件计数，用于统计<mark>总指令</mark>、<mark>异常</mark>、<mark>休眠</mark>、<mark>存储</mark>、<mark>折叠</mark>指令。<br />
<img src="https://pic.imgdb.cn/item/64301c780d2dde5777a6fd98.png" alt="在这里插入图片描述" /></p>
<p>👇  <mark>官方文档介绍：</mark></p>
<p><img src="https://pic.imgdb.cn/item/64301c960d2dde5777a75ec4.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h4 id="353-使用示例"><a class="markdownIt-Anchor" href="#353-使用示例"></a> 3.5.3 使用示例</h4>
<p>通过<strong>can分析仪</strong>，发送can数据，并<strong>查看统计情况</strong>：</p>
<p><img src="https://pic.imgdb.cn/item/64301cbd0d2dde5777a7fb52.webp" alt="" /></p>
<br>
<hr />
<br>
<h2 id="4️⃣-其它调试工具"><a class="markdownIt-Anchor" href="#4️⃣-其它调试工具"></a> 4️⃣  其它调试工具</h2>
<h3 id="41-systemview"><a class="markdownIt-Anchor" href="#41-systemview"></a> 4.1 Systemview</h3>
<p><span id="Systemview" name="Systemview"></span></p>
<h4 id="411-systemview简介"><a class="markdownIt-Anchor" href="#411-systemview简介"></a> 4.1.1 Systemview简介</h4>
<p><a href="https://www.segger.com/products/development-tools/systemview/">SystemView</a>是SEGGER开发的针对嵌入式系统的trace工具，支持多种RTOS，也支持自定义OS的移植（需实现trace API，参见User</p>
<p>Manual）。其核心基于<strong>SEGGER RTT</strong>，一个<strong>Host-Targe</strong>t间的通信框架，可通过多种方式连接，除J-LINK之外还可以使用串口及TCP-IP协</p>
<p>议，对非商业用途免费且无功能限制。</p>
<p>SystemView 是一个用于虚拟分析嵌入式系统的工具包。SystemView 可以完整的深入观察一个应用程序的运行时行为，这远远超出一个</p>
<p>调试器所能提供的。这在开发和处理具有多个线程和事件的复杂系统时尤其有效。</p>
<p><a href="http://www.segger.com/products/development-tools/systemview/">官方介绍</a></p>
<br>
<hr />
<h4 id="412-使用效果"><a class="markdownIt-Anchor" href="#412-使用效果"></a> 4.1.2 使用效果</h4>
<p><img src="https://pic.imgdb.cn/item/64301ce80d2dde5777a8c739.png" alt="在这里插入图片描述" /></p>
<p><a href="https://blog.csdn.net/weixin_51330198/article/details/126063836">SystemView 介绍与移植</a></p>
<hr />
<h3 id="42-j-link的rtt打印"><a class="markdownIt-Anchor" href="#42-j-link的rtt打印"></a> 4.2  J-Link的RTT打印</h3>
<p>可以通过占用一部分内存空间来实现非在线调试时swd端口的数据输出，一般用在串口紧张时代替串口实现printf调试。</p>
<p>我没用过，所以具体见网上教程</p>
<p>（👇详见下文）</p>
<p><a href="https://blog.csdn.net/qq1291917670/article/details/119414735?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-119414735-blog-120769285.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-119414735-blog-120769285.pc_relevant_default&amp;utm_relevant_index=6">JLink的RTT使用</a></p>
<hr />
<h3 id="43-j-scope"><a class="markdownIt-Anchor" href="#43-j-scope"></a> 4.3 J-Scope</h3>
<h4 id="431-j-scope-简介"><a class="markdownIt-Anchor" href="#431-j-scope-简介"></a> 4.3.1  J-Scope 简介</h4>
<p>J-Scope是SEGGER公司推出的，可以在目标MCU运行时，实时分析数据并图形化显示的软件。它不需要SWO或目</p>
<p>标上的任何额外引脚等功能，但使用可用的标准调试端口。J-Scope可以以类似示波器的方式显示多个变量的值。</p>
<p><font face="宋体" color=red size=5>可以用于平时调车的时候，打印变量波形，如对比电机设定曲线和实际曲线来观察闭环控制效果。</font></p>
<h4 id="432-使用效果"><a class="markdownIt-Anchor" href="#432-使用效果"></a> 4.3.2 使用效果</h4>
<p><mark>如图是六轴陀螺仪三轴的工作曲线：</mark></p>
<p><img src="https://pic.imgdb.cn/item/64301d140d2dde5777a9999d.png" alt="在这里插入图片描述" /></p>
<br>
<p>（👇<strong>官网</strong>及<strong>使用教程</strong>）</p>
<p><a href="https://www.segger.com/products/debug-probes/j-link/tools/j-scope/">J-Scope 官网</a></p>
<p><a href="https://blog.csdn.net/qq_23852045/article/details/108837881">使用教程</a></p>
<br>
<hr />
<h3 id="44-matlab"><a class="markdownIt-Anchor" href="#44-matlab"></a> 4.4 MATLAB</h3>
<p>作为一个工科生，<mark>MATLAB</mark>有多重要就不用多说了吧，基本什么都能干。 比如，我们调车的时候，云台的串级pid大部分都是用的经验调</p>
<p>参。如果能熟练掌握<mark>MATLAB</mark> ,就可以通过仿真来整定参数。</p>
<p><img src="https://pic.imgdb.cn/item/64301d330d2dde5777aa1643.png" alt="在这里插入图片描述" /></p>
<p>（👇具体的实现方法可以参考这两篇文章）</p>
<p><a href="https://bbs.robomaster.com/thread-4941-1-1.html">系统辨识基础</a></p>
<p><a href="https://bbs.robomaster.com/thread-5059-1-1.html">云台传递函数</a></p>
<br>
<hr />
<br>
<h2 id="️参考文章"><a class="markdownIt-Anchor" href="#️参考文章"></a> ❗️参考文章</h2>
<p><a href="https://developer.arm.com/documentation/101407/0537/Debugging/Code-and-Data-Trace--Cortex-M-/Tracepoint-Expressions">官方文档</a></p>
<p><a href="https://blog.csdn.net/weixin_42876465/article/details/107171974?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165881686416780357239382%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165881686416780357239382&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-107171974-null-null.185%5Ev2%5Econtrol&amp;utm_term=%E8%B0%83%E8%AF%95&amp;spm=1018.2226.3001.4450"> keil 调试经验总结</a></p>
<p><a href="https://blog.csdn.net/weixin_42876465/article/details/86545913">STM32调试利器之ITM</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDgyNzgyMw%3D%3D&amp;chksm=fc035d33cb74d425b8daf8e162aa4f24b2993698426823b7c77f25e38d7c7fa6730f202f995f&amp;idx=1&amp;mid=2247483891&amp;scene=21&amp;sn=569d5e4f49cfff2b59da5b68b707fe51#wechat_redirect">KEIL 调试的 ini 文件有什么用</a></p>
<p><a href="https://blog.csdn.net/weixin_46623350/article/details/105305426">STM32开发，通过SWO功能输出Printf函数到Utility</a></p>
]]></content>
      <categories>
        <category>stm32</category>
        <category>调试</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>单片机</tag>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2023/04/06/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="嵌入式c语言补充"><a class="markdownIt-Anchor" href="#嵌入式c语言补充"></a> 嵌入式C语言补充</h1>
<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.7.28」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em></p>
<p><strong>摘要：</strong></p>
<p><strong>简介：</strong></p>
</blockquote>
<br>
<hr />
<br>
<span id="more"></span>
<p>⭐️<font face="华文行楷" color=black size=7> 目录</font></p>
<p>[TOC]</p>
<br>
<hr />
<br>
<p><a href="https://blog.csdn.net/as480133937/article/details/100138838">链接</a></p>
<h4 id="221-基本公式"><a class="markdownIt-Anchor" href="#221-基本公式"></a> 2.2.1 <em><strong>基本公式:</strong></em></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>V</mi><mi>α</mi></msub><mo>=</mo><mtext> </mtext><msub><mi>V</mi><mi>d</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><msub><mi>V</mi><mi>q</mi></msub><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>V</mi><mi>β</mi></msub><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mi>V</mi><mi>d</mi></msub><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><msub><mi>V</mi><mi>q</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}

V_\alpha =\ V_d\cdot\cos{\theta}\ -\ V_q\cdot\sin{\theta}  \\
\\
V_\beta\ =\ V_d\cdot\sin{\theta}\ +\ V_q\cdot\cos{\theta}  \\ 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h4 id="551-数据传输"><a class="markdownIt-Anchor" href="#551-数据传输"></a> 5.5.1  数据传输</h4>
<blockquote>
<p>用于传输浮点数据</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">f_data</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在进行数据传输的时候会方便很多，比如<strong>串口传输</strong>只需要把这个数组 <code>byte[4]</code> 进行传输就可以了。</p>
<img src="https://pic.imgdb.cn/item/6301e24a16f2c2beb15305f2.png" alt="image-20220715133600887" style="zoom: 33%;" />
<h3 id="13-无感foc控制流程"><a class="markdownIt-Anchor" href="#13-无感foc控制流程"></a> 1.3 无感FOC控制流程</h3>
<p><img src="/pic/image-20221004205036856.png" alt="image-20221004205036856" /></p>
<p><strong>反park变换 ：</strong>  由直流信息转变为交流信息，把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 和D轴Q轴信息进行合成 为一个交流信息</p>
<hr />
<h3 id="4️⃣"><a class="markdownIt-Anchor" href="#4️⃣"></a> 4️⃣</h3>
<br>
]]></content>
  </entry>
  <entry>
    <title>SystemView 介绍与移植</title>
    <url>/2023/04/08/SystemView%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.7.20」</em>    第一版</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em><br />
<br></p>
<p><strong>version :</strong>    <em>v2.0</em>      <em>「2022.7.21」</em>    添加部分漏掉的内容[详见](#  3.1 补充)</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em><br />
<br></p>
<p><strong>摘要：</strong>  <em>介绍systemview，以及移植过程</em></p>
<p><strong>简介：</strong> <em>前几天在看RM官方代码(<strong>RoboRTS-Firmware-icra2021</strong>)时，看到其中对SystemView的应用，稍微花了点时间研究了一下，感觉挺有用的，记录一下</em></p>
</blockquote>
<span id="more"></span>
<br>
<hr />
<h3 id="0️⃣前言"><a class="markdownIt-Anchor" href="#0️⃣前言"></a> 0️⃣前言</h3>
<p>在使用<a href="https://freertos.org/">FreeRTOS</a>进行应用开发时经常会遇到普通的方式难以调试的问题，如栈内存不足等等，同时也希望对运行的多个Task进行实时的</p>
<p>性能及资源占用的分析，通常的调试手段在这里就变的心有余而力不足了。以FreeRTOS为例，如何在长时间的运行过程中收集调试数据</p>
<p>进行分析，以及如何调试不同的组件（如Queue，Notification，Semaphore等等）？这个时候就需要Trace工具帮忙了。针对RTOS的</p>
<p>Trace需求，接下来将针对SEGGER开发的SystemView Trace工具进行介绍。</p>
<hr />
<h3 id="1️⃣什么是systemview"><a class="markdownIt-Anchor" href="#1️⃣什么是systemview"></a> 1️⃣<strong>什么是SystemView？</strong></h3>
<p><a href="https://www.segger.com/products/development-tools/systemview/">SystemView</a>是SEGGER开发的针对嵌入式系统的trace工具，支持多种RTOS，也支持自定义OS的移植（需实现trace API，参见User</p>
<p>Manual）。其核心基于<strong>SEGGER RTT</strong>，一个<strong>Host-Targe</strong>t间的通信框架，可通过多种方式连接，除J-LINK之外还可以使用串口及TCP-IP协</p>
<p>议，对非商业用途免费且无功能限制。</p>
<p>SystemView 是一个用于虚拟分析嵌入式系统的工具包。SystemView 可以完整的深入观察一个应用程序的运行时行为，这远远超出一个</p>
<p>调试器所能提供的。这在开发和处理具有多个线程和事件的复杂系统时尤其有效。</p>
<p><a href="http://www.segger.com/products/development-tools/systemview/">官方介绍</a></p>
<p>SystemView的原理简单来讲是这样的：首先上位机PC端有一个处理程序，下位机ARM上需增加部分代码，用于记录嵌入式系统的一些数</p>
<p>据，通过连接的仿真器接口将数据传输到上位机，然后PC端的处理程序处理这些数据，由于数据传输使用的是<strong>SEGGER J-link</strong>的实时传输</p>
<p>技术（RTT），所以<strong>SystemView</strong>可以实时分析和展示数据。分析的内容包括中断、任务、软件定时器执行的时间，切换的时间，以及发</p>
<p>生的事件等，这些分析都是实时的，丝毫不影响下位机的运行。这样就可以验证我们设计的整个嵌入式系统是否按照我们的预期在工作，</p>
<p>比如任务的<mark>切换逻辑</mark>，<mark>中断的触发</mark>等。它可以应用于带有RTOS的系统，也支持裸机，对于下位机资源的消耗量也是比较少的。</p>
<hr />
<hr />
<h3 id="2️⃣-测试环境"><a class="markdownIt-Anchor" href="#2️⃣-测试环境"></a> 2️⃣ 测试环境</h3>
<blockquote>
<p><strong>开发板：</strong>             <em>ACE实验室H7通用开发板</em>   //   ACE实验室哨兵H7云台板</p>
<blockquote>
<p><strong>主控芯片：</strong>	<em>STM32H750VBT6</em></p>
</blockquote>
<blockquote>
<p><strong>CPU：</strong>			<em>Cortex-M7</em></p>
</blockquote>
<blockquote>
<p><strong>最高主频：</strong>     480MHZ</p>
</blockquote>
<p><strong>测试程序：</strong>     			  <em>[2022_sentryH750_v1.3.5]</em>  / <em>[systemview_test]</em></p>
<blockquote>
<p><strong>FreeRTOS版本：</strong> <em>v10.3.1</em></p>
</blockquote>
<blockquote>
<p><strong>FreeRTOS说明：</strong>  <em>FreeRTOS为STM32CubeMX配置的未修改版本。</em></p>
</blockquote>
<p><strong>开发平台：</strong>	    <em>VSCODE、MDK-ARM</em></p>
<blockquote>
<p><strong>程序编辑：</strong>    <em>VSCODE</em></p>
</blockquote>
<blockquote>
<p><strong>程序调试：</strong>     <em>MDK-ARM     [ v 5.35.0.2]</em></p>
</blockquote>
<p><strong>调试设备：</strong>			<em>J-Link仿真器 ：    [ACE - Sentry-哨兵]  /  [Sentry]</em></p>
<p><strong>Systemview 程序包：</strong>   <em>SystemView_Windows_V332_x86</em></p>
<blockquote>
<p><a href="https://www.segger.com/products/development-tools/systemview/">下载链接</a></p>
</blockquote>
</blockquote>
<hr />
<h3 id="3️⃣移植过程"><a class="markdownIt-Anchor" href="#3️⃣移植过程"></a> 3️⃣移植过程</h3>
<h4 id="pc端程序包下载"><a class="markdownIt-Anchor" href="#pc端程序包下载"></a> PC端程序包下载：</h4>
<p><em>在官网上下载Systemview程序包</em></p>
<p><img src="https://pic.imgdb.cn/item/64311f430d2dde57773effea.png" alt="在这里插入图片描述" /></p>
<h4 id="window端的程序有两种"><a class="markdownIt-Anchor" href="#window端的程序有两种"></a> <strong>window端的程序有两种</strong></h4>
<p><strong>安装包</strong></p>
<p>从<a href="http://www.segger.com/systemview.html">官网</a>下载最新的DEB包或者RPM包并执行。安装向导会指引完成安装。</p>
<p><strong>可移植压缩包</strong></p>
<p>从<a href="http://www.segger.com/systemview.html">官网</a>下载最新的存档，解压到系统的任意目录。<br />
这种方式不需要安装，解压后就可以直接使用程序包内容。</p>
<hr />
<h4 id="代码移植"><a class="markdownIt-Anchor" href="#代码移植"></a> 代码移植</h4>
<p>将程序包内<code>SEGGER</code> 目录下代码以及 <code>Sample</code> 中的<strong>FreeRTOS代码</strong>添加到项目中。</p>
<h6 id="1-首先是config文件夹下面的所有文件"><a class="markdownIt-Anchor" href="#1-首先是config文件夹下面的所有文件"></a> <em><strong>1.  首先是<code>Config</code>文件夹下面的所有文件。</strong></em></h6>
<p><img src="https://pic.imgdb.cn/item/64311f790d2dde57773f56e7.png" alt="在这里插入图片描述" /></p>
<h6 id="2-根据自己的rtos版本选择系统配置文件我的是-freertos-v1031-选择用-freertosv10"><a class="markdownIt-Anchor" href="#2-根据自己的rtos版本选择系统配置文件我的是-freertos-v1031-选择用-freertosv10"></a> <strong>2.  根据自己的RTOS版本选择系统配置文件（我的是 <em>FreeRTOS v10.3.1</em>  选择用 FreeRTOSV10）</strong></h6>
<p><img src="https://pic.imgdb.cn/item/64311f960d2dde57773f808b.png" alt="在这里插入图片描述" /></p>
<h6 id="3-rtt相关文件"><a class="markdownIt-Anchor" href="#3-rtt相关文件"></a> <strong>3.   RTT相关文件</strong></h6>
<p><img src="https://pic.imgdb.cn/item/64311fb10d2dde57773fa45e.png" alt="在这里插入图片描述" /></p>
<h6 id="4-放进项目里面的systemview文件夹"><a class="markdownIt-Anchor" href="#4-放进项目里面的systemview文件夹"></a> <strong>4.    放进项目里面的systemview文件夹</strong></h6>
<p><img src="https://pic.imgdb.cn/item/64311fc40d2dde57773fbefd.png" alt="在这里插入图片描述" /></p>
<h6 id="5-程序添加"><a class="markdownIt-Anchor" href="#5-程序添加"></a> 5.  程序添加</h6>
<ol>
<li>在<code>FreeRTOS.h</code> 中添加  <code>#include &quot;SEGGER_SYSVIEW_FreeRTOS.h&quot;</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SEGGER_SYSVIEW_Conf();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64311fd40d2dde57773fd3fe.png" alt="在这里插入图片描述" /></p>
<ol start="2">
<li>在<code>main.c</code>里面添加<code>#include &quot;SEGGER_SYSVIEW.h&quot;</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SEGGER_SYSVIEW.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64311fe50d2dde57773feb85.png" alt="在这里插入图片描述" /></p>
<ol start="3">
<li><em>然后还需要在系统启动前添加segger systemview的初始化</em></li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  systemview 初始化 */</span></span><br><span class="line">   <span class="built_in">SEGGER_SYSVIEW_Conf</span>();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/64311ff90d2dde5777400992.png" alt="在这里插入图片描述" /></p>
<h6 id="31-补充"><a class="markdownIt-Anchor" href="#31-补充"></a> 3.1 补充</h6>
<p>还要在系统启动前启动DWT计数器</p>
<p><img src="https://pic.imgdb.cn/item/643120110d2dde5777402b8f.png" alt="在这里插入图片描述" /></p>
<p><em>[默认情况下SystemView会从DWT的Cycle counter获取系统当前周期数用于生成时间戳  ;  但在STM32CubeMX的初始化代码中该计数器默认未启用，在这里手工启用。 <mark><strong>详见（stm32延时方式 dwt.pdf）</strong></mark>]</em></p>
<ol start="4">
<li>在<code>FreeRTOSConfig.h</code>中添加宏定义</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_pxTaskGetStackStart     1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/643120520d2dde5777407b3e.png" alt="在这里插入图片描述" /></p>
<ol start="5">
<li>取消勾选keil的GNU勾选模式</li>
</ol>
<p><em>[不然会报错]</em></p>
<p><img src="https://pic.imgdb.cn/item/6431207d0d2dde577740a6b8.png" alt="在这里插入图片描述" /></p>
<p>​														<mark><em>环境问题（未解决）</em></mark></p>
<p><em>[ps: 取消之后目前已知问题，会导致print 重定义出问题]</em></p>
<p><img src="https://pic.imgdb.cn/item/643120900d2dde577740bcc8.png" alt="在这里插入图片描述" /></p>
<p>​													<mark>暂时是注释解决</mark></p>
<p><strong>到这里就完成了在STM32上的程序移植</strong>。</p>
<hr />
<h3 id="4️⃣-使用过程"><a class="markdownIt-Anchor" href="#4️⃣-使用过程"></a> 4️⃣ 使用过程</h3>
<h5 id="1-启动systemview"><a class="markdownIt-Anchor" href="#1-启动systemview"></a> 1. 启动SystemView</h5>
<p><img src="https://pic.imgdb.cn/item/643120aa0d2dde577740d838.png" alt="在这里插入图片描述" /></p>
<h5 id="2-可能会弹出警告说没有商业许可不管他暂时没发现问题"><a class="markdownIt-Anchor" href="#2-可能会弹出警告说没有商业许可不管他暂时没发现问题"></a> 2. 可能会弹出警告，说没有商业许可；不管他，暂时没发现问题</h5>
<p><img src="https://pic.imgdb.cn/item/643120ce0d2dde577741005f.png" alt="在这里插入图片描述" /></p>
<h5 id="3-systemview将加载并分析这些数据展示加载的记录的系统信息"><a class="markdownIt-Anchor" href="#3-systemview将加载并分析这些数据展示加载的记录的系统信息"></a> 3. SystemView将加载并分析这些数据，展示加载的记录的系统信息</h5>
<p><img src="https://pic.imgdb.cn/item/643120f20d2dde5777412621.png" alt="在这里插入图片描述" /></p>
<h5 id="4-点击开始记录"><a class="markdownIt-Anchor" href="#4-点击开始记录"></a> 4. 点击开始记录</h5>
<p><img src="https://pic.imgdb.cn/item/643121070d2dde5777413fd1.png" alt="在这里插入图片描述" /></p>
<h5 id="5-选择jlink"><a class="markdownIt-Anchor" href="#5-选择jlink"></a> 5. 选择JLink</h5>
<p><img src="https://pic.imgdb.cn/item/6431211a0d2dde57774156d2.png" alt="在这里插入图片描述" /></p>
<h5 id="6选择目标板的信息这里我的以及搞过了没弹出来用的网图"><a class="markdownIt-Anchor" href="#6选择目标板的信息这里我的以及搞过了没弹出来用的网图"></a> 6.选择目标板的信息（这里我的以及搞过了，没弹出来，用的网图）</h5>
<p><img src="https://pic.imgdb.cn/item/6431212b0d2dde5777416c7c.png" alt="在这里插入图片描述" /></p>
<h5 id="7进入实时监视"><a class="markdownIt-Anchor" href="#7进入实时监视"></a> 7.进入实时监视</h5>
<p><mark>部分JLINK会因为被检测到盗版而无法使用</mark></p>
<p><img src="https://pic.imgdb.cn/item/64301ce80d2dde5777a8c739.png" alt="在这里插入图片描述" /></p>
<br>
<hr />
<h3 id="5️⃣-窗口介绍"><a class="markdownIt-Anchor" href="#5️⃣-窗口介绍"></a> 5️⃣ 窗口介绍</h3>
<p>总共分大概以下几种窗口：</p>
<p><mark>时间轴窗口（Timeline）</mark>、<mark>事件窗口（Events）</mark>、<mark>终端窗口(Terminal)</mark>、<mark>CPU占用窗口（CPU Load）</mark>、<mark>不知道怎么命名窗口（context）</mark></p>
<p><img src="https://pic.imgdb.cn/item/643121730d2dde577741c3c5.png" alt="在这里插入图片描述" /></p>
<hr />
<h5 id="时间轴窗口timeline"><a class="markdownIt-Anchor" href="#时间轴窗口timeline"></a> 时间轴窗口（Timeline）</h5>
<p><img src="https://pic.imgdb.cn/item/643121840d2dde577741d8b1.png" alt="在这里插入图片描述" /></p>
<p>用于显示各<mark>任务占用的时间</mark>和逻辑顺序</p>
<ul>
<li>处于ready状态的任务，在开始执行前会被显示在<mark>浅灰色的栏</mark>中。</li>
<li>上下文是按<mark>优先级排序</mark>的。第一行显示了一个统一上下文中的所有活动。列表的顶部是中断，用Id来排序的，接下来是scheduler调度器和软件定时器（如果在系统中使用这些的话）。</li>
<li>在调度器(和定时器)下面，任务按优先级排序。当没有其他上下文处于活动状态时，底层上下文显示空闲时间。</li>
</ul>
<hr />
<h5 id="事件窗口events"><a class="markdownIt-Anchor" href="#事件窗口events"></a> 事件窗口（Events）</h5>
<p><img src="https://pic.imgdb.cn/item/643121a80d2dde57774206ce.png" alt="在这里插入图片描述" /></p>
<p><strong>Events窗口显示系统发送的所有事件，并显示它们的信息。每个事件都有以下几项：</strong></p>
<ul>
<li>在目标时间或记录时间内的时间戳，可以用微秒或纳秒分辨率显示</li>
<li>创建Events的上下文，即运行的任务。</li>
<li>Event描述，和事件类型一起显示，(IRS进入和退出，任务活动，API调用)。</li>
<li>Event细节描述事件的参数，即API调用参数。</li>
<li>在列表中定位事件的ID。</li>
</ul>
<p><strong>也可以通过事件滤波器查看对应的事件</strong></p>
<p><img src="https://pic.imgdb.cn/item/643121bc0d2dde5777421cfe.png" alt="在这里插入图片描述" /></p>
<hr />
<h5 id="终端窗口"><a class="markdownIt-Anchor" href="#终端窗口"></a> 终端窗口</h5>
<p><img src="https://pic.imgdb.cn/item/643121d10d2dde57774234db.png" alt="在这里插入图片描述" /></p>
<p><em>终端窗口显示来自目标应用程序的printf输出，以及发出log输出的任务上下文，以及发送消息时的时间</em></p>
<p><em>戳。双击消息，可以显示出该消息在事件列表中的所有信息。</em></p>
<p><em>Timeline窗口显示的是输出的指示器，根据级别排序（错误总是排在顶部）。显示的日志级别可以通过</em></p>
<p><em>View -&gt; Message Indicators… 来配置。</em></p>
<p><strong>可通过systemview的API接口，打印信息</strong></p>
<p><img src="https://pic.imgdb.cn/item/643121e40d2dde577742486c.png" alt="在这里插入图片描述" /></p>
<hr />
<h5 id="cpu占用窗口cpu-load"><a class="markdownIt-Anchor" href="#cpu占用窗口cpu-load"></a> CPU占用窗口（CPU Load）</h5>
<p><img src="https://pic.imgdb.cn/item/643121f50d2dde5777425c36.png" alt="在这里插入图片描述" /></p>
<p>CPU load窗口显示了一个周期内上下文占用的CPU时间。CPU负载是用一个使用Timeline当前分辨率的</p>
<p>bin的宽度来测量的，因此与缩放级别是同步的。</p>
<p>可以通过选择bin的数量用来测量较短或较长时期的负载。使用一个bin，就可以在整个可见的时间轴上</p>
<p>测量CPU负载。</p>
<hr />
<h5 id="context窗口"><a class="markdownIt-Anchor" href="#context窗口"></a> Context窗口</h5>
<p><img src="https://pic.imgdb.cn/item/6431220a0d2dde57774271e2.png" alt="在这里插入图片描述" /></p>
<p><strong>Context窗口信息包括以下内容：</strong></p>
<ul>
<li>上下文名称和类型。</li>
<li>任务堆栈信息。（如果有的话）</li>
<li>上下文的活动计数。</li>
<li>活动频率。</li>
<li>总的运行时间和最后运行时间。</li>
<li>每秒当前的、最小和最大运行时间，单位是ms和%。</li>
</ul>
<br>
<hr />
<h3 id="6️⃣-其他使用"><a class="markdownIt-Anchor" href="#6️⃣-其他使用"></a> 6️⃣ 其他使用</h3>
<h5 id="事件记录"><a class="markdownIt-Anchor" href="#事件记录"></a> 事件记录</h5>
<p><mark>systemview默认的事件有</mark></p>
<p><img src="https://pic.imgdb.cn/item/643122200d2dde5777428a51.png" alt="在这里插入图片描述" /></p>
<hr />
<h5 id="添加中断记录"><a class="markdownIt-Anchor" href="#添加中断记录"></a> 添加中断记录</h5>
<p>可以自己在中断函数中添加对应的API接口，来实现对中断进入的记录。</p>
<p><img src="https://pic.imgdb.cn/item/643122320d2dde5777429bbc.png" alt="在这里插入图片描述" /></p>
<p><strong>结果如图：</strong></p>
<p><img src="https://pic.imgdb.cn/item/643122410d2dde577742ac70.png" alt="在这里插入图片描述" /></p>
<p><strong>可以看到会定期触发can中断，且每次进入中断事件长短不同</strong></p>
<p><img src="https://pic.imgdb.cn/item/643122540d2dde577742bef4.png" alt="在这里插入图片描述" /></p>
<h5 id="分析示例"><a class="markdownIt-Anchor" href="#分析示例"></a> 分析示例</h5>
<p><img src="https://pic.imgdb.cn/item/643122660d2dde577742d299.png" alt="在这里插入图片描述" /></p>
<p>可以看到哨兵云台任务<mark>占用的时间最长</mark>，且可以看到我们现在的任务运行时间在整个周期中占用的都是非常短的。</p>
<br>
<hr />
<h3 id="7️⃣-存在的问题"><a class="markdownIt-Anchor" href="#7️⃣-存在的问题"></a> 7️⃣ 存在的问题</h3>
<blockquote>
<p><strong>问题描述：</strong>    <em>J-Link不同而导致被识别盗版而不能用的问题</em></p>
<blockquote>
<ul>
<li>[x] <strong>原因：</strong>  <em>J-Link被识别盗版</em></li>
<li>[x] <strong>解决：</strong>  换用其他的J-Link仿真器，或利用串口进行收发（详见链接<a href="https://blog.imi.moe/systemview-freertos/">串口移植收发</a>）</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><strong>问题描述：</strong>  出现报错：</p>
<p>Error: L6218E: Undefined symbol SEGGER_SYSVIEW_X_GetInterruptId (referred from segger_sysview.o).<br />
Error: L6218E: Undefined symbol SEGGER_SYSVIEW_X_GetTimestamp (referred from segger_sysview.o).</p>
<blockquote>
<ul>
<li>[x] <strong>原因：</strong> systemview 在keil中与gnu扩展的不兼容</li>
<li>[x] <strong>解决：</strong>  在keil中选择不勾选GNU拓展（[详见]( ######5.  程序添加)）</li>
<li>[ ]  <strong>隐患：</strong>  其他部分代码可能会出现问题</li>
</ul>
</blockquote>
<p><strong>拓展问题表述：</strong> 串口 print重定义代码出现报错</p>
<blockquote>
<ul>
<li>[x] <strong>原因</strong>： 因为没有了GNU拓展，导致这部分代码不可用</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>[ ] <strong>解决：</strong>  暂定先注释掉，待解决。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<h3 id="8️⃣-应用场景"><a class="markdownIt-Anchor" href="#8️⃣-应用场景"></a> 8️⃣ 应用场景</h3>
<ul>
<li>用于查看每个进程的时间片，查看各个进程时间占用情况。</li>
<li>防止某个进程占用时间过长，而被操作系统强行进入<mark>堵塞状态。</mark></li>
<li>查看中断进入情况，避免因传感器发送频率过高，而频繁进入中断。</li>
</ul>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>单片机</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充</title>
    <url>/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.9.11」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em><br />
<br></p>
<p><strong>摘要：</strong> 记录汇总自己在嵌入式开发过程中 学习的一些零散知识</p>
<p><strong>简介:</strong>  简单汇总,方便自己查看</p>
</blockquote>
<br>
<span id="more"></span>
<p>(👇 第一部分)<br />
<a href="https://ye2020.github.io/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%E2%80%94%E2%80%94ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/#more">嵌入式C语言学习记录(一) —— ARM指令集与作用域</a><br />
(👇 pdf  版)<br />
<a href="https://download.csdn.net/download/weixin_51330198/86701430?spm=1001.2014.3001.5501">pdf文件</a></p>
<br>
<hr />
<br>
<hr />
<br>
<h2 id="4️⃣-gnu-拓展语法"><a class="markdownIt-Anchor" href="#4️⃣-gnu-拓展语法"></a> 4️⃣ GNU 拓展语法</h2>
<blockquote>
<ul>
<li>ANSIC(C89)、(C99)、(C11)表示的是C语言标准</li>
<li><strong>GNU拓展语法</strong>是GUN编译器对C语言标准的拓展</li>
</ul>
</blockquote>
<br>
<h3 id="41-指定初始化"><a class="markdownIt-Anchor" href="#41-指定初始化"></a> 4.1 指定初始化</h3>
<p><code>GNU C</code> 支持指定初始化<strong>数组元素</strong>和 <strong>结构体成员</strong></p>
<p><font face="华文彩云" color=red size=5>初始化数组元素示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">10</span>] = <span class="number">1</span>,[<span class="number">30</span>] = <span class="number">2</span>&#125;;				<span class="comment">// 给指定几个元素初始化</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">10</span> ... <span class="number">30</span>] = <span class="number">1</span>,[<span class="number">40</span> ... <span class="number">60</span>] = <span class="number">2</span>&#125;; <span class="comment">// 给某个索引范围的数组元素初始化</span></span><br></pre></td></tr></table></figure>
<br>
<blockquote>
<p><code>GNU C</code> 支持使用 <code>…</code> 表示范围拓展 , 不仅可以使用在<strong>数组初始化</strong>中 , 也可以使用在<code>switch-case</code> 中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> ... <span class="number">4</span>:</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        	</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>初始化结构体成员示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;<span class="type">test_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">test_t</span> test1 = &#123;<span class="string">&quot;name1&quot;</span>,<span class="number">10</span>&#125;;		<span class="comment">// C语言标准初始化方式(即固定顺序直接初始化)</span></span><br><span class="line">	</span><br><span class="line">    <span class="type">test_t</span> test2 = 						<span class="comment">// GNU C初始化方式(直接通过结构域名.name和.age,给结构体变量的某一个指定成员直接赋值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;name2&quot;</span>,</span><br><span class="line">        .age  =<span class="number">20</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h3 id="42-语句表达式"><a class="markdownIt-Anchor" href="#42-语句表达式"></a> 4.2  语句表达式</h3>
<ul>
<li>
<p><strong>表达式:</strong>   <em>表达式就是由一系列操作符和操作数构成的式子。</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = i++ + <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>语句 :</strong>  在表达式后加一个 <code>;</code>  就构成了一条基本语句 ,  <code>;</code> 表示一条语句的结束</p>
</li>
<li>
<p><strong>语句表达式 :</strong></p>
<ul>
<li>GNU C对C语言标准作了扩展,允许在一个表达式里内嵌语句;</li>
<li>允许在表达式内部使用局部变量、for循环和goto跳转语句;</li>
</ul>
<br>
<p><strong>语句表达式格式:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(&#123;表达式<span class="number">1</span> ; 表示<span class="number">2</span> ; 表达式<span class="number">3</span> ;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>语句表达式 <strong>最外面使用小括号<code>( )</code></strong> 括起来,里面一对 <strong>大括号<code>&#123; &#125;</code></strong> 包起来的是代码块,</li>
<li>代码块里允许内嵌各种语句。语句的格式可以是一般表达式,也可以是循环、跳转语句。</li>
<li>语句表达式的值为内嵌语句中<strong>最后一个表达式的值</strong>。</li>
</ul>
</blockquote>
</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<p>使用语句表达式求值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = </span><br><span class="line">   (&#123;</span><br><span class="line">       <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">           s = s + i;</span><br><span class="line">       	   s;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在上面的程序中,通过语句表达式实现了从1到10的累加求和</li>
<li>因为语句表达式的值等于最后一个表达式的值,所以在for循环的后面,我们要添加一个<code>s</code>;</li>
<li><code>s</code>语句表示整个语句表达式的值 , 如果不加这一句,结果是<code>sum=0</code>。</li>
<li>如果将这一行语句改为<code>100</code>,最后<code>sum</code>的值就变成了100,这是因为语句表达式的值总等于<strong>最后一个表达式的值</strong>.</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="421-使用实例"><a class="markdownIt-Anchor" href="#421-使用实例"></a> 4.2.1 使用实例</h4>
<blockquote>
<ul>
<li>语句表达式的主要用途在于定义功能复杂的宏。</li>
<li>使用语句表达式来定义宏,不仅可以实现复杂的功能,还能避免宏定义带来的歧义和漏洞。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<p>定义一个宏 , 求两个数的最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ANSIC */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))	<span class="comment">// 经典宏陷阱 , 在 MAX(i++ , j++); 时会出现累加两次问题</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GNU C */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (&#123;		\				<span class="comment">// 在语句表达式中定义两个临时变量,分别来暂时存储i和j的值,然后使用临时变量进行比较</span></span></span><br><span class="line">		<span class="type">int</span> _x = x;			\				<span class="comment">// 这样就避免了两次自增、自减问题。</span></span><br><span class="line">		<span class="type">int</span> _y = y;			\</span><br><span class="line">		_x &gt; _y ? _x : _y;	\</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* GNU C 优化*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   max(x,y) (&#123;		\</span></span><br><span class="line"><span class="meta">    	typeof(x) _x = (x); \				<span class="comment">// typeof 关键字是GNUC 拓展的,用于获取一个变量或表达式的类型</span></span></span><br><span class="line">    	typeof(x) _y = (y); \				<span class="comment">// 使用typeof关键字来自动获取宏的 两个参数类型</span></span><br><span class="line">    	(<span class="type">void</span>)(&amp;_x == &amp;_y);	\</span><br><span class="line">    	_x &gt; _y ? _x : _y;	\</span><br><span class="line">&#125;)   </span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5>备注：</font>  <strong>为什么存在 <code>(void) (&amp;_x == &amp;_y);</code>  这个看似很多余的语句</strong></p>
<blockquote>
<p>它的作用有两个 :</p>
<ul>
<li>一是用来给用户提示一个警告,对于不同类型的指针比较,编译器会发出一个警告,提示两种数据的类型不同。</li>
<li>二是两个数进行比较运算 , 运算的结果却没有用到,有些编译器可能会给出一个<code>warning</code>,加一个<code>(void)</code>后,就可以消除这个警告。</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="43-typeof关键字"><a class="markdownIt-Anchor" href="#43-typeof关键字"></a> 4.3   <code>typeof</code>关键字</h3>
<blockquote>
<ul>
<li><code>typeof</code>是<code>GNU C</code>扩展的一个关键字 , 用来获取一个变量或表达式的类型。</li>
<li>使用<code>typeof</code>可以获取一个变量或表达式的类型。<code>typeof</code>的参数有两种形式 : <strong>表达式</strong>或<strong>类型</strong>。</li>
</ul>
</blockquote>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">typeof(i) j = <span class="number">20</span>;		<span class="comment">// typeof(i) 就等于int, typeof(i)j=20 就相当于int j=20,</span></span><br><span class="line">typeof(<span class="type">int</span> *) a;		<span class="comment">//  typeof(int*)a;相当于int*a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;				<span class="comment">// f()函数的返回值类型是int,</span></span><br><span class="line">typeof(f()) k;			<span class="comment">// typeof(f())k ; 就相当于int k;</span></span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>其他用法：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof (<span class="type">int</span> *) y;				<span class="comment">//把y定义为指向int类型的指针,相当于int *y;</span></span><br><span class="line">typeof (<span class="type">int</span>) *y;				<span class="comment">//定义一个执行int类型的指针变量y</span></span><br><span class="line">typeof (*x) y;					<span class="comment">//定义一个指针x所指向类型的指针变量y</span></span><br><span class="line">typeof (<span class="type">int</span>) y[<span class="number">4</span>];				<span class="comment">//相当于定义一个int y[4]</span></span><br><span class="line">typeof (*x) y[<span class="number">4</span>];				<span class="comment">//把y定义为指针x指向的数据类型的数组</span></span><br><span class="line">typeof (typeof (<span class="type">char</span> *)[<span class="number">4</span>]) y;	<span class="comment">//相当于定义字符指针数组 char *y[4];</span></span><br><span class="line">typeof (<span class="type">int</span> x[<span class="number">4</span>]) y; 			<span class="comment">//相当于定义 int y[4]</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h3 id="44-container_of宏"><a class="markdownIt-Anchor" href="#44-container_of宏"></a> 4.4  container_of宏</h3>
<blockquote>
<p><strong>作用 :</strong>  根据结构体某一成员的地址,获取这个<mark>结构体的首地址</mark>。</p>
<p><strong>实现原理 :</strong></p>
<ul>
<li>结构体中各个成员的地址在数值上等于结构体各成员相对于<strong>结构体首地址的偏移</strong>。</li>
<li>直接用结构体成员的地址 , 减去该成员在结构体内的偏移,就可以得到该结构体的首地址了。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>宏定义原型：</font></p>
<p><img src="https://pic.imgdb.cn/item/632ea18f16f2c2beb1c15734.png" alt="image-20220912130718233" /></p>
<br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) 	(&#123; 					\											\</span></span><br><span class="line"><span class="meta">		const typeof( ((type *)0)-&gt;member ) *_mptr = (ptr);		\</span></span><br><span class="line"><span class="meta">		(type *)((char *)_mptr - offsetof(type, member) );	&#125;)</span></span><br></pre></td></tr></table></figure>
<p>可以看到这个宏有<strong>三个参数:</strong></p>
<ul>
<li><code>type</code>为结构体类型;</li>
<li><code>member</code>为结构体内的成员;</li>
<li><code>ptr</code>为结构体内成员<code>member</code>的地址。</li>
</ul>
<br>
<hr />
<br>
<h4 id="441-结构体的储存空间"><a class="markdownIt-Anchor" href="#441-结构体的储存空间"></a> 4.4.1 结构体的储存空间</h4>
<p><span id="two" name="two"></span></p>
<p><strong>编译器</strong>在给一个<strong>结构体变量</strong>分配储存空间时,有以下特点:</p>
<ul>
<li>根据每个成员的<strong>数据类型</strong>和<strong>字节对齐方式</strong>,编译器会按照结构体中各个成员的顺序,在内存中分配<strong>一片连续的空间</strong>来存储它们</li>
<li>结构体中的<strong>每个成员变量</strong>,从结构体首地址开始依次存放,每个成员变量相对于结构体首地址,都有一个<strong>固定偏移</strong>。</li>
<li>在<strong>同一个编译环境</strong>下 , 各个成员相对于结构体首地址的<strong>偏移是固定不变</strong>的 . (当然 使用<code>#pragma pack(x)</code> 或 <code>typedef __packed struct</code> 改变字节对齐方式 ,同时也会改变地址编译 )</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//暂且将链表放在结构体的第一位</span></span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">int</span> math;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct student</code> 的<mark>地址偏移</mark></p>
<img src="https://pic.imgdb.cn/item/632ea19516f2c2beb1c16403.png" alt="image-20220912134256201" style="zoom: 80%;" />
<br>
<p><font face="华文彩云" color=red size=5>示例2：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> 				//  <span class="title">A</span> 对齐为 4 ，大小为 16</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">int</span> a;				<span class="comment">// a 偏移为 0 </span></span><br><span class="line">    <span class="type">char</span> b;				<span class="comment">// b 偏移为 4</span></span><br><span class="line">    <span class="type">int</span> c; 				<span class="comment">// c 偏移为 8（大于 4 + 1 的 4 的最小整数倍）</span></span><br><span class="line"> 	<span class="type">char</span> d; 			<span class="comment">//  d 偏移为 12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">char</span> a1; 			<span class="comment">// a1偏移为 0</span></span><br><span class="line">    <span class="type">int</span> a2; 			<span class="comment">// a2移为 4</span></span><br><span class="line">    <span class="type">char</span> a3; 			<span class="comment">// a3移为 8</span></span><br><span class="line">    <span class="type">short</span> a4; 			<span class="comment">// a4移为 10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct B</code>  的<mark>地址偏移</mark></p>
<img src="https://pic.imgdb.cn/item/64311ac50d2dde577739895b.webp" alt="在这里插入图片描述" style="zoom:80%;" />
<br>
<blockquote>
<p><strong>可以看到 ：</strong></p>
<ul>
<li>结构体中成员变量在内存中存储的其实是<strong>偏移地址</strong></li>
<li>也就是说<strong>结构体A的地址+成员变量的偏移地址 = 结构体成员变量的起始地址</strong></li>
<li>因此，可以根据结构体变量的起始地址和成员变量的偏移地址来反推出结构体A的地址。</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="442-container_of宏实现"><a class="markdownIt-Anchor" href="#442-container_of宏实现"></a> 4.4.2  <code>container_of</code>宏实现</h4>
<h5 id="4421-type-0-member-解析"><a class="markdownIt-Anchor" href="#4421-type-0-member-解析"></a> 4.4.2.1 <code>(((type *)0)-&gt;member)</code> 解析</h5>
<p><font face="华文彩云" color=red size=5>测试代码：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;age=%p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;math= %p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;math);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>运行结果：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;age = <span class="number">00000000</span></span><br><span class="line">&amp;math= <span class="number">00000004</span> </span><br><span class="line">&amp;num = <span class="number">00000008</span></span><br></pre></td></tr></table></figure>
<p><strong>如上所示:</strong></p>
<blockquote>
<ul>
<li><code>((TYPE *)0)</code>将0转换为type类型的结构体指针 (即转换为一个指向结构体类型为<code>student</code>的常量指针)</li>
<li>因为常量指针的值为0,即可以看作结构体<strong>首地址为0</strong></li>
<li>所以结构体中每个<strong>成员变量的地址</strong>即该成员相对于结构体<strong>首地址的偏移</strong>。</li>
<li><code>(((type *)0)-&gt;member)</code> 引用结构体中<code>MEMBER</code>成员。</li>
</ul>
</blockquote>
<br>
<hr />
<h5 id="4422-const-typeof-type-0-member-_mptr-ptr"><a class="markdownIt-Anchor" href="#4422-const-typeof-type-0-member-_mptr-ptr"></a> 4.4.2.2 const typeof( ((type *)0)-&gt;member ) *_mptr = (ptr);</h5>
<p><strong>这句代码意思是:</strong></p>
<ul>
<li>
<p>用<code>typeof()</code>获取结构体里<code>member</code>成员属性的类型，</p>
</li>
<li>
<p><code>typeof( ((type *)0)-&gt;member )</code> 表达式使用<code>typeof</code>关键字 ,来获取结构体成员 <code>MEMBER</code>的数据类型</p>
</li>
<li>
<p>然后定义一个该类型的<strong>临时指针变量<code>__mptr</code></strong>， 用来储存宏中参数<code>ptr</code>的值</p>
</li>
<li>
<p>并将<code>ptr</code>所指向的<code>member</code>的<strong>地址</strong>赋给<code>__mptr</code>；</p>
</li>
<li>
<p>因为结构体成员的数据类型可以是任何数据类型 , 为了让这个宏兼容各种数据类型 , 所以定义了一个临时指针变量<code>__mptr</code></p>
</li>
</ul>
<br>
<hr />
<h5 id="4423-offsetoftype-member"><a class="markdownIt-Anchor" href="#4423-offsetoftype-member"></a> 4.4.2.3 <code>offsetof(TYPE, MEMBER)</code></h5>
<blockquote>
<p><strong>作用 :</strong>  这个宏的作用就是求出 <code>MEMBER</code>相对于0地址的一个偏移值。</p>
<p><strong>原理 :</strong>　将0强制转换为一个指向<code>TYPE</code>类型的结构体常量指针 , 然后通过这个常量指针访问成员,获取成员<code>MEMBER</code>的地址, 其大小在数值上等于<code>MEMBER</code>成员在结构体<code>TYPE</code>中的偏移</p>
</blockquote>
<br>
<p>可以看到这个宏有<strong>两个参数:</strong></p>
<ul>
<li><code>TYPE</code>为结构体类型;</li>
<li><code>MEMBER</code>为结构体<code>TYPE</code>内的成员;</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<p><code>size_t</code>是标准C库中定义的，在32位架构中被普遍定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<p>而在64位架构中被定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使程序有很好的移植性，因此内核使用<code>size_t</code>和，而不是<code>int</code>，<code>unsigned</code>。</p>
</blockquote>
<br>
<hr />
<h5 id="4424-type-char-_mptr-offsetoftype-member"><a class="markdownIt-Anchor" href="#4424-type-char-_mptr-offsetoftype-member"></a> 4.4…2.4  <code>(type *)((char *)_mptr - offsetof(type, member) );</code></h5>
<br>
<p><strong>这句代码的意思是:</strong></p>
<ul>
<li>取结构体某个成员<code>member</code>的地址,减去这个成员在结构体type中的偏移,得到结构体<code>type</code>的首地址。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ul>
<li>把 <code>__mptr</code> 转换成 <code>char *</code> 类型， 因为 <strong><code>offsetof</code>宏</strong> 得到的偏移量是以字节为单位。</li>
<li>在语句表达式的最后  因为返回的是结构体的首地址 , 所以整个地址还必须强制转换一下,转换为<code>TYPE *</code></li>
<li>即返回一个指向 <strong><code>TYPE</code>结构体类型</strong>的<strong>指针</strong>,所以最后一个表达式中会出现一个强制类型转换<code>(TYPE *)</code></li>
</ul>
<br>
<hr />
<h4 id="445-使用实例"><a class="markdownIt-Anchor" href="#445-使用实例"></a> 4.4.5 使用实例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        Student stu;						<span class="comment">// 定义结构体类型变量</span></span><br><span class="line">        Student *sptr = <span class="literal">NULL</span>;</span><br><span class="line">        stu.id = <span class="number">123456</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(stu.name,<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">        stu.math = <span class="number">90</span>;</span><br><span class="line">    </span><br><span class="line">        sptr = container_of(&amp;stu.id,Student,id);</span><br><span class="line">   	<span class="comment">/*  宏展开为 */</span></span><br><span class="line">    <span class="comment">//  sptr = (&#123; const unsigned char  *__mptr = (&amp;stu.id); </span></span><br><span class="line">    <span class="comment">//            (Student *)( (char *)__mptr - ((size_t) &amp;((Student *)0)-&gt;id) );&#125;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">    </span><br><span class="line">        sptr = container_of(&amp;stu.name,Student,name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">        sptr = container_of(&amp;stu.math,Student,id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h3 id="46-零长度数组"><a class="markdownIt-Anchor" href="#46-零长度数组"></a> 4.6  零长度数组</h3>
<p>零长度数组定义:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>它的特点是 <strong>不占用内存存储空间</strong></p>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">0</span>];		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>int a[0]</code> 仅仅意味着程序中通过<code>buffer</code>结构体实例的<code>a[index]</code>成员可以访问<code>len</code>之后的第<code>index</code>个地址</li>
<li>它并 没有为<code>a[]</code>数组分配内存，因此<code>sizeof（struct buffer）=sizeof（int）</code>。</li>
</ul>
</blockquote>
<br>
<p><mark>用途:</mark>  <strong>零长度数组</strong>一般很少单独使用，它常常作为结构体的一个成员，构成一个<strong>变长结构体</strong>。</p>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> len;	<span class="comment">// len 标志着下面数据的长度</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">0</span>];	<span class="comment">// 数组名data是一个指针常量，标识着成员变量len后面的那个地址，但其本身并不占空间。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">int</span> this_length = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">    buf = (<span class="keyword">struct</span> buffer *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer)+ this_length);</span><br><span class="line">    buf-&gt;len = this_length;</span><br><span class="line">	<span class="built_in">memset</span>(buf-&gt;a, <span class="string">&#x27;a&#x27;</span>, this_length);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(buf-&gt;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>sizeof(buffer) + 20，即24个字节大小。其中4个字节用来存储结构体指针 buf 指向的结构体类型变量，另外20个字节空间，才是我们真正使用的内存空间。</li>
<li>使用零长度数组 ,使得这个<strong>结构体的长度</strong>可以随着程序动态的变化</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font>   <strong>零长度数组</strong>要放在结构体的最后</p>
<br>
<hr />
<h3 id="47-__attribute__-关键字"><a class="markdownIt-Anchor" href="#47-__attribute__-关键字"></a> 4.7  <code>__attribute__</code>  关键字</h3>
<br>
<blockquote>
<p><mark>说明 :</mark></p>
<ul>
<li><code>__attribute__</code>是<code>GNU C</code> 新增的一个关键字 ,  可以用来设置<strong>函数属性</strong>、<strong>变量属性</strong>和<strong>类型属性</strong>。</li>
<li>函数属性可以把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</li>
</ul>
<p><mark>语法格式 :</mark>  <code>__atttribute__((ATTRIBUTE))</code></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ul>
<li>
<p><code>__attribute__</code>前后都有<strong>两个</strong>下划线</p>
</li>
<li>
<p><code>__attribute__</code>后面是<strong>两对小括号</strong> , 不能只写一对</p>
</li>
<li>
<p>括号里面的 <code>ATTRIBUTE</code>表示要声明的属性</p>
<ul>
<li>
<p>可以同时添加多个属性说明</p>
</li>
<li>
<p>可以选择若干个单独的<code>__attribute__</code>，或者把它们写在一起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 写在一起 */</span></span><br><span class="line"><span class="type">char</span> c2 __attribute__((packed,aligned(<span class="number">4</span>)));			<span class="comment">// 各个属性之间用逗号隔开</span></span><br><span class="line">__attribute__((packed,aligned(<span class="number">4</span>))) <span class="type">char</span> c2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单独 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">     __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span></span><br><span class="line">     __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)))</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>如上所示 , 属性声明要<strong>紧挨着变量</strong> ,以上<code>C2</code>变量两种定义方式都是可行的</p>
</li>
</ul>
<br>
<hr />
<h4 id="471-变量属性说明"><a class="markdownIt-Anchor" href="#471-变量属性说明"></a> 4.7.1 变量属性说明’</h4>
<blockquote>
<p>举例说明其中几种属性</p>
</blockquote>
<br> 
<blockquote>
<p><mark>变量属性:</mark></p>
<ul>
<li>cleanup</li>
<li>aligned</li>
<li>packed</li>
<li>common</li>
<li>nocommon</li>
<li>deprecated</li>
<li>mode</li>
<li>section</li>
<li>shared</li>
<li>tls_model</li>
<li>transparent_union</li>
<li>unused</li>
<li>vector_size</li>
<li>weak</li>
<li>dllimport</li>
<li>dlexport</li>
</ul>
</blockquote>
<p><br> (官方文档 👇)</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes">(变量属性说明 - 官方文档)</a></p>
<hr />
<h5 id="4711-属性-section"><a class="markdownIt-Anchor" href="#4711-属性-section"></a> 4.7.1.1 属性: <code>section</code></h5>
<blockquote>
<p><strong>作用:</strong>  在程序编译时 , 将一个<strong>函数</strong>或变量放到 目标文件( .o文件) 的指定段中 , 即放到指定的<code>section</code>中</p>
<p><strong>格式：</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font></p>
<p>一段源程序代码在编译生成可执行文件的过程中,<strong>函数</strong>和<strong>变量</strong>是放在不同段中的 , 如图所示:</p>
<p><img src="https://pic.imgdb.cn/item/632ea19c16f2c2beb1c16d0d.png" alt="image-20220913221409508" /></p>
<ul>
<li>一个可执行文件主要由<strong>代码段</strong>、<strong>数据段</strong>、<strong>BSS段</strong>构成。</li>
<li><strong>代码段</strong>主要存放编译生成的可执行指令代码;</li>
<li><strong>数据段</strong>和<strong>BSS段</strong>用来存放全局变量、未初始化的全局变量</li>
<li>代码段、数据段和BSS段构成了一个可执行文件的主要部分。</li>
<li>此外还有其他的段 ,如<strong>只读数据段</strong>、<strong>符号表</strong> 、还包含其他一些<code>section</code></li>
</ul>
<p><br><font face="华文彩云" color=red size=5>说明：</font></p>
<p><img src="https://pic.imgdb.cn/item/632ea1a916f2c2beb1c1806c.png" alt="image-20220913222112669" /></p>
<p>​													<mark>从C程序到可执行文件</mark></p>
<br>
<hr />
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> uninit_val __attribute__((section(<span class="string">&quot;.data&quot;</span>)));</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>__atttribute__</code> 的 <code>section</code> 属性，显式指定一个函数或变量，在编译时放到指定的 <code>section</code> 里面</li>
<li>未初始化的全局变量是放在 <code>.bss section</code> 中的，即放在 <strong>BSS 段</strong>中</li>
<li>现在通过 <code>section</code> 属性，把这个未初始化的全局变量放到<strong>数据段</strong> <code>.data</code> 中。</li>
</ul>
<br>
<hr />
<p><span id="six" name="six"></span></p>
<h5 id="4712-属性-aligned"><a class="markdownIt-Anchor" href="#4712-属性-aligned"></a> 4.7.1.2 属性: <code>aligned</code></h5>
<blockquote>
<p><strong>作用 :</strong>　指定一个变量或类型的对齐方式（使被设置的对象<strong>占用更多的空间</strong>）</p>
<p><strong>注意 :</strong>  对齐的字节数必须是<strong>2的幂次方</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font>  定义一个变量在内存中以<strong>指定字节数</strong>对齐</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x __attribute__ ((aligned (<span class="number">16</span>))) = <span class="number">0</span>;    <span class="comment">// 以16字节地址对齐</span></span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文行楷" color=red size=5>结构体对齐：</font></p>
<p>由前文 <a href="#two">结构体储存方式</a> 可知道 :</p>
<ul>
<li>结构体作为一种复合数据类型，编译器在给一个结构体变量分配存储空间时，会进行地址对齐;</li>
<li>结构体整体对齐要按结构体所有成员中最大成员字节数的整数倍进行对齐.</li>
<li>结构体成员按不同的顺序排放,可能会导致结构体整体长度不一致</li>
</ul>
<p><br><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为12 ((1 + (3)) + 4 + 2 = 10 ,补齐后为12)</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充3字节</span></span><br><span class="line">     <span class="type">int</span> b ;		<span class="comment">// 偏移为4; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> c ;		<span class="comment">// 偏移为8; 占用2字节; 填充2字节</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为8 ((1+(1)) + 2 + 4 = 8 )</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充1字节</span></span><br><span class="line">     <span class="type">short</span> b ;		<span class="comment">// 偏移为2; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;		<span class="comment">// 偏移为4; 占用4字节; 填充4字节</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<br>
<blockquote>
<p>用<code>__attribute__(aligned())</code>属性</p>
<p>不仅可以显性指定结构体<strong>某个成员的地址对齐</strong> ; 也可以显式指定<strong>整个结构体</strong>的对齐方式</p>
</blockquote>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 让 short 型的变量 b 按4字节对齐 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>								<span class="comment">// 结构体size为12 ((1 + (3)) + 4 + 4 = 12)</span></span><br><span class="line">     <span class="type">char</span> a;								<span class="comment">// 偏移为0; 占用1字节; 填充3字节</span></span><br><span class="line">     <span class="type">short</span> b __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">// 偏移为4; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;								<span class="comment">// 偏移为8; 占用4字节; 填充0字节</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显式指定结构体整体以16字节对齐 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>			<span class="comment">// 结构体size为16 ((1+(1)) + 2 + 4 = 8 ; 末尾填充8个字节后长度为16)</span></span><br><span class="line">     <span class="type">char</span> a;								<span class="comment">// 偏移为0; 占用1字节; 填充1字节</span></span><br><span class="line">     <span class="type">short</span> b;								<span class="comment">// 偏移为2; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;								<span class="comment">// 偏移为4; 占用4字节; 填充4字节</span></span><br><span class="line"> &#125;__attribute__((aligned(<span class="number">16</span>)));</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>特别注意：</font></p>
<ul>
<li>
<p>修改字节对齐方式 ,最大不能超过编译器允许的最大值;</p>
</li>
<li>
<p>如果连接器最大只支持16字节对齐，那么此时定义32字节对齐也是按16字节对齐</p>
</li>
</ul>
<br>
<hr />
<p><span id="five" name="five"></span></p>
<h5 id="4713-属性packed"><a class="markdownIt-Anchor" href="#4713-属性packed"></a> 4.7.1.3 <strong>属性：<code>packed</code></strong></h5>
<blockquote>
<p><strong>作用 :</strong>　指定一个变量或类型尽量使用<strong>最小的地址对齐方式</strong>来分配地址（一般用来设置<strong>减少地址对齐</strong>）</p>
<p><strong>注意 :</strong>  对齐的字节数必须是<strong>2的幂次方</strong></p>
<p><strong>用途 :</strong> 如用于封装结构体 , 为防止因内存空洞 导致与实际连续的寄存器地址不符合 ,则可以使用该属性.</p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>							<span class="comment">// 结构体size为7 ((1+ 2 + 4 = 7)</span></span><br><span class="line">     <span class="type">char</span> a;							<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> b __attribute__((packed));	<span class="comment">// 偏移为1; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c __attribute__((packed));		<span class="comment">// 偏移为3; 占用4字节; 填充0字节</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>实际应用：</font></p>
<blockquote>
<ul>
<li>在实际应用中 , 经常可以看到<code>aligned</code> 和 <code>packed</code> <strong>一起使用</strong>，即对一个变量或类型<strong>同时使用</strong> <code>aligned</code> 和 <code>packed</code> 属性声明。</li>
<li>这样做的好处是，既<strong>避免了</strong>结构体内因地址对齐产生的<strong>内存空洞</strong>，又<strong>指定了</strong>整个结构体的<strong>对齐方式</strong>。</li>
</ul>
</blockquote>
<br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>							<span class="comment">// 结构体size为8 ((1+ 2 + 4 = 7 ; 末尾填充1个字节后 ,长度变为8)</span></span><br><span class="line">    <span class="type">char</span> a;							<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">    <span class="type">short</span> b ;							<span class="comment">// 偏移为1; 占用2字节; 填充0字节</span></span><br><span class="line">    <span class="type">int</span> c ;							<span class="comment">// 偏移为3; 占用4字节; 填充1字节</span></span><br><span class="line">&#125;__attribute__((packed,aligned(<span class="number">8</span>)));</span><br></pre></td></tr></table></figure>
<p><strong>如上所示 :</strong></p>
<ul>
<li>结构体 <code>data</code> 虽然使用 <code>packed</code> 属性声明，整个<strong>长度变为7</strong>；</li>
<li>同时又使用了 <code>aligned(8)</code> 指定其按<strong>8字节地址</strong>对齐，所以编译器要在结构体后面<strong>填充1个字节</strong></li>
<li>这样整个结构体的<strong>大小就变为8字节</strong>，按8字节地址对齐。</li>
</ul>
<br>
<hr />
<h5 id="4714-属性-deprecated"><a class="markdownIt-Anchor" href="#4714-属性-deprecated"></a> 4.7.1.4 属性: <code>deprecated</code></h5>
<blockquote>
<p><strong>作用 :</strong>　弃用，如果在源文件在任何地方地方使用<code>__attribute__((deprecated))</code> 函数,编译器将会<strong>发出警告.</strong></p>
<p><strong>注意 :</strong>  该<code>deprecated</code>属性也可用于<strong>函数</strong>和<strong>类型</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__((deprecated))  <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   test(<span class="number">1</span>);		<span class="comment">// 输出警告: void test(int a) is deprecated </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br> <font face="华文彩云" color=red size=5>注意：</font></p>
<p>警告仅在<strong>使用时</strong>出现，并且仅在类型应用于本身未被声明为<strong>已弃用</strong>的<strong>标识符、变量或函数</strong>时才会出现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 变量 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> old_var __attribute__ ((deprecated));</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> old_var;					<span class="comment">// 这里不出现警告</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">new_fn</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> old_var;					<span class="comment">// 警告仅在这里出现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">old_fn</span> <span class="params">()</span> __<span class="title function_">attribute__</span> <span class="params">((deprecated))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">old_fn</span> <span class="params">()</span>;						<span class="comment">// 这里不出现警告</span></span><br><span class="line"><span class="type">int</span> (*fn_ptr)() = old_fn;			<span class="comment">// 出现警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T1 __attribute__ ((deprecated));</span><br><span class="line">T1 x;											<span class="comment">// 出现警告 </span></span><br><span class="line"><span class="keyword">typedef</span> T1 T2;									<span class="comment">// 出现警告</span></span><br><span class="line">T2 y;											<span class="comment">// 不出现警告 ，因为未明确弃用 T2。</span></span><br><span class="line"><span class="keyword">typedef</span> T1 T3 __attribute__ ((deprecated));		<span class="comment">// 不出现警告，因为T3 已被明确弃用</span></span><br><span class="line">T3 z __attribute__ ((deprecated));				<span class="comment">// 不出现警告, 因为T3 已被明确弃用</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="472-函数属性说明"><a class="markdownIt-Anchor" href="#472-函数属性说明"></a> 4.7.2 函数属性说明</h4>
<blockquote>
<p>举例说明其中几种属性</p>
</blockquote>
<br>
<blockquote>
<p><mark>函数属性:</mark></p>
<table>
<thead>
<tr>
<th>alias</th>
<th>const</th>
<th>dllimport</th>
</tr>
</thead>
<tbody>
<tr>
<td>always_inline</td>
<td>destructor</td>
<td>eightbit_data</td>
</tr>
<tr>
<td>cdecl</td>
<td>deprecated</td>
<td>far</td>
</tr>
<tr>
<td>fastcall</td>
<td>format</td>
<td>format_arg</td>
</tr>
<tr>
<td>constructor</td>
<td>dllexport</td>
<td>function_vector</td>
</tr>
<tr>
<td>interrupt</td>
<td>long_call/short_call</td>
<td>malloc</td>
</tr>
<tr>
<td>model</td>
<td>naked</td>
<td>near</td>
</tr>
<tr>
<td>no_instrument_function</td>
<td>noinline</td>
<td>nonnull</td>
</tr>
<tr>
<td>noreturn</td>
<td>nothrow</td>
<td>pure</td>
</tr>
<tr>
<td>regparm</td>
<td>saveall</td>
<td>section</td>
</tr>
<tr>
<td>sentinel</td>
<td>signal</td>
<td>tiny_data</td>
</tr>
<tr>
<td>unused</td>
<td>used</td>
<td>weak</td>
</tr>
</tbody>
</table>
</blockquote>
<br>
<p>(官方文档 👇)</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes">(函数属性说明 - 官方文档)</a></p>
<br>
<hr />
<h5 id="4721-属性-format"><a class="markdownIt-Anchor" href="#4721-属性-format"></a> 4.7.2.1 属性 : <code>format</code></h5>
<blockquote>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>指定变参函数的参数格式检查 (用于解决在使用可变参数的函数调用时 , <strong>编译器检查不出可变参数的类型或者个数是否正确</strong>的问题)</li>
<li>作用是提示编译器检查函数调用的过程中，可变参数部分按照printf或其他的规则进行检查;</li>
<li>若参数的个数或者类型不匹配，编译过程中将会发出警告</li>
</ul>
</blockquote>
<br>
<p><strong>用途 ：</strong>　比如实现对自定义的打印函数 传入的可变参数的检查</p>
<p><strong>格式:</strong>　<code>format (archetype, string-index, first-to-check)</code></p>
<blockquote>
<ul>
<li><strong><code>archetype</code>参数 :</strong> <code>printf</code>, <code>scanf</code>,<code>strftime</code> , <code>strfmon</code></li>
<li><strong><code>string-index</code>参数 :</strong> 指定哪个参数是格式字符串参数（从 1 开始）</li>
<li><strong><code>first-to-check</code>参数 :</strong>  是要检查格式字符串的第一个参数的编号*(即从函数的第几个参数开始按上述规则进行检查)<em>。对于无法检查参数的函数，将第三个参数指定为零。</em>(在这种情况下，编译器只检查格式字符串的一致性)*</li>
<li>C++有隐式的<code>this</code>函数 , <code>string-index</code>, <code>first-to-check</code>应该向后一位开始</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font> 以自定义的打印函数为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如下所示:</span></span><br><span class="line"><span class="comment">			printf参数表示: 告诉编译器按照 printf 函数的检查标准来检查</span></span><br><span class="line"><span class="comment">			第二个参数1表示: 格式化字符串在LOG函数的第一个传入参数</span></span><br><span class="line"><span class="comment">			第二个参数2表示: LOG函数中要替代&quot;%&quot;占位符的参数排在第二位 ; (即“…”里的第一个参数在LOG函数参数总数排在第2)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>  __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>)))</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如下所示:</span></span><br><span class="line"><span class="comment">			LOG函数多了个新的传入参数num , 则</span></span><br><span class="line"><span class="comment">            format函数的 string-index和first-to-check参数应向后移动一位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> *fmt, ...)</span>  __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>;</span><br></pre></td></tr></table></figure>
  <br>
<hr />
<h6 id="47211-拓展-变参函数的实现"><a class="markdownIt-Anchor" href="#47211-拓展-变参函数的实现"></a> 4.7.2.1.1 拓展 ——变参函数的实现</h6>
<blockquote>
<p>简单介绍怎么设计一个 变参函数 , 打印传入的实参</p>
</blockquote>
<p><br><span id="three" name="three"></span></p>
<p><strong>基本思路:</strong></p>
<ul>
<li>变参函数的参数存储由一个<strong>连续的</strong>参数列表组成，列表里存放的是每个参数的地址。</li>
<li>有一个固定参数<code>count</code> , 该参数后面连续储存着后面一系列参数的地址</li>
<li>通过获取<code>count</code>的地址 , 再通过<code>&amp;count + 1</code>就可以依次访问下一个地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">(<span class="type">int</span> count, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *args;							<span class="comment">// 用于保存下一个参数地址(用char *类型指针实现,以兼容更多数据类型) )</span></span><br><span class="line">    args = &amp;count + <span class="number">4</span>;					<span class="comment">// 获取第一个可变参数的地址(涉及指针运算,注意每个地址大小都是4字节)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*args: %d\n&quot;</span>, *args);</span><br><span class="line">        args+=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);			<span class="comment">// 依次打印出1,2,3,4,5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="47212-变参函数的优化"><a class="markdownIt-Anchor" href="#47212-变参函数的优化"></a> 4.7.2.1.2 变参函数的优化</h6>
<blockquote>
<p>可通过调用<strong>变参函数宏</strong> 来获取参数列表 , 解决解析参数的问题</p>
</blockquote>
 <br>
<p><font face="华文彩云" color=red size=5>说明：</font></p>
<ul>
<li><code>va_list</code></li>
</ul>
<blockquote>
<ul>
<li>通过一个类型为 <code>va_list</code> 的对象，包含了参数信息 , 称为<strong>参数指针</strong></li>
<li>它包含了栈中至少一个参数的位置 , 可以使用这个参数指针从一个可选参数移动到下一个可选参数</li>
<li>va_list 类型被定义在头文件 stdarg.h 中。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list argptr;  <span class="comment">// 用 va_list 类型定义参数指针，以获取可选参数。</span></span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_start</code></li>
</ul>
<blockquote>
<ul>
<li>宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <strong>参数指针</strong>。</li>
<li>该宏的第二个参数必须是该函数最后一个有名称参数的名称。</li>
<li>必须先调用该宏，才可以开始使用可选参数。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list argptr, lastparam)</span>; </span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_arg</code></li>
</ul>
<blockquote>
<ul>
<li>展开宏 va_arg 会得到当前 argptr 所引用的可选参数</li>
<li>同时将 <strong>参数指针</strong> 移动到列表中的下一个参数。</li>
<li>宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list argptr, type)</span>;</span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_end</code></li>
</ul>
<blockquote>
<ul>
<li>当不再需要使用参数指针时，必须调用宏 <code>va_end</code></li>
<li>如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list argptr)</span>;</span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_copy</code></li>
</ul>
<blockquote>
<ul>
<li>宏 <code>va_copy</code> 使用当前的 src 值来初始化参数指针 dest。</li>
<li>就可以使用 <code>dest</code> 中的备份获取从 <code>src</code> 所引用的位置开始的<strong>参数列表</strong></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_copy</span><span class="params">(va_list dest, va_list src)</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>优化后：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>						<span class="comment">// 可变参数宏定义在stdarg.h中</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">(<span class="type">int</span> count,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;						<span class="comment">// 定义一个参数指针</span></span><br><span class="line">    va_start(args,count);				<span class="comment">// 初始化参数指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = va_arg(args,<span class="type">int</span>);		<span class="comment">// 取得int类型的可变参数值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*args: %d\n&quot;</span>, val);		<span class="comment">// 打印取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="47213-简单日志打印函数的实现"><a class="markdownIt-Anchor" href="#47213-简单日志打印函数的实现"></a> 4.7.2.1.3  简单日志打印函数的实现</h6>
<blockquote>
<p>通过<code>vsnprintf</code>函数 , 解决<strong>打印功能</strong>实现的问题</p>
</blockquote>
<br>
<p><font face="黑体" color=red size=5>printf系列函数说明：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; 			   <span class="comment">//输出到标准输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">//输出到文件</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;    <span class="comment">//输出到字符串str中</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">//按size大小输出到字符串str中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数功能与上面的一一对应相同，只是在函数调用时，把上面的...对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief     	vsnprintf函数说明</span></span><br><span class="line"><span class="comment">  * @param[out] str : 把生成的格式化的字符串存放在这里</span></span><br><span class="line"><span class="comment">  * @param[in]  size ：接受的最大字符数(无符号数) (非字节数，UNICODE一个字符两个字节),防止产生数组越界.</span></span><br><span class="line"><span class="comment">  * @param[in]  format :指定输出格式的字符串，它决定了需要提供的可变参数的类型、个数和顺序。</span></span><br><span class="line"><span class="comment">  * @param[in]  ap  :va_list变量.</span></span><br><span class="line"><span class="comment">  * @retval    执行成功，返回最终生成字符串的长度，</span></span><br><span class="line"><span class="comment">  *       	   若生成字符串的长度大于size，则将字符串的前size个字符复制到str，同时将原串的长度返回（不包含终止符）；</span></span><br><span class="line"><span class="comment">  *            执行失败，返回负值，并置errno</span></span><br><span class="line"><span class="comment">  * @attention  none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>代码实现：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> log_str[LOG_OUTPUT_MAX_LEN];			<span class="comment">// 输出缓冲区(把生成的格式化的字符串存放在这里)</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;								<span class="comment">// 用于记录当前已使用的长度</span></span><br><span class="line">    va_list arg;								<span class="comment">// 定义一个可变参数指针</span></span><br><span class="line">    va_start(arg, fmt);							<span class="comment">// 初始化参数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* len累加用于记录已使用的缓冲区长度 ;  </span></span><br><span class="line"><span class="comment">     	(LOG_OUTPUT_MAX_LEN - len)表示缓冲区剩余长度*/</span>   	</span><br><span class="line">    len += vsnprintf(log_str, LOG_OUTPUT_MAX_LEN - len, fmt, arg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &amp;log_str[len]等效于( log_str + len ) 表示地址偏移,将目标缓冲区指向字符串尾部 */</span></span><br><span class="line">    len += <span class="built_in">snprintf</span>(&amp;log_str[len],LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[len = %d]&quot;</span>,len)	<span class="comment">//&amp;log_str[len]等同于log_str + len</span></span><br><span class="line">    </span><br><span class="line">	va_end(arg);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 将格式化字符串输出,此处是用串口输出 */</span></span><br><span class="line">    __log_output((<span class="type">uint8_t</span> *)log_str, len);		<span class="comment">//  类似printf(&quot;%s&quot;,log_str);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    log_printf(<span class="string">&quot;test \r\n&quot;</span> );</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>运行结果：</font ></p>
<p><img src="https://pic.imgdb.cn/item/632ea1b016f2c2beb1c18a66.png" alt="image-20220917215405446" /></p>
<br>
<hr />
<h6 id="47214-日志打印函数优化"><a class="markdownIt-Anchor" href="#47214-日志打印函数优化"></a> 4.7.2.1.4  日志打印函数优化</h6>
<blockquote>
<p><strong>优化方向:</strong></p>
<ul>
<li>添加打印等级 , 根据设置的打印等级，模块打印的 log 信息也会不一样</li>
<li>添加<code>format</code>属性声明 , 用于让编译器在编译的时候 , 检查<code>log_printf</code>函数的参数格式</li>
</ul>
</blockquote>
<br>
<p><span id="four" name="four"></span></p>
<p><font face="华文彩云" color=red size=5>代码实现一：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************** log.c ************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_OUTPUT_LEVEL 4			<span class="comment">// 输出等级(最大为4)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TIMESTAMP_EN 0			<span class="comment">// 时间信息输出使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FUNCTION_EN  0			<span class="comment">// 函数信息输出使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE_LINE_EN 0			<span class="comment">// 文件信息输出使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASSERT   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARINING 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级输出信息表 */</span></span><br><span class="line"><span class="type">char</span> *LOG_LEVEL_TAGS[<span class="number">6</span>] = &#123;<span class="string">&quot;NULL&quot;</span>, <span class="string">&quot;ASSERT&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;WARNING&quot;</span>, <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;DEBUG&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief     	将打印信息缓存到缓冲区</span></span><br><span class="line"><span class="comment">  * @param[out] buff : 把生成的格式化的字符串存放在这里</span></span><br><span class="line"><span class="comment">  * @param[in]  size ：接受的最大字符数(传入vsnprintf)</span></span><br><span class="line"><span class="comment">  * @param[in]  fmt  : 格式化字符串</span></span><br><span class="line"><span class="comment">  * @retval    执行成功，返回最终生成字符串的长度，</span></span><br><span class="line"><span class="comment">  *       	   </span></span><br><span class="line"><span class="comment">  * @attention  none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">log_printf_to_buffer</span><span class="params">(<span class="type">char</span> *buff, <span class="type">int</span> size, <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;					<span class="comment">// 用于记录当前已使用的长度</span></span><br><span class="line">    va_list arg;  </span><br><span class="line">    va_start(arg, fmt);</span><br><span class="line">   </span><br><span class="line">    len += vsnprintf(buff, size, fmt, arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************** log.h ************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为需要打印实时信息,如运行时间,当前函数和调用位置等 ; 所以使用函数宏的方式 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __log_with_level(level, ...)                                                                                                              \</span></span><br><span class="line"><span class="meta">    do                                                                                                                                       \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                                                        \</span></span><br><span class="line"><span class="meta">        char log_str[LOG_OUTPUT_MAX_LEN];                                                                                                    \</span></span><br><span class="line"><span class="meta">        int len = 0;                                                                                                                         \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> ((level &lt;= LOG_OUTPUT_LEVEL) &amp;&amp; (level &lt;= 5))                                                                             \</span></span><br><span class="line"><span class="meta">        &#123;                                                                                                                                    \</span></span><br><span class="line"><span class="meta">            len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;\r\n&quot;</span>);                                                                \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (LOG_TIMESTAMP_EN)                                                                                                            \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s]&quot;</span>,__TIME__ );                                                  \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s][%s]&quot;</span>, <span class="string">&quot;LOG&quot;</span>, LOG_LEVEL_TAGS[level]);                              \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (LOG_FUNCTION_EN)                                                                                                             \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s]&quot;</span>, __FUNCTION__);                                              \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> ((LOG_FILE_LINE_EN) &amp;&amp; (level &lt;= LOG_ERROR))                                                                                  \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;(%s,%d)&quot;</span>, __FILE__, __LINE__);                                     \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            len += log_printf_to_buffer(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, __VA_ARGS__);                                               \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;%s&quot;</span>,log_str);                                                                                                            \</span></span><br><span class="line"><span class="meta">                                                                                                                                             \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                                                                    \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 各输出等级打印函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_assert(...) __log_with_level(LOG_ASSERT, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_error(...) __log_with_level(LOG_ERROR, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_waring(...) __log_with_level(LOG_WARINING, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(...) __log_with_level(LOG_INFO, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong>  为什么要使用do { … } while(0)</p>
<ul>
<li>为了防止宏在条件、选择等分支中展开后 ，产生歧义</li>
<li>使用do { … } while(0)这种结构 ， 在宏展开后，是一个代码块，避免发生歧义</li>
</ul>
<p><br><strong>缺陷:</strong></p>
<ul>
<li>因为 <code>__attribute__</code>  关键字不能作用于宏 , 所以没办法让编译器进行可变参数的检查</li>
<li>也无法使用<strong>内联函数</strong> , 因为使用了变参数列表 , 所以内联函数无法展开</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>代码实现二：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_OUTPUT_LEVEL 3			<span class="comment">// 输出等级(最大为4)</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	0: 关闭打印</span></span><br><span class="line"><span class="comment">	1: 只打印错误信息</span></span><br><span class="line"><span class="comment">	2: 打印警告和错误信息</span></span><br><span class="line"><span class="comment">	3: 打印所有信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARINING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO     3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印函数 */</span></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_warn(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 若打印等级不符合,则只输出空函数 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> (LOG_OUTPUT_LEVEL &gt;= LOG_WARINING)   </span></span><br><span class="line">    <span class="type">char</span> log_str[LOG_OUTPUT_MAX_LEN];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, fmt);</span><br><span class="line">    </span><br><span class="line">    len += vsnprintf(log_str, LOG_OUTPUT_MAX_LEN - len, fmt, arg);</span><br><span class="line">    </span><br><span class="line">    va_end(arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,log_str);  </span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_info(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_error(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="4722-属性-weak"><a class="markdownIt-Anchor" href="#4722-属性-weak"></a> 4.7.2.2 属性:  <code>weak</code></h5>
<blockquote>
<p><strong>作用 :</strong>　将一个<strong>强符号</strong>转换为<strong>弱符号</strong> , 可用于函数和变量</p>
<p><strong>用途 :</strong>   主要用于定义可以在用户代码中覆盖的库函数</p>
<p><strong>格式:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  __attribute__((weak))  func(<span class="type">void</span>);			<span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span>  num  __attribte__((weak);						<span class="comment">// 变量声明</span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li><strong>强符号：</strong> 函数名、初始化的全局变量名；</li>
<li><strong>弱符号：</strong> 未初始化的全局变量名。</li>
</ul>
<br>
<p><strong>不同场景下的同名符号:</strong></p>
<ul>
<li><strong>（强符号 + 强符号）:</strong> 在一个工程中同时定义两个同名的<strong>函数</strong>或<strong>全局变量</strong> , 在链接器链接目标文件的时候会报<strong>重定义错误</strong></li>
<li><strong>(强符号 + 弱符号) :</strong>   在一个工程中同时定义两个同名的<strong>初始化全局变量</strong>或<strong>未初始化全局变量</strong> , 编译器一般会<strong>选用强符号</strong>，<strong>丢掉弱符号</strong>。</li>
<li><strong>(弱符号 + 弱符号) :</strong>  谁的体积大，即谁在内存中存储空间大，使用谁。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="type">int</span> a __attribute__((weak)) = <span class="number">1</span>;		<span class="comment">// 将一个初始化的全局变量声明为弱符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> __attribute__((weak)) func(<span class="type">void</span>);	<span class="comment">// 将一个函数声明为弱符号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main：a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (func)							<span class="comment">// 在调用弱符号函数时 , 先判断函数地址是否为0</span></span><br><span class="line">        func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><strong>输出结果:</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>: <span class="selector-tag">a</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如上所示 ：</strong></p>
<ul>
<li>链接器在链接时会选择 main.c 中的这个强符号(即a = 4)</li>
<li>当函数被声明为一个弱符号时 , 如果链接器找不到定义时 , 不会报错 ,而是将这个弱符号设置为0</li>
<li>只有当程序运行时 , 调用到这个函数时 , 才会产生内存错误</li>
</ul>
</blockquote>
<br>
<hr />
<h5 id="4723-属性-alias"><a class="markdownIt-Anchor" href="#4723-属性-alias"></a> 4.7.2.3 属性 : <code>alias</code></h5>
<blockquote>
<p><strong>作用 :</strong>  用于给函数定义一个别名</p>
<p><strong>用途 :</strong>  主要与<code>weak</code>属性一起使用 , 通过<code>alias</code>属性对旧的函数接口做封装 , 起一个新接口的名字</p>
<p><strong>格式 :</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* __f()函数定义一个别名f() , 可以通过调用f()函数来直接调用_f() */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((alias(<span class="string">&quot;__f&quot;</span>)))</span>;  </span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>将<code>alias</code> 有时会和 <code>weak</code> <code>属性一起使用</code></li>
<li>如果<code>mian.c</code>新定义了<code>f()</code>函数 , 则调用的新定义的<code>f()</code>函数</li>
<li>当<code>f()</code> 没有定义时 , 就会调用<code>_f()</code>函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f.c</span></span><br><span class="line"><span class="type">void</span> __f(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__f()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 给_f()函数声明一个别名f(), 并声明为弱符号函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((weak,alias(<span class="string">&quot;__f&quot;</span>)))</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">void</span> __attribute__((weak)) f(<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h5 id="4724-属性-noinline-always_inline"><a class="markdownIt-Anchor" href="#4724-属性-noinline-always_inline"></a> 4.7.2.4 属性:  <code>noinline</code> &amp; <code>always_inline</code></h5>
<blockquote>
<p><strong>作用:</strong></p>
<blockquote>
<ul>
<li><strong>noinline:</strong>  通过声明<code>noinline</code>使指定的内联函数<strong>不展开</strong></li>
<li><strong>always_inline:</strong> 通过声明<code>always_inline</code>使指定的内联函数<strong>展开</strong></li>
</ul>
</blockquote>
<p><strong>用途:</strong></p>
<blockquote>
<ul>
<li>因为通过inline关键字修饰的函数 , 并不一定在编译时会展开</li>
<li>如函数体太大、存在循环、存在指针、函数调用频繁等情况 ，编译器一般不会做内联展开</li>
<li>通过使用<code>noinline</code>和<code>always_inline</code> 来<strong>显式的</strong>指定编译器是否做内联展开</li>
</ul>
</blockquote>
<p><strong>格式：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> __attribute__((noinline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> __attribute__((always_inline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h4 id="473-类型属性说明"><a class="markdownIt-Anchor" href="#473-类型属性说明"></a> 4.7.3 类型属性说明</h4>
<br>
<blockquote>
<p><mark>类型属性 :</mark></p>
<ul>
<li>aligned</li>
<li>packed</li>
<li>transparent_union</li>
<li>unused</li>
<li>deprecated</li>
<li>may_alias</li>
</ul>
</blockquote>
<br>
<p>(官方文档 👇)</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes">(类型属性说明 - 官方文档)</a></p>
<br>
<hr />
<h3 id="48-内建函数"><a class="markdownIt-Anchor" href="#48-内建函数"></a> 4.8  内建函数</h3>
<blockquote>
<p><strong>内建函数 :</strong></p>
<blockquote>
<ul>
<li>GNU C提供了大量内建函数 , 内建函数是在编译器内部实现的函数 , 可以如关键字一样直接调用</li>
<li>通常以<code>__builtin</code>开头</li>
<li>主要是在编译器内部使用 , 为编译器服务的</li>
</ul>
</blockquote>
<p><br><strong>用途:</strong></p>
<blockquote>
<ul>
<li>用来处理变长参数列表；</li>
<li>用来处理程序运行异常、编译优化、性能优化；</li>
<li>查看函数运行中的底层信息、堆栈信息等；</li>
<li>C 标准库函数的内建版本。</li>
</ul>
</blockquote>
<p><br><strong>说明 :</strong></p>
<blockquote>
<ul>
<li>在开发中 , 一般不会使用内建函数</li>
<li>因为有些函数 , 有助于我们对程序运行的底层机制、编译优化等的理解</li>
<li>而且在Linux内核中也经常会使用 ， 所以还是应该去了解</li>
</ul>
</blockquote>
</blockquote>
 <br>
<hr />
<blockquote>
<p>简单介绍几种常见的内建函数</p>
</blockquote>
<h4 id="481-__builtin_return_addresslevel"><a class="markdownIt-Anchor" href="#481-__builtin_return_addresslevel"></a> 4.8.1   <code>__builtin_*return_*address(LEVEL)</code></h4>
<blockquote>
<p><strong>作用 :</strong></p>
<ul>
<li>
<p>返回当前函数或其调用者的返回地址</p>
</li>
<li>
<p>参数<code>LEVEL</code>指定调用栈的级数;</p>
<blockquote>
<ul>
<li>0 : 表示当前函数的返回地址;</li>
<li>1 :表示当前函数的调用者的返回地址;</li>
<li>2: 获取上二级函数的返回地址</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> *p;</span><br><span class="line">     p = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;main return address: %p\n&quot;</span>,p);		<span class="comment">// 获取当前函数的返回地址</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li>C 语言函数在<strong>调用过程</strong>中，会将当前函数的<strong>返回地址</strong>、<strong>寄存器等现场信息</strong>保存在堆栈中，然后才会跳到被调用函数中去执行。</li>
<li>当被调用函数执行结束后，根据保存在堆栈中的返回地址，就可以直接返回到原来的函数中继续执行。</li>
</ul>
<br>  
<hr />
<h4 id="482-__builtin_constant_pexp"><a class="markdownIt-Anchor" href="#482-__builtin_constant_pexp"></a> 4.8.2 <code>__builtin_constant_p(EXP)</code></h4>
<blockquote>
<p><strong>作用 :</strong>  用于判断参数<code>EXP</code>在编译时 是否为<strong>常量</strong></p>
<p><strong>说明 :</strong>  如果<code>EXP</code>是常量返回 1 ; 否则返回 0</p>
<p><strong>用途 ;</strong>  主要用于宏定义中 , 根据宏的参数是常量还是变量 , 实现的方法也不同</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 根据参数是否为常数 , 实现不同的版本 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dma_cache_sync(addr, sz, dir)        		\</span></span><br><span class="line"><span class="meta">do &#123;                            			  		\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_constant_p(dir))          		\</span></span><br><span class="line"><span class="meta">        __inline_dma_cache_sync(addr, sz, dir); 	\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>                        					\</span></span><br><span class="line"><span class="meta">        __arc_dma_cache_sync(addr, sz, dir);   	    \</span></span><br><span class="line"><span class="meta">&#125;                           					    \</span></span><br><span class="line"><span class="meta">while (0);</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="483-__builtin_expectexpc"><a class="markdownIt-Anchor" href="#483-__builtin_expectexpc"></a> 4.8.3 <code>__builtin_expect(exp,c)</code></h4>
<blockquote>
<p><strong>作用 :</strong>  用于为编译器提供分支预测信息 ,</p>
<p><strong>说明 :</strong>   无论参数<code>C</code>的值是什么 , 该内建函数的返回值都是<code>exp</code> , <code>c</code>必须是编译时的常数</p>
<p><strong>用途 ：</strong> <code>Linux</code>内核编程时常用的<code>likely（）</code>和<code>unlikely（）</code>就是通过<code>__builtin_expect(exp,c)</code>实现的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 将参数x转换为布尔类型 , 然后与1和0直接做比较 , 告诉编译器x为真或假的可能性很高 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely_notrace(x) __builtin_expect(!!(x), 1) 		<span class="comment">// 告诉编译器x发生的概率很高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely_notrace(x) __builtin_expect(!!(x), 0)		<span class="comment">// 告诉编译器x发生的概率很低</span></span></span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>注意：</font ></p>
<blockquote>
<p>为什么要进行两次取非操作</p>
<ul>
<li>为了把传入参数转换为布尔类型</li>
<li>如果参数x是0, 两次取非后还是0</li>
<li>如果参数是非0 , 两次取非后会变成1</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="49-可变参数宏"><a class="markdownIt-Anchor" href="#49-可变参数宏"></a> 4.9 可变参数宏</h3>
<blockquote>
<p><strong>说明 :</strong></p>
<blockquote>
<p>在标准<code>C</code>语言中支持可变参数函数( 具体见<a href="#three">变参函数的实现</a> ) ;</p>
<p>而在<code>GNU C</code>中，宏也可以接受可变数目的参数</p>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font >变参宏的实现形式其实跟变参函数差不多 :</p>
<ul>
<li>用 <code>...</code> 表示<strong>变参列表</strong>，变参列表由不确定的参数组成，各个参数之间用逗号隔开。</li>
<li>可变参数宏使用 <code>__VA_ARGS__</code> 预定义<strong>标识符</strong>来表示前面的变参列表</li>
<li>预处理器在将<strong>宏展开</strong>时，会用变参列表<strong>替换</strong>掉宏定义中的所有 <code>__VA_ARGS__</code> 标识符。</li>
<li>也可以用<code>args...</code>表示变参列表 , 在后面的宏定义中直接使用<code>arg</code>表示变参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用__VA_ARGS__ */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(...) __log_with_level(LOG_INFO, __VA_ARGS__)	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用args... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(args...) __log_with_level(LOG_INFO, arg)	</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="491-拓展-宏定义中的特殊符号"><a class="markdownIt-Anchor" href="#491-拓展-宏定义中的特殊符号"></a> 4.9.1 拓展 —— 宏定义中的特殊符号</h4>
<blockquote>
<p>宏定义语句中存在一些特殊的符号 ：</p>
<ul>
<li>
<p>语句连接符 <code>\</code> ： 用于在复杂宏定义中 ， 将上下行连接起来 ， 表示上下行同属于一行</p>
</li>
<li>
<p>符号<code>#</code> ：将其后面的宏参数进行<strong>字符串化</strong>操作，简单说就是在对它所引用的<strong>宏变量</strong> 通过替换后在其左右各加上一个双引号。</p>
</li>
<li>
<p>符号<code>#@</code> :  将标记转换为相应的单个字符 , 注意：仅对单一标记转换有效 .</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> B(x) #@x     <span class="comment">// B(1) 即&#x27;1&#x27; ; B(a)即&#x27;a&#x27; ; 对B(abc)无效</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>义参数连接符 <code>##</code>：主要用于将宏定义中的两个<code>token</code>链接起来，这里的<code>token</code>可以是宏的变量，也可以是任意参数或者标记。(宏展开时会将<code>##</code> 两边的字符合并 , 并删除<code>##</code>这个连接符)</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> f(a,b) a##b     <span class="comment">// 输入f(a,1)输出为a1</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<h4 id="492-通过连接符对宏进行优化"><a class="markdownIt-Anchor" href="#492-通过连接符对宏进行优化"></a> 4.9.2 通过<code>##</code>连接符对宏进行优化</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(fmt, ...) printf(fmt, __VA_ARGS__)  <span class="comment">// 定义一个简单的可变参数宏 </span></span></span><br></pre></td></tr></table></figure>
<p><strong>如上所示 :</strong></p>
<ul>
<li>
<p>如上的定义方式存在漏洞　：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;test&quot;,);		// 如果变参为空时,宏展开后会产生语法错误</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用<code>##</code>连接符来避免产生这个语法错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define LOG(<span class="built_in">fmt</span>, ...) <span class="built_in">printf</span>(<span class="built_in">fmt</span>, <span class="comment">##__VA_ARGS__)</span></span> </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当变参列表非空时，## 的作用是连接 <code>fmt</code>，和变参列表，各个参数之间用逗号隔开，宏可以正常使用</p>
</li>
<li>
<p>当变参列表为空时，<code>##</code>会将固定参数 <code>fmt</code> 后面的逗号删除掉，这样宏也就可以正常使用了。</p>
</li>
</ul>
<br>
<hr />
<br>
<h2 id="5️⃣-c语言补充"><a class="markdownIt-Anchor" href="#5️⃣-c语言补充"></a> 5️⃣ C语言补充</h2>
<h3 id="51-内联函数与宏"><a class="markdownIt-Anchor" href="#51-内联函数与宏"></a> 5.1 内联函数与宏</h3>
<h4 id="511-宏与带参宏"><a class="markdownIt-Anchor" href="#511-宏与带参宏"></a> 5.1.1 宏与带参宏</h4>
<p>宏定义<code>#define</code>  本质是替换，从宏变成最终替换文本的过程称为<mark>宏展开</mark>。</p>
<br>
<h5 id="5111-带参宏"><a class="markdownIt-Anchor" href="#5111-带参宏"></a> 5.1.1.1 带参宏</h5>
<p>带参宏的用法与函数调用不完全相同，可能存在部分<strong>陷阱</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">5</span>;</span><br><span class="line">	SQUARE(x+<span class="number">2</span>);</span><br><span class="line">    SQUARE(++x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意 ：</strong> 上面两个运行结果分别是 <mark>17</mark> ；<mark>42</mark></p>
<p><strong>原因如下:</strong></p>
<ul>
<li><code>SQUARE(x+2);</code> 被替换成（5+2 * 5 +2 = 17）</li>
<li><code>SQUARE(++x);</code> 被替换成（++x * ++x = 6*7 =42）</li>
</ul>
</blockquote>
<br>
<h5 id="5112-总结"><a class="markdownIt-Anchor" href="#5112-总结"></a> 5.1.1.2 总结：</h5>
<ul>
<li>宏起到的作用只是替换，而不提供计算；</li>
<li>宏是在代码处不加任何验证的简单替代</li>
<li>宏不可以在运行时调试</li>
</ul>
<hr />
<h4 id="512-内联函数"><a class="markdownIt-Anchor" href="#512-内联函数"></a> 5.1.2  内联函数</h4>
<h5 id="5121-定义"><a class="markdownIt-Anchor" href="#5121-定义"></a> 5.1.2.1 定义：</h5>
<blockquote>
<p>一个用<code>inline</code>声明的函数称为内联函数 , 内联函数一般前面会使用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span> x)</span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内联函数可以定义在头文件中，因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题</strong></p>
<hr />
<br>
<ul>
<li><code>inline</code>是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。</li>
<li><strong>对于短小的代码来说，inline可以带来一定的效率提升</strong>，而且和函数宏相比，<code>inline</code> <strong>更安全可靠</strong>。</li>
<li>可是这个是以<strong>增加空间消耗为代价</strong>的 , 因为内联函数相当于<strong>代码复制</strong>，在运行时，将内联的代码复制上去。</li>
</ul>
<br>
<p><strong>内联函数一般使用情况：</strong></p>
<ul>
<li>一个函数不断被重复调用。</li>
<li>函数体积小</li>
<li>且函数不包含<strong>指针赋值</strong>、<strong>递归</strong>、<strong>循环</strong>等语句。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>一般来说，我们写小程序没有必要定义成<code>inline</code></li>
<li>但是如果要完成一个工程项目，<mark>当一个简单函数被调用多次时</mark>，则应该考虑用<code>inline</code>。</li>
<li>使用static和inline关键字修饰它 , 并可以视情况使用<code>noinline</code>或<code>always_inline</code>进行声明</li>
</ul>
<br>
<hr />
<h4 id="513-宏与内联函数"><a class="markdownIt-Anchor" href="#513-宏与内联函数"></a> 5.1.3 宏与内联函数</h4>
<p>相比于函数宏 , 内联函数具有以下<strong>优势:</strong></p>
<ul>
<li>参数类型检查。内联函数虽然具有宏的展开特性，但其本质仍是函数，编译过程中，编译器仍可以对其进行参数检查，而宏就不具备这个功能。</li>
<li>便于调试。函数支持的调试功能有断点、单步……，内联函数也同样可以。</li>
<li>返回值。内联函数有返回值，返回一个结果给调用者。这个优势是相对于 ANSI C 而言的。不过现在宏也可以有返回值和类型了，比如使用<strong>语句表达式</strong>定义的宏。</li>
<li>接口封装。有些内联函数可以用来封装一个接口，而宏不具备这个特性。</li>
</ul>
<br>
<hr />
<h5 id="5131-总结"><a class="markdownIt-Anchor" href="#5131-总结"></a> 5.1.3.1 总结：</h5>
<ul>
<li>宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入调用处，而减少了普通函数调用时的资源消耗。</li>
<li>宏<strong>不是函数</strong>，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体。</li>
<li><code>inline</code>函数<strong>是函数</strong>，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；</li>
</ul>
<br>
<hr />
<h4 id="514内联函数为什么用static修饰"><a class="markdownIt-Anchor" href="#514内联函数为什么用static修饰"></a> 5.1.4内联函数为什么用static修饰</h4>
<blockquote>
<p>内联函数为什么定义在头文件中</p>
<blockquote>
<ul>
<li>内联函数的使用方法和宏类似</li>
<li>通过定义在头文件中 , 任何想要使用该内联函数的源文件 ,只需要包含该头文件 ,而不需要重新定义一遍</li>
</ul>
</blockquote>
<br>
<p>内联函数为什么要用static修饰</p>
<blockquote>
<ul>
<li>因为我们使用 inline 定义的内联函数，编译器<strong>不一定会内联展开</strong></li>
<li>那么当多个文件都包含这个内联函数的定义时，编译时就有可能报<strong>重定义错误</strong>。</li>
<li>而使用 static 修饰，可以将这个函数的<strong>作用域</strong>局限在各自<strong>本地文件内</strong>，避免了重定义错误。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<br>
<hr />
<h3 id="52-预定义宏"><a class="markdownIt-Anchor" href="#52-预定义宏"></a> 5.2 预定义宏</h3>
<blockquote>
<p>C标准规定了一些预定义宏( 前文关于<a href="#four">日志函数优化</a> 部分就使用了部分预定义宏)</p>
</blockquote>
<br>
<p><mark>预定义宏:</mark></p>
<p><img src="https://pic.imgdb.cn/item/632ea1b616f2c2beb1c1914d.png" alt="image-20220920221113126" /></p>
<br>
<p><strong>注意:</strong>  使用时注意这些宏的作用域</p>
<hr />
<h3 id="53-pragma"><a class="markdownIt-Anchor" href="#53-pragma"></a> 5.3 #pragma</h3>
<blockquote>
<p><strong>作用 ：</strong> <code>#pragma</code> 是一个C语言中的预处理指令，用于设定编译器的状态或者指示编译器完成一些特定的动作</p>
<p><strong>注意:</strong></p>
<blockquote>
<ul>
<li><code>#pragma</code> 所定义的很多指示字是编译器特有的</li>
<li><code>#pragma</code> 在不同的编译器间是不可移植的</li>
<li>预处理器将忽略它不认识的 <code>#pragma</code> 指令</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font ></p>
<p><code>ARM-MDK</code>下支持的<code>#pragma</code>指令:</p>
<p><img src="https://pic.imgdb.cn/item/632ea1bc16f2c2beb1c19b07.png" alt="image-20220922201802679" /></p>
<hr />
<blockquote>
<p>介绍其中几种 , 但不同编译器对其指令的支持不同</p>
</blockquote>
<br>
<h4 id="531-pragma-packn"><a class="markdownIt-Anchor" href="#531-pragma-packn"></a> 5.3.1  #pragma pack(n)</h4>
<blockquote>
<p><strong>作用  :</strong>   告诉编译器 ,  <em><strong>结构体或类</strong></em> 内部的成员变量相对于 <em><strong>第一个变量</strong></em> 的地址的偏移量的对齐方式</p>
<p><strong>注意  :</strong></p>
<blockquote>
<ul>
<li>在参数n缺省的情况下 , 编译器按自然边界对齐</li>
<li>当变量所需的自然对齐边界比n大时 , 按照n对齐</li>
<li>否则按自然边界对齐</li>
</ul>
</blockquote>
</blockquote>
<br>
<p>[👇  关于结构体对齐,  前文已经介绍过了 ]</p>
<p>(<a href="#two">结构体对齐</a>)</p>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)		<span class="comment">// 使结构体按一字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为7 (1 + 4 + 2 = 7)</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> b ;		<span class="comment">// 偏移为1; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> c ;		<span class="comment">// 偏移为5; 占用2字节; 填充0字节</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>如上所示:</strong></p>
<ul>
<li>结构体成员的大小取其内部<strong>长度最大</strong>的数据成员作为其大小;</li>
<li>因为pack 参数默认为 8，所以对齐参数为 4 ;</li>
<li>一般的 pack 对齐格式分别是 1，2，4，8，16;</li>
<li>在默认的对齐格式，也就是<code>#pragmapack()</code> 的情况下，会在结构体中挑选占用字节最多的类型</li>
</ul>
<br>
<hr />
<h5 id="5311-pragma-pack-和-__attribute__packed-和-__attribute__aligned"><a class="markdownIt-Anchor" href="#5311-pragma-pack-和-__attribute__packed-和-__attribute__aligned"></a> 5.3.1.1 <code>#pragma pack</code> 和  <code>__attribute__(packed)</code> 和 <code>__attribute__(aligned)</code></h5>
<br>
<ul>
<li>
<p><code>#pragma pack</code>设置结构体和联合体的字节对齐方式 , 一般参数是 1，2，4，8，16;</p>
<br>
</li>
<li>
<p><code>__attribute__ ((__packed__))</code>关键字用于指定一个<strong>变量或类型</strong>以最小的方式对齐</p>
<ul>
<li>用于告诉编译器 , <strong>不对结构体进行</strong>对齐处理 , 即按照它原有的类型大小分配空间</li>
<li><code>__attribute__ ((__packed__))</code>是个<strong>类型属性</strong>可用于单独的结构体成员,也可用于变量</li>
</ul>
<br>
</li>
<li>
<p><code>__attribute__((aligned(n)))</code> 作用与<code>#pragma pack</code>类似, 也是指定<strong>变量或类型</strong>对齐方式</p>
<ul>
<li><code>__attribute__((aligned(n)))</code>同样是一个<strong>类型属性</strong> , 不仅可以显性指定结构体<strong>某个成员的地址对齐</strong> ; 也可以显式指定<strong>整个结构体</strong>的对齐方式</li>
<li><code>__attribute__((aligned(n)))</code>的参数必须的<strong>2的幂次方</strong></li>
</ul>
</li>
</ul>
<br>
<p>[👇 关于和 , 可查看前文  ]</p>
<p>(<a href="#five"><strong>attribute</strong>(packed)</a> ; <a href="#six"><strong>attribute</strong>(aligned)</a>)</p>
<hr />
<h4 id="532-pragma-message"><a class="markdownIt-Anchor" href="#532-pragma-message"></a> 5.3.2  <code>#pragma message</code></h4>
<blockquote>
<p><strong>作用 :</strong>  在编译到该处代码时会在 <em><strong>编译输出窗口</strong></em> 中将制定 消息文本 打印出来。</p>
<p><strong>格式 :</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;消息文本&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>用途 :</strong>  可用于在版本更替的时候 , 输出版本信息等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(version V1.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V1.0...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(version V1.3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V1.3...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(version V2.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V2.0...&quot;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<h4 id="533-pragma-once"><a class="markdownIt-Anchor" href="#533-pragma-once"></a> 5.3.3  <code>#pragma once</code></h4>
<blockquote>
<p><em><strong>作用 :</strong></em>   <code>#pragma once</code> 用于保证头文件只被编译一次</p>
<p><em><strong>注意 :</strong></em>   <code>#pragma once</code> 不一定会被编译器支持</p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLOBAL_H_				<span class="comment">// 条件编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GLOBAL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><em><strong>如上所示 :</strong></em></p>
<ul>
<li>条件编译
<ul>
<li>被 C 语言所支持的，并不是只包含一次头文件 , 而是包含多次</li>
<li>通过宏控制 , 可以保证头文件里面的内容只被嵌入一次</li>
<li>由于在编译之前 , 预处理器还是处理了多次 , 所以效率上比较低</li>
</ul>
</li>
<li><code>#pragma once</code>
<ul>
<li>是告诉预处理器当前文件只编译一次，所以说效率较高</li>
<li>通过与条件编译指令一起使用 , 即保证了移植性 , 又保证了效率</li>
</ul>
</li>
</ul>
<br>
<hr />
<h3 id="54-assert断言"><a class="markdownIt-Anchor" href="#54-assert断言"></a> 5.4  assert断言</h3>
<blockquote>
<p><em><strong>作用 :</strong></em>  计算表达式 <code>expression</code> ，如果其值为假（即为0），那么它先向<code>stderr</code>打印一条出错信息，然后通过调用 <code>abort</code> 来终止程序运行</p>
<br>
<p><em><strong>宏原型 :</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span> <span class="params">(<span class="type">int</span> expression)</span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>expression</code>可以是一个条件表达式或逻辑表达式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert(n != <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<br>
<p><em><strong>说明 :</strong></em></p>
<blockquote>
<ul>
<li>assert宏的原型定义在<code>&lt;assert.h&gt;</code>中</li>
<li><strong>assert是宏，而不是函数。</strong></li>
<li><code>assert</code> 的调用会增加额外的开销 ;</li>
<li>一般可以用于在函数开始出 <em><strong>检验传入参数</strong></em> 的合法性</li>
<li>在调试结束后，可以通过插入 <code>#define NDEBUG</code> 来禁用 <code>assert</code> 调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* NDEBUG宏和assert宏原型 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(e) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(e)  \</span></span><br><span class="line"><span class="meta">    ((void) ((e) ? ((void)0) : __assert (#e, __FILE__, __LINE__)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><em><strong>注意 :</strong></em></p>
<blockquote>
<ul>
<li><strong>每个assert只检验一个条件</strong> ( 存在多个条件时 , 无法<strong>直观的判断是哪个条件失败</strong>)</li>
<li>因为<code>assert</code>只在<code>DEBUG</code>个生效 , 所以不能使用改变环境的语句 <em><strong>(如 :   <code>assert(i++ &lt; 100)</code>)</strong></em></li>
</ul>
</blockquote>
<br>
<p><em><strong>优点 :</strong></em></p>
<ul>
<li>使用<code>assert()</code>能自动标识出文件和出问题的行号</li>
<li>而且提供了一种无需更改代码就能开启或关闭的断言机制</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="55-共用体-union"><a class="markdownIt-Anchor" href="#55-共用体-union"></a> 5.5 共用体 <code>union</code></h3>
<blockquote>
<p><em><strong>一般形式:</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">成员表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br>
<p><em><strong>结构体和共用体的区别在于 :</strong></em></p>
<ul>
<li>结构体的各个成员会 <em><strong>占用不同的内存</strong></em> ，互相之间没有影响；</li>
<li>而共用体的所有成员 <em><strong>占用同一段内存</strong></em> ，修改一个成员会影响其余所有成员。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用实例：</font ></p>
<hr />
<h4 id="551-数据传输"><a class="markdownIt-Anchor" href="#551-数据传输"></a> 5.5.1  数据传输</h4>
<blockquote>
<p>用于传输浮点数据</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">f_data</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在进行数据传输的时候会方便很多，比如<strong>串口传输</strong>只需要把这个数组 <code>byte[4]</code> 进行传输就可以了。</p>
<br>
<hr />
<h4 id="552-管理状态变量"><a class="markdownIt-Anchor" href="#552-管理状态变量"></a> 5.5.2 管理状态变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sys_status</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> all_status;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> status1 : <span class="number">1</span>;   <span class="comment">// FALSE / TRUE</span></span><br><span class="line">        <span class="type">bool</span> status2 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status3 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status4 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status5 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status6 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status7 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status8 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status9 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status10 : <span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; bit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>如上所示 :</strong></em></p>
<ul>
<li>
<p>将各个状态封装成联合体类型;</p>
</li>
<li>
<p>联合体里边的成员是一个<code>32bit</code>的 <em><strong>整数</strong></em> 及一个 <em><strong>结构体</strong></em> ，该结构体以 <em><strong>位域</strong></em> 的形式体现。</p>
</li>
<li>
<p><strong>由于每个字段恰好为 1位 ，所以只能为其赋值 1 或 0 。</strong></p>
</li>
<li>
<p>这样就可以方便的操作 <em><strong>每个</strong></em> 状态标志位了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sys_status.bit.status1 = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也可以直接操作 <em><strong>全部</strong></em> 标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sys_status.all_status = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>补充说明：</font ></p>
<blockquote>
<p><em><strong>位域:</strong></em></p>
<ul>
<li>
<p>C语言允许在一个结构体中 <em><strong>以位为单位来指定其成员所占内存长度</strong></em> ，这种以位为单位的成员称为“<em><strong>位段</strong></em>”或称“<em><strong>位域</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint8_t</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">uint8_t</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用位段能够用较少的位数存储数据， <code>:</code> 后面的数字用来限定成员变量占用的位数。</p>
</li>
</ul>
<br>
<p><em><strong>其他应用:</strong></em></p>
<ul>
<li>
<p>寄存器的封装 , 也是这样通过联合体封装的</p>
<p><img src="https://pic.imgdb.cn/item/632ea1c316f2c2beb1c1a38f.png" alt="image-20220923222927253" /></p>
</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="553-数据的拆分组合"><a class="markdownIt-Anchor" href="#553-数据的拆分组合"></a> 5.5.3 数据的拆分组合</h4>
<p>比如想要获取一个整数的 <em><strong>各个字节</strong></em></p>
<br>
<ul>
<li>可以采用 <em><strong>移位</strong></em> 的方式 , 例如:</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="attr">#define	GET_LOW_BYTE0</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt;  0)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第0个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE1</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt;  8)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第1个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE2</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt; 16)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第2个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE3</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt; 24)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第3个字节 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用 <em><strong>联合体</strong></em> 进行拆分:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte0;</span><br><span class="line">        <span class="type">uint8_t</span> byte1;</span><br><span class="line">        <span class="type">uint8_t</span> byte2;</span><br><span class="line">        <span class="type">uint8_t</span> byte3;</span><br><span class="line">    &#125;byte;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span> <span class="title">num</span>;</span></span><br><span class="line">    </span><br><span class="line">    num.data = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte0 = 0x%x\n&quot;</span>, num.byte.byte0);	<span class="comment">// 第一位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte1 = 0x%x\n&quot;</span>, num.byte.byte1);	<span class="comment">// 第二位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte2 = 0x%x\n&quot;</span>, num.byte.byte2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte3 = 0x%x\n&quot;</span>, num.byte.byte3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>补充说明：</font ></p>
<ul>
<li>
<p>在使用联合体进行数据操作时 , 要明确当前平台的 <em><strong>大小端模式</strong></em></p>
<ul>
<li><strong>大小端</strong> 用于表示数据在存储器中的 <em><strong>存放顺序</strong></em> ：</li>
<li><em><strong>大端模式</strong></em> ，是指数据的低位保存在内存的 高地址 中，而数据的高位，保存在内存的 低地址 中</li>
<li><em><strong>小端模式</strong></em> ，是指数据的低位保存在内存的 低地址 中，而数据的高位，保存在内存的 高地址 中</li>
</ul>
</li>
<li>
<p>同样的,可以使用联合体来进行 <em><strong>数据组合</strong></em>  :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span> <span class="title">num</span>;</span></span><br><span class="line">    </span><br><span class="line">    num.byte.byte0 = <span class="number">0x78</span>;</span><br><span class="line"> 	num.byte.byte1 = <span class="number">0x56</span>;</span><br><span class="line"> 	num.byte.byte2 = <span class="number">0x34</span>;</span><br><span class="line"> 	num.byte.byte3 = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num.data = 0x%x\n&quot;</span>, num.data);	<span class="comment">// num.data即为组合后数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<hr />
<h3 id="56-const关键字"><a class="markdownIt-Anchor" href="#56-const关键字"></a> 5.6 <code>const</code>关键字</h3>
<blockquote>
<p>摘抄自<a href="https://blog.csdn.net/K_O_R_K/article/details/120579024?spm=1001.2014.3001.5502">嵌入式 C语言 补充</a></p>
</blockquote>
<p>关键字const用来定义常量，如果一个变量被const修饰，那么它的值就不能再被改变，我想一定有人有这样的疑问，C语言中不是有#define吗，干嘛还要用const呢，我想事物的存在一定有它自己的道理，所以说const的存在一定有它的合理性，与预编译指令相比，const修饰符有以下的优点：</p>
<p>预编译指令只是对值进行简单的替换，不能进行类型检查<br />
可以保护被修饰的东西，防止意外修改，增强程序的健壮性<br />
编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。<br />
下面我们从几个方面来说一下const的用法：</p>
<br>
<hr />
<h4 id="561修饰局部变量"><a class="markdownIt-Anchor" href="#561修饰局部变量"></a> 5.6.1修饰局部变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">5</span>; <span class="type">int</span> <span class="type">const</span> n=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>这两种写法是一样的，都是表示变量n的值不能被改变了;</li>
<li>需要注意的是，用<code>const</code>修饰变量时，一定要给变量初始化，否则之后就不能再进行赋值了。</li>
</ul>
<br>
<p><code>const</code> 用于修饰常量 <em><strong>静态字符串</strong></em> ，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str=<span class="string">&quot;fdsafdsa&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[4]=’x’</code> 这样的语句</li>
<li>这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。</li>
<li>有了 <code>const</code> ，这个错误就能在编译期被发现。</li>
</ul>
<br>
<hr />
<h4 id="562常量指针与指针常量"><a class="markdownIt-Anchor" href="#562常量指针与指针常量"></a> 5.6.2常量指针与指针常量</h4>
<p><em><strong>常量指针</strong></em> 是指针指向的内容是常量，可以有一下两种定义方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * n; </span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * n;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li>
<p><em><strong>常量指针</strong></em> 说的是不能通过这个指针改变变量的值，但是还是 <em><strong>可以通过其他的引用来改变变量的值的.</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* n=&amp;a; a=<span class="number">6</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em><strong>常量指针</strong></em> 指向的值不能改变，但是这并不是意味着指针本身不能改变， <em><strong>常量指针可以指向其他的地址。</strong></em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; <span class="type">int</span> b=<span class="number">6</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* n=&amp;a; n=&amp;b;</span><br></pre></td></tr></table></figure>
<ul>
<li><em><strong>指针常量</strong></em> 是指指针本身是个常量，<em><strong>不能在指向其他的地址</strong></em> ，写法如下：</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> n;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针常量指向的<strong>地址不能改变</strong>，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> n=&amp;a;</span><br><span class="line">*p=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>区分<strong>常量指针</strong>和<strong>指针常量</strong>的关键就在于星号的位置，以星号为分界线;</li>
<li>如果<code>const</code>在星号的左边，则为<strong>常量指针</strong>; <code>int const *n</code>;是常量指针</li>
<li>如果<code>const</code>在星号的右边则为<strong>指针常量</strong>。<code>int *const n</code>是指针常量</li>
</ul>
<br>
<p><em><strong>指向常量的常指针</strong></em></p>
<ul>
<li>是以上两种的结合，指针 <em><strong>指向的位置不能改变</strong></em> 并且也 <em><strong>不能通过这个指针改变变量的值</strong></em></li>
<li>但是依然可以通过其他的 <em><strong>普通指针改变变量的值</strong></em> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="563-修饰函数的参数"><a class="markdownIt-Anchor" href="#563-修饰函数的参数"></a> 5.6.3 修饰函数的参数</h4>
<p>根据<strong>常量指针</strong>与<strong>指针常量</strong>，<code>const</code>修饰函数的参数也是分为三种情况:</p>
<ul>
<li>
<p>防止修改指针指向的内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>strSource</code> 是<strong>输入参数</strong>，<code>strDestination</code> 是<strong>输出参数</strong>。</li>
<li>给 <code>strSource</code> 加上 <code>const</code> 修饰后，如果函数体内的语句试图改动 <code>strSource</code> 的内容，编译器将指出错误</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>防止修改指针指向的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*指针p1和指针p2指向的地址都不能修改。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span> <span class="params">( <span class="type">int</span> *<span class="type">const</span> p1 , <span class="type">int</span> *<span class="type">const</span> p2 )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>以上两种的结合 , <strong>指针和内容都不能改</strong></li>
</ul>
<br>
<hr />
<h4 id="564-修饰函数的返回值"><a class="markdownIt-Anchor" href="#564-修饰函数的返回值"></a> 5.6.4 修饰函数的返回值</h4>
<p>如果给以“<strong>指针传递</strong>”方式的函数返回值加 <code>const</code> 修饰，那么函数返回值（即指针）的内容<strong>不能被修改</strong>，该返回值只能被赋给加<code>const</code> 修饰的同类型指针。</p>
<br>
<p><font face="华文彩云" color=red size=5>例如：</font ></p>
<p><em><strong>函数原型:</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetString</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如下语句将出现<strong>编译错误</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = GetString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = GetString();</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="565-修饰全局变量"><a class="markdownIt-Anchor" href="#565-修饰全局变量"></a> 5.6.5 修饰全局变量</h4>
<ul>
<li>全局变量的 <em><strong>作用域</strong></em> 是整个文件;</li>
<li>我们应该尽量 <strong>避免使用全局变量</strong>  , 因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数;</li>
<li>如果一定要用全局变量，我们应该尽量的使用<code>const</code>修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。</li>
</ul>
<br>
<h3 id="57-staic关键字"><a class="markdownIt-Anchor" href="#57-staic关键字"></a> 5.7 <code>staic</code>关键字</h3>
<p>static关键字在编写程序时一般有三大类用法：</p>
<ul>
<li>定义局部变量</li>
<li>定义全局变量</li>
<li>定义函数</li>
</ul>
<br>
<hr />
<h4 id="571-static定义局部变量"><a class="markdownIt-Anchor" href="#571-static定义局部变量"></a> 5.7.1 static定义局部变量</h4>
<blockquote>
<p><em><strong>作用域 :</strong></em>  作用域是为代码块内</p>
<p><em><strong>储存属性 :</strong></em> 用<code>static</code>定义的局部变量的生命周期 , 会变成静态储存 , 即全局都存在 ;</p>
<p><strong>储存位置 :</strong> 储存位置由 <em><strong>栈</strong></em> 转移到了 <em><strong>数据段</strong></em> (.text)中</p>
<p><strong>值 :</strong></p>
<ul>
<li>静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0</li>
<li>以后每次调用静态局部变量的时候都用上次调用后的值。</li>
<li>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，<strong>也是唯一的一次初始化</strong>。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> k = <span class="number">4</span>;   <span class="comment">// 在离开这个函数后,k = 4 不会变 ;在下次进入这个函数时 ,k都是4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d&quot;</span>, i );		<span class="comment">// 打印k的值 编译器会报错; 因为k的作用域还是局限在&#123;&#125;中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="5711-补充-内存空间分布"><a class="markdownIt-Anchor" href="#5711-补充-内存空间分布"></a> 5.7.1.1 补充 —— 内存空间分布</h5>
<p>可执行文件(.o)在被加载到内存中时 , <em><strong>内存空间分布图</strong></em>:</p>
<p><img src="https://pic.imgdb.cn/item/632ea1e216f2c2beb1c1c7ed.png" alt="image-20220924001131747" /></p>
<br>
<ul>
<li><em><strong>函数</strong></em> 翻译成二进制指令放在 <em><strong>代码段</strong></em> 中</li>
<li><em><strong>初始化的全局变量</strong></em> 和 <em><strong>静态局部变量</strong></em> 放在 <em><strong>数据段</strong></em> 中(.data)</li>
<li><em><strong>未初始化的全局变量</strong></em> 和 <em><strong>静态变量</strong></em> 放在 <em><strong>BSS段</strong></em> 中(.bss)</li>
<li>函数的 <em><strong>局部变量</strong></em> 保存在 <em><strong>栈</strong></em> 中</li>
<li>使用<code>malloc</code>申请的 <em><strong>动态内存</strong></em> 保存在 <em><strong>堆空间</strong></em> 中</li>
</ul>
<br>
<hr />
<h4 id="572-static定义全局变量"><a class="markdownIt-Anchor" href="#572-static定义全局变量"></a> 5.7.2 static定义全局变量</h4>
<blockquote>
<p><em><strong>作用域：</strong></em> 作用域仅为当前文件 ; 其他文件不可访问 ; 其他文件可以定义与其同名的变量</p>
<p><em><strong>储存属性 :</strong></em> 储存<strong>属性不变</strong> ,  还是 <em><strong>静态储存</strong></em>  , 生命周期为整个程序运行期间</p>
<p><em><strong>储存位置:</strong></em> 储存位置 <em><strong>不变</strong></em>  , 都是在在<code>.data</code>段（已初始化）或者<code>.bss</code>段（未初始化）内</p>
<p><em><strong>说明：</strong></em></p>
<blockquote>
<ul>
<li>用static定义的全局变量称为静态全局变量</li>
<li>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<h4 id="573-static定义函数"><a class="markdownIt-Anchor" href="#573-static定义函数"></a> 5.7.3 static定义函数</h4>
<blockquote>
<p><code>static</code>定义的<strong>函数</strong>与 static定义的<strong>全局变量</strong>特性相似</p>
<p><em><strong>作用域 :</strong></em> static函数的作用域是本源文件 ; 其他文件不能引用该函数 ; 其他文件可以定义 <em><strong>同名函数</strong></em></p>
<p><em><strong>储存属性 :</strong></em> <em><strong>静态储存</strong></em>, 生命周期为整个程序运行期间</p>
<p><em><strong>储存位置 :</strong></em>  储存在<strong>代码段</strong>(.test)中</p>
</blockquote>
<br>
<hr />
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>c语言</tag>
        <tag>学习</tag>
        <tag>gun</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式C语言学习记录(一) —— ARM指令集与作用域</title>
    <url>/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%E2%80%94%E2%80%94ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.9.11」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em></p>
<br>
<p><strong>摘要：</strong> 记录汇总自己在嵌入式开发过程中 学习的一些零散知识</p>
<br>
<p><strong>简介：</strong> 简单汇总,方便自己查看</p>
</blockquote>
<br>
<span id="more"></span>
<p>（👇 第二部分）</p>
<p><a href="https://ye2020.github.io/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/#more">嵌入式C语言学习记录(二) —— GNU拓展语法与C语言补充</a><br />
(👇 PDF 版)<br />
<a href="https://download.csdn.net/download/weixin_51330198/86701430?spm=1001.2014.3001.5501">PDF 文件</a></p>
<br>
<hr />
<br>
<br>
<hr />
<br>
<h2 id="1️⃣-stringh-库函数"><a class="markdownIt-Anchor" href="#1️⃣-stringh-库函数"></a> 1️⃣ string.h 库函数</h2>
<p><strong>下面是头文件 string.h 中定义的函数：</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>void *memchr(const void *str, int c, size_t n</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-memchr.html">在参数 <em>str</em> 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</a></td>
</tr>
<tr>
<td>2</td>
<td><code>int memcmp(const void *str1, const void *str2, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-memcmp.html">把 <em>str1</em> 和 <em>str2</em> 的前 n 个字节进行比较。</a></td>
</tr>
<tr>
<td>3</td>
<td><code>void *memcpy(void *dest, const void *src, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-memcpy.html">从 src 复制 n 个字符到 <em>dest</em>。</a></td>
</tr>
<tr>
<td>4</td>
<td><code>void *memmove(void *dest, const void *src, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-memmove.html">另一个用于从 <em>src</em> 复制 n 个字符到 <em>dest</em> 的函数。</a></td>
</tr>
<tr>
<td>5</td>
<td><code>void *memset(void *str, int c, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-memset.html">复制字符 c（一个无符号字符）到参数 <em>str</em> 所指向的字符串的前 n 个字符。</a></td>
</tr>
<tr>
<td>6</td>
<td><code>char *strcat(char *dest, const char *src)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strcat.html">把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾。</a></td>
</tr>
<tr>
<td>7</td>
<td><code>char *strncat(char *dest, const char *src, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strncat.html">把 <em>src</em> 所指向的字符串追加到 <em>dest</em> 所指向的字符串的结尾，直到 n 字符长度为止。</a></td>
</tr>
<tr>
<td>8</td>
<td><code>char *strchr(const char *str, int c)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strchr.html">在参数 <em>str</em> 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</a></td>
</tr>
<tr>
<td>9</td>
<td><code>int strcmp(const char *str1, const char *str2)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strcmp.html">把 <em>str1</em> 所指向的字符串和 <em>str2</em> 所指向的字符串进行比较。</a></td>
</tr>
<tr>
<td>10</td>
<td><code>int strncmp(const char *str1, const char *str2, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strncmp.html">把 <em>str1</em> 和 <em>str2</em> 进行比较，最多比较前 n 个字节。</a></td>
</tr>
<tr>
<td>11</td>
<td><code>int strcoll(const char *str1, const char *str2)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strcoll.html">把 <em>str1</em> 和 <em>str2</em> 进行比较，结果取决于 LC_COLLATE 的位置设置</a></td>
</tr>
<tr>
<td>12</td>
<td><code>char *strcpy(char *dest, const char *src)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strcpy.html">把 <em>src</em> 所指向的字符串复制到 <em>dest</em>。</a></td>
</tr>
<tr>
<td>13</td>
<td><code>char *strncpy(char *dest, const char *src, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strncpy.html">把 <em>src</em> 所指向的字符串复制到 <em>dest</em>，最多复制 n 个字符。</a></td>
</tr>
<tr>
<td>14</td>
<td><code>size_t strcspn(const char *str1, const char *str2)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strcspn.html">检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</a></td>
</tr>
<tr>
<td>15</td>
<td><code>char *strerror(int errnum)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strerror.html">从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</a></td>
</tr>
<tr>
<td>16</td>
<td><code>size_t strlen(const char *str)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strlen.html">计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</a></td>
</tr>
<tr>
<td>17</td>
<td><code>char *strpbrk(const char *str1, const char *str2)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strpbrk.html">检索字符串 <em>str1</em> 中第一个匹配字符串 <em>str2</em> 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</a></td>
</tr>
<tr>
<td>18</td>
<td><code>char *strrchr(const char *str, int c)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strrchr.html">在参数 <em>str</em> 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</a></td>
</tr>
<tr>
<td>19</td>
<td><code>size_t strspn(const char *str1, const char *str2)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strspn.html">检索字符串 <em>str1</em> 中第一个不在字符串 <em>str2</em> 中出现的字符下标。</a></td>
</tr>
<tr>
<td>20</td>
<td><code>char *strstr(const char *haystack, const char *needle)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strstr.html"> 在字符串 <em>haystack</em> 中查找第一次出现字符串 <em>needle</em>（不包含空结束字符）的位置。</a></td>
</tr>
<tr>
<td>21</td>
<td><code>char *strtok(char *str, const char *delim)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strtok.html">分解字符串 <em>str</em> 为一组字符串，<em>delim</em> 为分隔符。</a></td>
</tr>
<tr>
<td>22</td>
<td><code>size_t strxfrm(char *dest, const char *src, size_t n)</code></td>
<td><a href="https://www.runoob.com/cprogramming/c-function-strxfrm.html">根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 <strong>src</strong> 的前 <strong>n</strong> 个字符，并把它们放置在字符串 <strong>dest</strong> 中。</a></td>
</tr>
</tbody>
</table>
<br>
<hr />
<br>
<h2 id="2️⃣-arm汇编指令集"><a class="markdownIt-Anchor" href="#2️⃣-arm汇编指令集"></a> 2️⃣ ARM汇编指令集</h2>
<p><img src="https://pic.imgdb.cn/item/632ea0db16f2c2beb1c0781d.png" alt="在这里插入图片描述" /></p>
<br>
<ul>
<li><strong>R0~R3</strong>通常用来传递函数参数,</li>
<li><strong>R4~R11</strong>用来保存程序运算的中间结果或函数的局部变量等,</li>
<li><strong>R12</strong>常用来作为函数调用过程中的临时寄存器。</li>
<li><strong>R13</strong>寄存器又称为堆栈指针寄存器(StackPointer, SP) ,用来维护和管理函数调用过程中的栈帧变化, R13总是指向当前正在运行的函数的栈帧,一般不能再用作其他用途。</li>
<li><strong>R14</strong>寄存器又称为链接寄存器(Link Register, LR) ,在函数调用过程中主要用来保存上一级函数调用者的返回地址。寄存器</li>
<li><strong>R15</strong>又称为程序计数器(Program Counter, PC) , CPU从内存取指令执行,就是默认从PC保存的地址中取的,每取一次指令, PC寄存器的地址值自动增加。</li>
<li><strong>CPSR</strong> (当前处理器状态寄存器), 主要用来表征当前处理器的运行状态。除了各种状态位、标志位,CPSR寄存器里也有一些控制位,用来切换处理器的工作模式和中断使能控制。</li>
</ul>
<br>
<p><mark>CPSR寄存器标志位:</mark></p>
<img src="https://pic.imgdb.cn/item/632ea0f016f2c2beb1c08fc1.png" alt="image-20220910142630412" style="zoom:150%;" />
<br>
<h3 id="21-arm汇编指令"><a class="markdownIt-Anchor" href="#21-arm汇编指令"></a> 2.1 ARM汇编指令</h3>
<blockquote>
<p>一个完整的ARM指令通常是由<mark>操作码</mark> + <mark>操作数</mark></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;opcode&gt; &#123;&lt;cond&gt; &#123;s&#125; &lt;Rd&gt;,&lt;Rn&gt; &#123;,&lt;operand2&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 格式说明：</font></p>
<ul>
<li>使用<code>&lt;&gt;</code>标起来的是<strong>必选项</strong>,使用<code>&#123; &#125;</code>标起来的是<strong>可选项</strong>。</li>
<li><code>&lt;opcode&gt;</code>是二进制机器指令的操作码助记符,如<code>MOV</code>、<code>ADD</code>这些汇编指令都是操作码的<strong>指令助记符</strong>。</li>
<li><strong>cond</strong> : 执行条件, <code>ARM</code>为减少分支跳转指令个数,允许类似<code>BEQ</code>、<code>BNE</code>等形式的组合指令。</li>
<li><strong>S</strong>: 是否影响<code>CPSR</code>寄存器中的标志位,如SUBS指令会影响CPSR寄存器中的<code>N、Z、C、V</code>标志位,而<code>SUB</code>指令不会。</li>
<li><strong>Rd</strong> :目标寄存器。</li>
<li><strong>Rn</strong> :第一个操作数的寄存器。</li>
<li><strong>operand2</strong> :第二个可选操作数,灵活使用第二个操作数可以提高代码效率。</li>
</ul>
<br>
<hr />
<h5 id="211-操作数2operand2"><a class="markdownIt-Anchor" href="#211-操作数2operand2"></a> 2.1.1 操作数2(operand2)</h5>
<p>操作数operand2在汇编程序中经常出现的两种格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#constant		; 操作数是一个立即数</span><br><span class="line">Rm&#123;,shift&#125;		; 使用寄存器值作为操作数</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 注意：</font></p>
<p>在第二种格式中,通过<code>&#123;, shift&#125;</code>可选项,我们还可以通过多种移位或循环移位的方式,构建更加灵活的操作数。可选项<code>&#123;, shift&#125;</code>可以选择的移位方式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#constant,n 	;将立即数 constant循环右移n位</span><br><span class="line">ASR #			;算术右移n位, n的取值范围: [1,32]</span><br><span class="line">LSL #n			;逻辑左移n位, n的取值范围: [0,31]</span><br><span class="line">LSR #n			;逻辑右移n位, n的取值范围: [1,32]</span><br><span class="line">ROR #n			;向右循环移n位, n的取值范围: [1,31]</span><br><span class="line">RRX				;向右循环移1位,带扩展</span><br><span class="line">type Rs			;仅在ARM中可用,其中type指ASP、LSL、LSR、ROR, Rs是提供位移量的寄存器名称</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD R3, R2, R1, LSL #3		;R3=R2+R1&lt;&lt;3</span><br><span class="line">ADD R3, R2, R1, LSL R0		;R3=R2+R1&lt;&lt;R20</span><br><span class="line">ADD IP, IP, #16, 20			;IP=IP+立即数16循环右移20位</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h3 id="22-基本指令"><a class="markdownIt-Anchor" href="#22-基本指令"></a> 2.2 基本指令</h3>
<h4 id="221-储存访问指令"><a class="markdownIt-Anchor" href="#221-储存访问指令"></a> 2.2.1 储存访问指令</h4>
<h5 id="2211-ldr指令"><a class="markdownIt-Anchor" href="#2211-ldr指令"></a> 2.2.1.1 [<code>LDR</code>指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  LDR{条件} 目的寄存器，&lt;存储器地址&gt;;</p>
<p><strong>作用 :</strong> LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR  R0，[R1]               ;将存储器地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR  R0，[R1，R2]           ;将存储器地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line">LDR  R0，[R1，＃8]          ;将存储器地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR  R0，[R1，R2] ！        ;将存储器地址为R1+R2的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR  R0，[R1，＃8] ！       ;将存储器地址为R1+8的字数据读入寄存器R0，并将新地址R1＋8写入R1。</span><br><span class="line">LDR  R0，[R1]，R2          ;将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2写入R1。</span><br><span class="line">LDR  R0，[R1，R2，LSL＃2]！ ;将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br><span class="line">LDR  R0，[R1]，R2，LSL＃2   ;将存储器地址为R1的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>{！}为可选后缀，若选用该后缀，则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</p>
</blockquote>
<br>
<hr />
<br>
<h5 id="2212-str指令"><a class="markdownIt-Anchor" href="#2212-str指令"></a> 2.2.1.2 [<code>STR</code>指令]</h5>
<p><font face="华文彩云" color=red size=5> 注意：</font>  <code>LDR/STR</code>指令是<code>ARM</code>汇编中使用频率最高的一对指令</p>
<blockquote>
<p><strong>格式 :</strong>  STR{条件} 源寄存器，&lt;存储器地址&gt;;</p>
<p><strong>作用 :</strong>  STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR R0，[R1]，＃8  	;将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，＃8] 		;将R0中的字数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure>
<hr />
<br>
<hr />
<br>
<h5 id="2213-ldrb-指令"><a class="markdownIt-Anchor" href="#2213-ldrb-指令"></a> 2.2.1.3 [<code>LDRB</code> 指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  LDR{条件}B 目的寄存器，&lt;存储器地址&gt;</p>
<p><strong>作用 :</strong>  LDRB指令用于从存储器中将一个<strong>8位</strong>的字节数据传送到目的寄存器中，同时将寄存器的高24位清零。<br />
该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDRB  R0，[R1]        ;将存储器地址为R1的字节数据读入寄存器R0，并将R0的高24位清零。</span><br><span class="line">LDRB  R0，[R1，＃8]    ;将存储器地址为R1＋8的字节数据读入寄存器R0，并将R0的高24位清零。</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h5 id="2214-strb-指令"><a class="markdownIt-Anchor" href="#2214-strb-指令"></a> 2.2.1.4 [<code>STRB</code> 指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  STR{条件}B 源寄存器，&lt;存储器地址&gt;</p>
<p><strong>作用 :</strong>  STRB指令用于从源寄存器中将一个8位的字节数据传送到存储器中。该字节数据为源寄存器中的低8位。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRB  R0，[R1]      ;将寄存器R0中的字节数据写入以R1为地址的存储器中。</span><br><span class="line">STRB  R0，[R1，＃8]  ;将寄存器R0中的字节数据写入以R1＋8为地址的存储器中。</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h5 id="2215-ldrh-strh-指令"><a class="markdownIt-Anchor" href="#2215-ldrh-strh-指令"></a> 2.2.1.5 [<code>LDRH / STRH</code> 指令]</h5>
<blockquote>
<p><strong>格式:</strong></p>
<blockquote>
<ul>
<li>STR{条件}H 源寄存器，&lt;存储器地址&gt;</li>
<li>LDR{条件}H 目的寄存器，&lt;存储器地址&gt;</li>
</ul>
</blockquote>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>STRH指令用于从源寄存器中将一个16位的半字数据传送到存储器中。该半字数据为源寄存器中的低16位。</li>
<li>LDRH指令用于从存储器中将一个16位的半字数据传送到目的寄存器中，同时将寄存器的高16位清零。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<br>
<p>2.2.1.6 [<code>LDM / STM</code> 指令]</p>
<blockquote>
<p><strong>格式 :</strong>  LDM（或STM）{条件}{类型} 基址寄存器{！}，寄存器列表{∧}</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>批量加载/储存指令 , 在一组寄存器和内存间传输数据</li>
<li>常与堆栈格式组合使用 . 以模拟堆栈操作</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><strong>不同类型的堆栈:</strong></p>
<p><img src="https://pic.imgdb.cn/item/632ea0fd16f2c2beb1c0a098.png" alt="image-20220909162156729" /></p>
<br>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDMFD SP!,&#123;R0-R2,R14&#125;    ;将内存栈中的数据依次弹出到R14、R2、R1、R0</span><br><span class="line">STMFD SP!,&#123;R0-R2,R14&#125;	 ;将R0、R1、R2、R14依次压入内存栈</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 注意：</font></p>
<ul>
<li>每入栈一个元素, 栈指针<code>SP</code>都会往栈增长的方向移动一个存储单元.</li>
<li>栈是<strong>先入后出(FILO)</strong> , 所以<code>STMFD</code>指令会根据<code>&#123; &#125;</code>中的寄存器列表 ,<strong>从左到右</strong>压入栈</li>
<li><code>LDMFD</code> 指令出栈时,<strong>顺序相反</strong></li>
</ul>
<br>
<p><strong>入栈与出栈:</strong></p>
<p><img src="https://pic.imgdb.cn/item/632ea11016f2c2beb1c0b8ba.png" alt="image-20220909163300314" /></p>
<p><br> <font face="华文彩云" color=red size=5> 注意：</font></p>
<p>也可以通过<code>PUSH</code>/<code>POP</code> 指令来执行栈元素的<strong>入栈和出栈</strong>操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;R0-R2, R14&#125;	;将RO、R1、R2、R14依次压入栈,</span><br><span class="line">POP &#123;R0-R2,R14&#125; 	;将中的数据依次弹出到R14、R2、R1、R0</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h4 id="222-数据传送指令"><a class="markdownIt-Anchor" href="#222-数据传送指令"></a> 2.2.2 数据传送指令</h4>
<h5 id="2221-mov指令"><a class="markdownIt-Anchor" href="#2221-mov指令"></a> 2.2.2.1 [<code>MOV</code>指令]</h5>
<blockquote>
<p><strong>格式:</strong>  MOV{条件}{S} 目的寄存器，源操作数</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>是把一个寄存器的值(要能用立即数表示)赋给另一个寄存器，或者将一个常量赋给寄存器，将后边的量赋给前边的量。</li>
<li><code>MOV</code>指令中，条件缺省时指令无条件执行；</li>
<li>{S}用来表示是否影响<code>CPSR</code>寄存器的值,如<code>MOVS</code>指令就会影响寄存器<code>CPSR</code>的值,而<code>MOV</code>则不会</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R1，R0   		;将寄存器R0的值传送到寄存器R1</span><br><span class="line">MOV PC，R14   		;将寄存器R14的值传送到PC，常用于子程序返回</span><br><span class="line">MOV R1，R0，LSL＃3    ;将寄存器R0的值左移3位后传送到R1（即乘8）</span><br><span class="line">MOVS PC, R14	     ;将寄存器R14的值传送到PC中，返回到调用代码并恢复标志位</span><br></pre></td></tr></table></figure>
<br>
<h5 id="2222-mvn-指令"><a class="markdownIt-Anchor" href="#2222-mvn-指令"></a> 2.2.2.2 [<code>MVN</code> 指令]</h5>
<blockquote>
<p><strong>格式 :</strong> MVN{条件}{S} 目的寄存器，源操作数</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>MVN指令用来将操作数operand2按位取反后传送到目标寄存器Rd</li>
<li>与MOV指令不同的是 ,在传送之前就按位取反了</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MVN R0，＃0xFF   ;将立即数0xFF取反后赋值给R0</span><br><span class="line">MVN R0，R1 	    ;将R1寄存器的值取反后赋值给R0</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h4 id="223-算术逻辑运算指令"><a class="markdownIt-Anchor" href="#223-算术逻辑运算指令"></a> 2.2.3 算术逻辑运算指令</h4>
<h5 id="2231-算术指令"><a class="markdownIt-Anchor" href="#2231-算术指令"></a> 2.2.3.1 算术指令</h5>
<blockquote>
<p>算术指令包括 基本的加、减、乘、除</p>
</blockquote>
<p><strong>格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;加法</span><br><span class="line">ADC &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;带进位加法</span><br><span class="line">SUB &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;减法</span><br><span class="line">SBC &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;带借位减法</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD  R0，R1，R2           ; R0 = R1 + R2</span><br><span class="line">ADD  R0，R1，#256         ; R0 = R1 + 256</span><br><span class="line">ADD  R0，R2，R3，LSL#1     ; R0 = R2 + (R3 &lt;&lt; 1)</span><br><span class="line"></span><br><span class="line">ADC  R1,R1,#1			 ; R1 = R1 + 1 + C (其中C为CPSR寄存器中的进位) </span><br><span class="line"></span><br><span class="line">SUB  R0，R1，R2           ; R0 = R1 - R2</span><br><span class="line">SUB  R0，R1，#256         ; R0 = R1 - 256</span><br><span class="line">SUB  R0，R2，R3，LSL#1     ; R0 = R2 - (R3 &lt;&lt; 1)</span><br><span class="line"></span><br><span class="line">;BC指令用于把操作数1减去操作数2，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。</span><br><span class="line">SUBS  R0，R1，R2           ;R0 = R1 - R2 - ！C，并根据结果设置CPSR的进位标志位</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h5 id="2232-逻辑指令"><a class="markdownIt-Anchor" href="#2232-逻辑指令"></a> 2.2.3.2 逻辑指令</h5>
<blockquote>
<p>逻辑运算指令包括 (与、或、非、异或、清除等</p>
</blockquote>
<p><strong>格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;逻辑与运算(常用于屏蔽操作数1 中的某些位 )</span><br><span class="line">ORR &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;逻辑或运算(常用于设置操作数1的某些位。)</span><br><span class="line">EOR &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;异或运算(常用于反转操作数1的某些位。)</span><br><span class="line">BIC &#123;cond&#125; &#123;S&#125; Rd, Rn, operand2 ;位清除运算</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND  R0，R0，＃3           ; 该指令保持R0的0、1位，其余位清零。   ( R0 = R0 &amp; 0011 )</span><br><span class="line">ORR  R0，R0，＃3           ; 该指令设置R0的0、1位，其余位保持不变。( R0 = R0 | 0011)</span><br><span class="line">EOR  R0，R0，＃3           ; 该指令反转R0的0、1位，其余位保持不变。( R0 = R0 ^ 0011)</span><br><span class="line">BIC  R0，R0，＃％1011       ; 该指令清除 R0 中的位 0、1、和 3，其余的位保持不变。</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h4 id="224-比较指令"><a class="markdownIt-Anchor" href="#224-比较指令"></a> 2.2.4 比较指令</h4>
<h5 id="2241-cmp直接比较指令"><a class="markdownIt-Anchor" href="#2241-cmp直接比较指令"></a> 2.2.4.1 [<code>CMP</code>直接比较指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  CMP{条件} 操作数1，操作数2</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li><code>CMP</code>指令用于把一个寄存器的内容和另一个寄存器的内容或立即数进行比较 , 同时影响CPSR寄存器的N、Z、C、V标志位</li>
<li>该指令进行一次减法运算，但不存储结果，只更改条件标志位。标志位表示的是操作数1与操作数2的关系(大、小、相等)</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><mark>CPSR寄存器标志位:</mark></p>
<p><img src="https://pic.imgdb.cn/item/632ea0f016f2c2beb1c08fc1.png" alt="image-20220910142718682" /></p>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMP R1，R0     ;将寄存器R1的值与寄存器R0的值相减，并根据结果设置CPSR的标志位</span><br><span class="line">CMP R1，＃100  ;将寄存器R1的值与立即数100相减，并根据结果设置CPSR的标志位</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ul>
<li>
<p>比较指令的运行结果<strong>Z=1</strong>时,表示运算结果为零,<strong>两个数相等</strong>;</p>
</li>
<li>
<p><strong>N=1</strong>表示运算结果为负,</p>
</li>
<li>
<p><strong>N=0</strong>表示运算结果为非负,即运算结果为正或者为零。</p>
<br>
</li>
</ul>
<hr />
<h5 id="2242-cmn负数比较指令"><a class="markdownIt-Anchor" href="#2242-cmn负数比较指令"></a> 2.2.4.2 [<code>CMN</code>负数比较指令]</h5>
<blockquote>
<p><strong>格式:</strong>  CMN{条件} 操作数1，操作数2</p>
<p><strong>作用:</strong>  CMN指令用于把一个寄存器的内容和另一个寄存器的内容或立即数取反后进行比较，同时更新CPSR中条件标志位的值。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMN R0, #1			;将立即数取负,然后比较大小</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="225-跳转指令"><a class="markdownIt-Anchor" href="#225-跳转指令"></a> 2.2.5 跳转指令</h4>
<h5 id="2251-b-label-指令"><a class="markdownIt-Anchor" href="#2251-b-label-指令"></a> 2.2.5.1 [<code>B label</code> 指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  B {cond} Label</p>
<p><strong>作用:</strong></p>
<blockquote>
<ul>
<li>程序无条件跳转到标号Label处执行,</li>
<li>它是 24 位有符号数，左移两位后有符号扩展为 32 位. 表示跳转范围[0 , 32MB]</li>
<li>无条件跳转指令B主要用在循环 , 分支结构</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B  Label  	;程序无条件跳转到标号Label处执行</span><br><span class="line">CMP R1，＃0  ;当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行</span><br><span class="line">BEQ Label  </span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="2252-bl-带链接的跳转"><a class="markdownIt-Anchor" href="#2252-bl-带链接的跳转"></a> 2.2.5.2 [<code>BL</code> 带链接的跳转]</h5>
<blockquote>
<p><strong>格式 :</strong>  BL{条件} 目标地址</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>但跳转之前，会在寄存器<code>RL</code>(即<code>R14</code>)中保存PC的当前内容</li>
<li>BL指令一般用在函数调用的场合</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5> 示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BL Label  ;当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</span><br><span class="line">...		  ; 子程序返回后接着从此处继续执行</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="2253-bx-带状态切换的跳转"><a class="markdownIt-Anchor" href="#2253-bx-带状态切换的跳转"></a> 2.2.5.3 [<code>BX</code> 带状态切换的跳转]</h5>
<blockquote>
<p><strong>格式 :</strong>　BX{条件} 目标地址</p>
<p><strong>作用　:</strong> BX指令跳转到指令中所指定的目标地址，目标地址处的指令既可以是ARM指令，也可以是Thumb指令。</p>
</blockquote>
<br>
<hr />
<h5 id="2254-blx-指令"><a class="markdownIt-Anchor" href="#2254-blx-指令"></a> 2.2.5.4 [<code>BLX</code> 指令]</h5>
<blockquote>
<p><strong>格式 :</strong>  BX{条件} 目标地址</p>
<p><strong>作用:</strong>   BLX指令是BL指令和BX指令的综合 , 表示带链接和状态切换的跳转</p>
</blockquote>
<br>
<hr />
<h4 id="226-条件执行指令"><a class="markdownIt-Anchor" href="#226-条件执行指令"></a> 2.2.6 条件执行指令</h4>
<p>为了提高代码密度,减少ARM指令的数量,几乎所有的ARM指令都可以根据CPSR寄存器中的标志位,通过指令组合实现条件执行。</p>
<p><font face="华文彩云" color=red size=5> 如：</font></p>
<ul>
<li>无条件跳转指令B,我们可以在后面加上条件码组成BEQ、BNE组合指令。</li>
<li>BEQ指令表示两个数比较,结果相等时跳转;</li>
<li>BNE指令则表示结果不相等时跳转</li>
</ul>
<br>
<p><mark>ARM 指令的条件码:</mark></p>
<p><img src="https://pic.imgdb.cn/item/632ea12916f2c2beb1c0d5c3.png" alt="image-20220910151306942" /></p>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<blockquote>
<p>通过循环结构,我们可以实现数据块的搬运功能。我们可以将无条件跳转指令B和条件码NE组合在一起使用,构成一个循环程序结构。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA COPY,CODE,READOLY</span><br><span class="line">	ENTRY</span><br><span class="line">START</span><br><span class="line">	LDR R0,=SRC	; 源地址</span><br><span class="line">	LDR R1,=DST	; 目的地址</span><br><span class="line">	MOV R2,=#10	; 复制循环次数</span><br><span class="line">LOOP</span><br><span class="line">	LDR R3,[R0],#4 ;</span><br><span class="line">	STR R3,[R1],#4 ;</span><br><span class="line">	SUBS R2,R2,#4  ; </span><br><span class="line">	BNE LOOP	   ;</span><br><span class="line">	</span><br><span class="line">AREA COPYDATA, DATA, READWRITE</span><br><span class="line">SRC DCD 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">DST DCD 0,0,0,0,0,0,0,0,0,0</span><br><span class="line">	END	</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h3 id="23-伪指令"><a class="markdownIt-Anchor" href="#23-伪指令"></a> 2.3 伪指令</h3>
<p>伪指令有点类似C语言中的<strong>预处理命令</strong>,在程序编译时,这些伪指令会被<strong>翻译为一条或多条ARM标准指令</strong>。常见的ARM伪指令主要有4个: <code>ADR、ADRL、LDR、NOP,</code>它们的使用示例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADR RO, LOOP		;将标号LOOP的地址保存到R0寄存器中</span><br><span class="line">ADRL RO, LOOP		;中等范围的地址读取</span><br><span class="line">LDR R0, =9x30008000 ;将内存地址0x30008000赋值给R0(主要用途是将一个32位内存地址保存到寄存器中)</span><br><span class="line">NOP					;空操作,用于延时或插入流水线中暂停指令的运行(相当于&quot;MOV R0 R0&quot;)</span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5>备注：</font> 为什么要用<code>LDR</code> 伪指令将一个32位内存地址保存到寄存器中</p>
<ul>
<li>因为指令的长度一般都是固定的。在一个32位的系统中,一条指令通常是32位的,</li>
<li>指令中包括<strong>操作码</strong>和<strong>操作数</strong></li>
<li>指令中的操作码和操作数共享32位的存储空间;</li>
<li>一般前面的操作码要占据几个比特位,剩下来的留给操作数的编码空间就小于32位</li>
</ul>
<br>
<p><strong>ARM指令的编码格式:</strong></p>
<p><img src="https://pic.imgdb.cn/item/632ea14816f2c2beb1c0fb30.png" alt="image-20220910154956737" /></p>
<br>
<hr />
<h3 id="24-伪操作"><a class="markdownIt-Anchor" href="#24-伪操作"></a> 2.4 伪操作</h3>
<p>为了编程方便,汇编器也定义了一些特殊的指令<strong>助记符</strong>,以方便对汇编程序做各种处理。如使用<code>AREA</code>来定义一个段(section) ,使用<code>GBLA</code>来定义一个数据,使用<code>ENTRY</code>来指定汇编程序的执行入口等,这些指令助记符统称为<strong>伪操作</strong>。</p>
<br>
<p><mark>常用伪操作:</mark></p>
<p><img src="https://pic.imgdb.cn/item/632ea14f16f2c2beb1c1046a.png" alt="image-20220910160110433" /></p>
<br>
<hr />
<h4 id="241-area"><a class="markdownIt-Anchor" href="#241-area"></a> 2.4.1 [<code>AREA</code>]</h4>
<blockquote>
<p><strong>语法格式 :</strong>   [语法格式：AREA 段名 属性 1 ，属性 2 ，…  ]</p>
<p><strong>作用:</strong>    AREA 伪指令用于定义一个代码段或数据段。其中，段名若以数字开头，则该段名需用 “ | ” 括起来，如 |1_test| 。</p>
</blockquote>
<br>
<p>属性字段表示该代码段（或数据段）的相关属性，多个属性用逗号分隔。常用的属性如下：</p>
<ul>
<li><strong>CODE 属性</strong>：用于定义代码段，默认为 <code>READONLY</code> 。</li>
<li><strong>DATA 属性</strong>：用于定义数据段，默认为 <code>READWRITE</code> 。</li>
<li><strong>READONLY 属性</strong>：指定本段为<strong>只读</strong>，代码段默认为 <code>READONLY</code> 。</li>
<li><strong>READWRITE 属性</strong>：指定本段为<strong>可读可写</strong>，数据段的默认属性为 <code>READWRITE</code> 。</li>
<li><strong>ALIGN 属性</strong>：使用方式为<code>ALIGN</code> 表达式。在默认时，ELF（可执行连接文件）的代码段和数据段是按字对齐的，表达式的取值范围为 0 ～31，相应的对齐方式为2表达式次方。</li>
<li><strong>COMMON 属性</strong>：该属性定义一个通用的段，不包含任何的用户代码和数据。各源文件中同名的 COMMON 段共享同一段存储单元。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA Init ， CODE ， READONLY     ;该伪指令定义了一个代码段，段名为 Init ，属性为只读。 </span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="242-align"><a class="markdownIt-Anchor" href="#242-align"></a> 2.4.2 [<code>ALIGN</code>]</h4>
<blockquote>
<p><strong>语法格式:</strong>  [ALIGN { 表达式 { ，偏移量 }}   ]</p>
<p><strong>作用 :</strong>  地址对齐</p>
<blockquote>
<ul>
<li>ALIGN 伪指令可通过<strong>添加填充字节</strong>的方式，使当前位置满足一定的对齐方式。</li>
<li>其中，表达式的值用于指定对齐方式，可能的取值为<strong>2的幂</strong>，如 1 、2 、4 、8 、16 等。</li>
<li>若未指定表达式，则将当前位置对齐到<strong>下一个字</strong>的位置。</li>
<li>偏移量也为一个数字表达式，若使用该字段，则当前位置的对齐方式为：<strong>2的表达式次幂＋偏移量。</strong></li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5>使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA Init，CODE ，READONLY，ALIEN＝3	;指定后面的指令为 8 字节对齐。      </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">.... </span><br><span class="line">END      </span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="243-code16-code32"><a class="markdownIt-Anchor" href="#243-code16-code32"></a> 2.4.3 [<code>CODE16</code> /  <code>CODE32</code>]</h4>
<blockquote>
<p><strong>语法格式:</strong>  CODE16 （或 CODE32 ）</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>CODE16 伪指令通知编译器，其后的指令序列为 16 位的 Thumb 指令。</li>
<li>CODE32 伪指令通知编译器，其后的指令序列为 32 位的 ARM 指令。</li>
<li>在使用 ARM 指令和 Thumb 指令混合编程的代码里，可用这两条伪指令进行切换，但注意他们只通知编译器其后指令的类型，并不能对处理器进行状态的切换。</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5>使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA Init ，CODE ，READONLY            </span><br><span class="line">....      </span><br><span class="line">CODE32 				;通知编译器其后的指令为 32 位的 ARM 指令            </span><br><span class="line">LDR R0，＝NEXT＋1 	  ;将跳转地址放入寄存器 R0      </span><br><span class="line">BX R0 				;程序跳转到新的位置执行，并将处理器切换到 Thumb 工作状态      </span><br><span class="line">....     </span><br><span class="line">CODE16 				;通知编译器其后的指令为 16 位的 Thumb 指令            </span><br><span class="line">NEXT LDR R3，＝0x3FF            </span><br><span class="line">....     </span><br><span class="line">END 				;程序结束         </span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="244-entry"><a class="markdownIt-Anchor" href="#244-entry"></a> 2.4.4 [<code>ENTRY</code>]</h4>
<blockquote>
<p><strong>语法格式 :</strong>　　ENTRY</p>
<p><strong>作用</strong>:</p>
<blockquote>
<ul>
<li>ENTRY 伪指令用于指定汇编程序的入口点。</li>
<li>在一个完整的汇编程序中至少要有一个 ENTRY （也可以有多个)</li>
<li>当有多个 ENTRY 时，程序的真正入口点由链接器指定），但在一个源文件里最多只能有一个 ENTRY （可以没有）。</li>
</ul>
</blockquote>
</blockquote>
<p><font face="华文彩云" color=red size=5>使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA Init ， CODE ， READONLY            </span><br><span class="line">ENTRY 				;应用程序的入口点</span><br><span class="line">.....   </span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="245-end"><a class="markdownIt-Anchor" href="#245-end"></a> 2.4.5 [<code>END</code>]</h4>
<blockquote>
<p><strong>语法格式 :</strong>　　END</p>
<p><strong>作用</strong>:  END 伪指令用于通知编译器已经到了源程序的结尾。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5>使用示例：</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA Init ， CODE ， READONLY            </span><br><span class="line">......     </span><br><span class="line">END 			;指定应用程序的结尾</span><br></pre></td></tr></table></figure>
<br>
<br>
<hr />
<h2 id="3️⃣-作用域"><a class="markdownIt-Anchor" href="#3️⃣-作用域"></a> 3️⃣ 作用域</h2>
<br>
<h3 id="31-头文件的内容"><a class="markdownIt-Anchor" href="#31-头文件的内容"></a> 3.1 头文件的内容</h3>
<br>
<ul>
<li>函数原型</li>
<li>使用<code>#define</code>和<code>const</code>定义的符号常量</li>
<li>结构声明</li>
<li>类声明</li>
<li>模版声明</li>
<li>内联函数</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5> 注意：</font> 不要将函数定义和变量声明放在头文件中，容易导致重定义。 除非该函数是内联函数</p>
<br>
<hr />
<h3 id="32-inlcude-中-和-的区别"><a class="markdownIt-Anchor" href="#32-inlcude-中-和-的区别"></a> 3.2 <code>#inlcude</code>  中“ ” 和 &lt; &gt;的区别</h3>
<br>
<p><img src="https://pic.imgdb.cn/item/62f2829016f2c2beb19248e8.png" alt="image-20220802175044341" /></p>
<hr />
<br>
<h3 id="33-内存在程序中保留的时间"><a class="markdownIt-Anchor" href="#33-内存在程序中保留的时间"></a> 3.3 内存在程序中保留的时间</h3>
<br>
<ul>
<li><strong>自动储存</strong>：<strong>局部变量</strong>、<strong>函数参数</strong> 在程序开始执行其所属的函数和代码块时被创建， 在执行完函数和代码块时，内存被释放</li>
<li><strong>静态储存</strong>：<strong>全局变量</strong>、<code>staic</code>关键字定义的<strong>局部变量</strong>和<strong>全局变量</strong> 。在整个程序运行过程中都存在。</li>
<li><strong>动态存储</strong>： 用<code>new</code> 分配的内存会一直存在，直到使用<code>delete</code> 关键字将其释放。 也称为<strong>堆</strong></li>
</ul>
<br>
<hr />
<br>
<h3 id="34-作用域和链接"><a class="markdownIt-Anchor" href="#34-作用域和链接"></a> 3.4 作用域和链接</h3>
<br>
<ul>
<li><strong>作用域：</strong> 值在上面范围内能看到这个（<strong>函数/变量</strong> ），描述了名称在文件的多大范围内可见。</li>
<li><strong>链接性：</strong> 描述了名称在不同单元键的共享</li>
</ul>
<br>
<p><strong>局部变量作用域：</strong> 作用域只在定义它的代码块中</p>
<p><strong>全局变量作用域：</strong> 作用域为定义位置到文件结尾</p>
<p><strong>自动变量作用域：</strong>  作用域为局部</p>
<p><strong>函数体作用域：</strong>  整个类或整个名称空间，但不能是局部的</p>
<br>
<p><em>[<strong>例如：</strong></em>  局部变量和函数形参的 储存持续性为自动,作用域为局部； 没有链接性。 当程序开始执行时，为该变量分配内存，当函数结束时，这些变量会消失。]</p>
<br>
<br>
<br>
<p><font face="华文彩云" color=red size=5> 注意：</font></p>
<p><img src="https://pic.imgdb.cn/item/62f2822116f2c2beb18fd9b9.png" alt="image-20220803173542707" /></p>
<br>
<hr />
<h3 id="35-静态储存的链接性"><a class="markdownIt-Anchor" href="#35-静态储存的链接性"></a> 3.5 静态储存的链接性</h3>
<h4 id="351-静态变量的链接性"><a class="markdownIt-Anchor" href="#351-静态变量的链接性"></a> 3.5.1 静态变量的链接性：</h4>
<ul>
<li><strong>外部链接性:</strong> 可在其他文件中访问</li>
<li><strong>内部链接性：</strong> 只能在当前文件中访问</li>
<li><strong>无链接性：</strong>     只能在当前函数或代码块中访问</li>
</ul>
<p>静态变量的数量在程序运行期间是不变的， 编译器会分配固定的内存块来储存所有的静态变量，这些变量在程序</p>
<p>执行期间一直存在。</p>
<br>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;    <span class="comment">// 静态持续变量，连接性为外部</span></span><br><span class="line"></span><br><span class="line">staic <span class="type">int</span> b = <span class="number">0</span>; <span class="comment">// 静态持续变量，连接性为内部</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funct</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    staic <span class="type">int</span> c = <span class="number">0</span>;        <span class="comment">//静态变量，无链接性</span></span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;              <span class="comment">// 自动变量，无链接性</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<br>
<p>特别注意： 变量c是储存在静态数据区的，会在程序刚开始运行时就完成初始化，<strong>也是唯一的一次初始化</strong>。</p>
<p>即使<code>funct</code>函数没有被执行，c变量也是<strong>留在内存</strong>中的，而变量d则会<strong>消失。</strong></p>
<br>
<hr />
<h4 id="352-静态变量的初始化特性"><a class="markdownIt-Anchor" href="#352-静态变量的初始化特性"></a> 3.5.2  静态变量的初始化特性</h4>
<p>所有静态持续变量在初始化时都会被初始化为0 ，称为零初始化 。</p>
<p>在静态数据区，内存中所有的字节默认值都是 <code>0x00</code>，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 0，然后把不是 0 的几个元素赋值。如果定义成静态的，就省去了一开始置 0 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 <code>\0</code> 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 <code>\0</code> 。</p>
<br>
<hr />
<h3 id="36-变量储存方式总结"><a class="markdownIt-Anchor" href="#36-变量储存方式总结"></a> 3.6 变量储存方式总结</h3>
<p><img src="https://pic.imgdb.cn/item/62f2822616f2c2beb18ff55f.png" alt="image-20220803181043603" /></p>
<br>
<hr />
<h3 id="37-volatile-限定符"><a class="markdownIt-Anchor" href="#37-volatile-限定符"></a> 3.7 <code>volatile</code> 限定符</h3>
<p><img src="https://pic.imgdb.cn/item/62f2822a16f2c2beb1900f32.png" alt="image-20220803231002719" /></p>
<br>
<hr />
<br>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>arm</tag>
        <tag>单片机</tag>
        <tag>c语言</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>程序编译过程</title>
    <url>/2023/04/07/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="程序编译过程"><a class="markdownIt-Anchor" href="#程序编译过程"></a> 程序编译过程</h1>
<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.7.28」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em></p>
<br>
<p><strong>简介：</strong> 简单程序的编译过程</p>
</blockquote>
<br>
<span id="more"></span>
<hr />
<br>
<hr />
<h3 id="1️⃣-编译流程"><a class="markdownIt-Anchor" href="#1️⃣-编译流程"></a> 1️⃣ 编译流程</h3>
<p>程序的整个编译流程大致分成<strong>几个阶段</strong>:</p>
<ul>
<li><em><strong>预处理 :</strong></em>  将预处理指令进行处理 , 预处理器将<strong>源文件(.c)</strong> 经过预处理变成 <strong>文件(.i )</strong></li>
<li><em><strong>编译 :</strong></em>   编译器调用解析工具 , 将预处理后的<strong>源文件( .i )<strong>编译成</strong>汇编文件( .s)</strong></li>
<li><em><strong>汇编 :</strong></em>  这是也是编译的第二阶段 , 通过汇编器将<strong>汇编文件( .s)</strong> 汇编成可重定位的<strong>目标文件( .o)</strong></li>
<li><em><strong>链接 :</strong></em>  将各个<strong>目标文件( .o)<strong>链接成</strong>可执行文件</strong>( 也是可执行文件的一种 )</li>
</ul>
<br>
<p><em><strong>程序编译  , 链接流程图:</strong></em></p>
<p><img src="https://pic1.imgdb.cn/item/633aa48716f2c2beb1e98a0d.png" alt="image-20220928113639502" /></p>
<br>
<hr />
<h3 id="2️⃣-可执行文件"><a class="markdownIt-Anchor" href="#2️⃣-可执行文件"></a> 2️⃣ 可执行文件</h3>
<p>一个可执行文件通常由一系列不同的段<code>(section)</code>构成:<strong>代码段</strong>、<strong>数据段</strong>、<strong>BSS段</strong>、<strong>只读数据段</strong>等。</p>
<p><em><strong>C语言到可执行文件 :</strong></em></p>
<p><img src="https://pic1.imgdb.cn/item/633aa48716f2c2beb1e98a1c.png" alt="image-20220928114314496" /></p>
<ul>
<li><em><strong>函数</strong></em> 翻译成二进制指令放在 <em><strong>代码段</strong></em> 中</li>
<li><em><strong>初始化的全局变量</strong></em> 和 <em><strong>静态局部变量</strong></em> 放在 <em><strong>数据段</strong></em> 中(.data)</li>
<li><em><strong>未初始化的全局变量</strong></em> 和 <em><strong>静态变量</strong></em> 放在 <em><strong>BSS段</strong></em> 中(.bss)</li>
<li>程序中定义的一些<strong>字符串</strong> , <strong>printf函数打印的字符串常量</strong>放在 <strong>只读数据段( .rodata)</strong> 中</li>
</ul>
<br>
<hr />
<h3 id="3️⃣-预处理"><a class="markdownIt-Anchor" href="#3️⃣-预处理"></a> 3️⃣ 预处理</h3>
<blockquote>
<p><em><strong>预处理过程</strong></em> 就是 在编译源程序之前 , 先处理源文件中的各种<strong>预处理指令</strong></p>
</blockquote>
<br>
<p>预处理主要包括以下操作 :</p>
<ul>
<li><em><strong>头文件展开:</strong></em>  将<code>#include</code>包含的头文件内容展开到当前位置 , 并删除<code>#include</code></li>
<li><em><strong>宏展开:</strong></em> 展开所有的宏定义,并删除<code>#define</code>。</li>
<li><em><strong>条件编译:</strong></em>  根据宏定义条件,选择要参与编译的分支代码,其余的分支丢弃。</li>
<li><em><strong>删除注释</strong></em>。</li>
<li><em><strong>添加行号和文件名标识:</strong></em>   编译过程中根据需要可以显示这些信息。</li>
<li><em><strong>保留<code>#pragma</code>命令:</strong></em> 该命令会在程序编译时指示编译器执行一些特定行为。</li>
</ul>
<br>
<hr />
<h3 id="4️⃣-编译"><a class="markdownIt-Anchor" href="#4️⃣-编译"></a> 4️⃣ 编译</h3>
<p><em><strong>汇编过程主要包括以下步骤 :</strong></em></p>
<ul>
<li>
<p>词法分析</p>
</li>
<li>
<p>语法分析</p>
</li>
<li>
<p>语义分析</p>
</li>
<li>
<p>中间代码生成</p>
</li>
<li>
<p>汇编代码生成</p>
</li>
<li>
<p>目标代码生成</p>
<br>
</li>
</ul>
<hr />
<h4 id="41-词法分析"><a class="markdownIt-Anchor" href="#41-词法分析"></a> 4.1  词法分析</h4>
<blockquote>
<p>词法分析主要用来解析C程序语句 , 词法分析一般会通过词法扫描器从左到右 , 将源程序分解为一系列不能再分解的记号单元–token。</p>
</blockquote>
<br>
<p><em><strong>常见<code>token</code></strong></em></p>
<ul>
<li>C语言的各种 <em><strong>关键字</strong></em> : <code>int</code>,<code>float</code>、<code>for</code>,<code>while</code>、<code>break</code>等。</li>
<li>用户定义的各种 <em><strong>标识符</strong></em> :  <strong>函数名</strong>、<strong>变量名</strong>、<strong>标号</strong>等。</li>
<li>字面量: <strong>数字</strong>、<strong>字符串</strong>等。</li>
<li><em><strong>运算符</strong></em>: C语言标准定义的40多个运算符。</li>
<li><em><strong>分隔符</strong></em>: 程序结束符分号、for循环中的等</li>
</ul>
<p><font face="华文彩云" color=red size=5>示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sum = a + b / c;</span><br></pre></td></tr></table></figure>
<p><em><strong>如上所示:</strong></em></p>
<ul>
<li>经过词法分析后 分解成 <code>sum</code> ,<code>=</code>, <code>a</code> ,<code>+</code>, <code>b</code>, <code>/</code>, <code>c</code>,<code>;</code>  八个<code>token</code></li>
<li>如果程序出现<strong>中文符号</strong>、<strong>圆角\半角字符</strong> 等 ,程序就会在这个阶段发错编译错误</li>
</ul>
<br>
<hr />
<h4 id="42-语法分析"><a class="markdownIt-Anchor" href="#42-语法分析"></a> 4.2 语法分析</h4>
<blockquote>
<p>语法分析主要是对前一阶段产生的<code>token</code>序列进行解析,  看是否能构建成一个语法上正确的<strong>语法短语</strong>(程序、语句、表达式等)。</p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li>词法分析语法分析工具在对<code>token</code>序列分析过程中, 如果发现不能构建语法上正确的语句或表达式,就会报语法错误: <code>syntax error</code></li>
<li>如果程序语句后 少了 **结束分号 ** 或 <strong>循环中少了分号</strong> ，就会在此阶段产生编译错误</li>
</ul>
<br>
<hr />
<h4 id="43-语义分析"><a class="markdownIt-Anchor" href="#43-语义分析"></a> 4.3 语义分析</h4>
<blockquote>
<p>语义分析主要对语法分析输出的各种表达式、语句进行检查,看看有没有错误。</p>
</blockquote>
<br>
<p><em><strong>例如 :</strong></em></p>
<ul>
<li>传递给函数的实参与函数声明的形参类型不匹配,</li>
<li>使用了一个未声明的变量</li>
<li>除数为零了;</li>
<li><code>break</code>在循环语句或<code>switch</code>语句之外出现了,</li>
<li>在循环语句之外发现了<code>continue</code>语句等</li>
</ul>
<br>
<hr />
<h4 id="44-生成中间代码"><a class="markdownIt-Anchor" href="#44-生成中间代码"></a> 4.4 生成中间代码</h4>
<blockquote>
<p><em><strong>说明:</strong></em></p>
<ul>
<li>中间代码是一维线性结构 , 类似伪代码</li>
<li>通过中间代码 , 可以很容易的将中间代码翻译成汇编代码</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font ></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    sum = a + b / c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为中间代码 <em><strong>三地址码:</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> D<span class="number">.4227</span>;</span><br><span class="line">    <span class="type">int</span> D<span class="number">.4228</span>;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        a= <span class="number">2</span>;</span><br><span class="line">        b= <span class="number">1</span>;</span><br><span class="line">        C= <span class="number">1</span>;</span><br><span class="line">        D<span class="number">.4227</span> = b / c;</span><br><span class="line">        sum =D<span class="number">.4227</span> + a;</span><br><span class="line">        D<span class="number">.4228</span> = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">return</span> D<span class="number">.4228</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    D<span class="number">.4228</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> D<span class="number">.4228</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间代码转换为 <em><strong>汇编代码</strong></em> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0, #2		</span><br><span class="line">MOV R1, #1</span><br><span class="line">MOV R2, #1</span><br><span class="line">DIV R3, R1, R2		; R3 = R1 / R1</span><br><span class="line">ADD R0 RO.R3		; R0 = R0 + R3</span><br></pre></td></tr></table></figure>
<ul>
<li>将变量变量a、b、c分别放到寄存器R0、R1、R2中,</li>
<li>临时变量<code>D.4427</code>使用R3代替,然后使用<code>ADD</code>命令完成累加。</li>
</ul>
<br>
<hr />
<h4 id="45-汇编过程"><a class="markdownIt-Anchor" href="#45-汇编过程"></a> 4.5 汇编过程</h4>
<blockquote>
<ul>
<li>汇编器主要是 将汇编代码翻译成对应的二进制指令;</li>
<li>同时生成一些必要的信息 , 以section的形式组装到目标文件中</li>
</ul>
</blockquote>
<br>
<p><em><strong>汇编过程:</strong></em></p>
<p><img src="https://pic1.imgdb.cn/item/633aa48716f2c2beb1e98a26.png" alt="image-20220928233023855" /></p>
<br>
<hr />
<h3 id="5️⃣-链接过程"><a class="markdownIt-Anchor" href="#5️⃣-链接过程"></a> 5️⃣ 链接过程</h3>
<blockquote>
<ul>
<li>编译器在编译一个项目时,是以C源文件为单位进行编译的,每一个源文件编译生成一个对应的目标文件(.o)</li>
<li>但这些单独的<strong>目标文件(</strong>.o)是不可执行的 , 属于可重定位的目标文件;</li>
<li>它们要经过链接器 <em><strong>重定位</strong></em> 、<em><strong>链接</strong></em> 之后,才能组装成一个可执行的目标文件a.out。</li>
<li>链接器将各个目标文件组装在一起后, 重新 <strong>修改</strong> 各个目标文件中的变量或函数的 <strong>地址</strong> ,这个过程一般称为 <em><strong>重定位</strong></em> 。</li>
<li>链接过程中 , 将各个目标文件<strong>分段组装</strong> ; 例如 :  将各个目标文件的代码段放在一起,作为最终生成的可执行文件的代码段; 将各个目标文件的数据段放在一起,作为可执行文件的数据段。</li>
</ul>
</blockquote>
<br>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2023/04/07/test2/</url>
    <content><![CDATA[<h1 id="嵌入式c语言补充"><a class="markdownIt-Anchor" href="#嵌入式c语言补充"></a> 嵌入式C语言补充</h1>
<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.7.28」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em></p>
<p><strong>摘要：</strong></p>
<p><strong>简介：</strong></p>
</blockquote>
<br>
<hr />
<br>
<span id="more"></span>
<p>⭐️<font face="华文行楷" color=black size=7> 目录</font></p>
<p>[TOC]</p>
<br>
<hr />
<br>
<p><a href="https://blog.csdn.net/as480133937/article/details/100138838">链接</a></p>
<h4 id="221-基本公式"><a class="markdownIt-Anchor" href="#221-基本公式"></a> 2.2.1 <em><strong>基本公式:</strong></em></h4>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>V</mi><mi>α</mi></msub><mo>=</mo><mtext> </mtext><msub><mi>V</mi><mi>d</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><msub><mi>V</mi><mi>q</mi></msub><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>V</mi><mi>β</mi></msub><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mi>V</mi><mi>d</mi></msub><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><msub><mi>V</mi><mi>q</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
V_\alpha =\ V_d\cdot\cos{\theta}\ -\ V_q\cdot\sin{\theta}  \\\\
V_\beta\ =\ V_d\cdot\sin{\theta}\ +\ V_q\cdot\cos{\theta} \\\\
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000003em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.89999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05278em;">β</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>V</mi><mi>α</mi></msub><mo>=</mo><mtext> </mtext><msub><mi>V</mi><mi>d</mi></msub><mo>⋅</mo><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><msub><mi>V</mi><mi>q</mi></msub><mo>⋅</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
V_\alpha =\ V_d\cdot\cos{\theta}\ -\ V_q\cdot\sin{\theta} \\\\

\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h4 id="551-数据传输"><a class="markdownIt-Anchor" href="#551-数据传输"></a> 5.5.1  数据传输</h4>
<blockquote>
<p>用于传输浮点数据</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">f_data</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在进行数据传输的时候会方便很多，比如<strong>串口传输</strong>只需要把这个数组 <code>byte[4]</code> 进行传输就可以了。</p>
]]></content>
  </entry>
</search>
