<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"right","width":300,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="IMX6ULL 学习笔记   version :    v1.0      「2023.4.27」 author：  Y.Z.T. 简介： 随记, 记录 I.MX6ULL 系列 SOC 的uboot 启动流程">
<meta property="og:type" content="article">
<meta property="og:title" content="IMX6ULL学习笔记(四) —— uboot 启动流程">
<meta property="og:url" content="http://example.com/2023/06/02/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/index.html">
<meta property="og:site_name" content="Y.Z.T">
<meta property="og:description" content="IMX6ULL 学习笔记   version :    v1.0      「2023.4.27」 author：  Y.Z.T. 简介： 随记, 记录 I.MX6ULL 系列 SOC 的uboot 启动流程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c632.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c653.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea12916f2c2beb1c0d5c3.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/648168bc1ddac507cc73f368.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c701.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c722.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c73b.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c76e.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c76e.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/648169661ddac507cc75fcc9.png">
<meta property="article:published_time" content="2023-06-02T14:47:33.000Z">
<meta property="article:modified_time" content="2023-06-08T05:43:48.659Z">
<meta property="article:author" content="yezhaotin">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="单片机">
<meta property="article:tag" content="c语言">
<meta property="article:tag" content="arm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/64789ca7f024cca17394c632.png">


<link rel="canonical" href="http://example.com/2023/06/02/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/06/02/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/","path":"2023/06/02/IMX6ULL学习笔记(四)/","title":"IMX6ULL学习笔记(四) —— uboot 启动流程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>IMX6ULL学习笔记(四) —— uboot 启动流程 | Y.Z.T</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>


</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Y.Z.T</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#imx6ull-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="nav-text"> IMX6ULL 学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#23-uboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text"> 2.3 Uboot启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#231-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC-u-bootlds"><span class="nav-text"> 2.3.1  链接脚本 u-boot.lds</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2311-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC"><span class="nav-text"> 2.3.1.1 链接脚本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2312-vectorss-%E5%85%A5%E5%8F%A3%E7%82%B9_start"><span class="nav-text"> 2.3.1.2  vectors.S  ( 入口点:_start )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2313-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6-u-bootmap"><span class="nav-text"> 2.3.1.3  映射文件 u-boot.map</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#232-u-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text"> 2.3.2  U-boot启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2320-%E8%A1%A5%E5%85%85%E4%BF%A1%E6%81%AF"><span class="nav-text"> 2.3.2.0 补充信息</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#23201-entry-%E5%92%8C-endproc-%E5%AE%8F"><span class="nav-text"> 2.3.2.0.1 ENTRY() 和 ENDPROC() 宏</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23202-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9svc-%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 2.3.2.0.2  为什么选择SVC 模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23203-%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="nav-text"> 2.3.2.0.3 条件执行指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23204-cp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text"> 2.3.2.0.4  CP15协处理器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2321-%E9%98%B6%E6%AE%B51-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%96%E8%AE%BE%E7%A1%AC%E4%BB%B6"><span class="nav-text"> 2.3.2.1  阶段1 : 初始化外设硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#23211-uboot%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E7%82%B9-__start"><span class="nav-text"> 2.3.2.1.1  uboot程序入口点 __start</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23212-save_boot_params_ret%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.2 save_boot_params_ret函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23213-lowlevel_init%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.3 lowlevel_init函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23214-_main%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.4  _main函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23215-board_init_f-%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.5  board_init_f 函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23216-init_sequence_f-%E6%95%B0%E7%BB%84"><span class="nav-text"> 2.3.2.1.6  init_sequence_f 数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23217-relocate_code-%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.7   relocate_code 函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23218-relocate_vectors-%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.8  relocate_vectors 函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23219-board_init_r%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.1.9  board_init_r函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2322-%E9%98%B6%E6%AE%B52-bootz%E5%90%AF%E5%8A%A8linux-%E5%86%85%E6%A0%B8"><span class="nav-text"> 2.3.2.2 阶段2 : bootz启动linux 内核</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#23221-images-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text"> 2.3.2.2.1 images 全局变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23222-bootz-%E5%91%BD%E4%BB%A4"><span class="nav-text"> 2.3.2.2.2  bootz 命令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23223-do_bootm_linux-%E5%87%BD%E6%95%B0"><span class="nav-text"> 2.3.2.2.3  do_bootm_linux 函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#23224-%E8%A1%A5%E5%85%85"><span class="nav-text"> 2.3.2.2.4 补充</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yezhaotin"
      src="/images/photo.jpg">
  <p class="site-author-name" itemprop="name">yezhaotin</p>
  <div class="site-description" itemprop="description">呜呜呜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ye2020" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ye2020" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yezhaotin@outlook.com" title="E-Mail → mailto:yezhaotin@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/02/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo.jpg">
      <meta itemprop="name" content="yezhaotin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Y.Z.T">
      <meta itemprop="description" content="呜呜呜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="IMX6ULL学习笔记(四) —— uboot 启动流程 | Y.Z.T">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IMX6ULL学习笔记(四) —— uboot 启动流程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-02 22:47:33" itemprop="dateCreated datePublished" datetime="2023-06-02T22:47:33+08:00">2023-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-06-08 13:43:48" itemprop="dateModified" datetime="2023-06-08T13:43:48+08:00">2023-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="imx6ull-学习笔记"><a class="markdownIt-Anchor" href="#imx6ull-学习笔记"></a> IMX6ULL 学习笔记</h1>
<br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2023.4.27」</em></p>
<p><strong>author：</strong>  <em>Y.Z.T.</em></p>
<p><strong>简介：</strong> 随记, 记录 I.MX6ULL 系列 SOC 的uboot 启动流程</p>
</blockquote>
<span id="more"></span>
<br>
<hr />
<h3 id="23-uboot启动流程"><a class="markdownIt-Anchor" href="#23-uboot启动流程"></a> 2.3 Uboot启动流程</h3>
<h4 id="231-链接脚本-u-bootlds"><a class="markdownIt-Anchor" href="#231-链接脚本-u-bootlds"></a> 2.3.1  链接脚本 u-boot.lds</h4>
<h5 id="2311-链接脚本"><a class="markdownIt-Anchor" href="#2311-链接脚本"></a> 2.3.1.1 链接脚本</h5>
<blockquote>
<p>通过链接脚本可以找到程序的入口地址 , <code>uboot</code>的最终链接脚本是 <code>u-boot.lds</code> , 是通过编译<code>boot</code>生成的</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = <span class="number">0x00000000</span><span class="comment">;</span></span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .text</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/<span class="meta">cpu</span>/armv7/start<span class="number">.</span>o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .rodata</span> : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .data</span> : &#123;</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"> . = .<span class="comment">;</span></span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .u_boot_list</span> : &#123;</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)))<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .image_copy_end</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .rel_dyn_start</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .rel</span><span class="number">.</span>dyn : &#123;</span><br><span class="line">  *(.rel*)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .rel_dyn_end</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .end</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__end)</span><br><span class="line"> &#125;</span><br><span class="line"> _image_binary_end = .<span class="comment">;</span></span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4096</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta"> .mmutable</span> : &#123;</span><br><span class="line">  *(.mmutable)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .bss_start</span> __rel_dyn_start (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_start))<span class="comment">;</span></span><br><span class="line">  __bss_base = .<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .bss</span> __bss_base (OVERLAY) : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">   __bss_limit = .<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .bss_end</span> __bss_limit (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_end))<span class="comment">;</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta"> .dynsym</span> _image_binary_end : &#123; *(.dynsym) &#125;</span><br><span class="line"><span class="meta"> .dynbss</span> : &#123; *(.dynbss) &#125;</span><br><span class="line"><span class="meta"> .dynstr</span> : &#123; *(.dynstr*) &#125;</span><br><span class="line"><span class="meta"> .dynamic</span> : &#123; *(.dynamic*) &#125;</span><br><span class="line"><span class="meta"> .plt</span> : &#123; *(.plt*) &#125;</span><br><span class="line"><span class="meta"> .interp</span> : &#123; *(.interp*) &#125;</span><br><span class="line"><span class="meta"> .gnu</span><span class="number">.</span>hash : &#123; *(.gnu<span class="number">.</span>hash) &#125;</span><br><span class="line"><span class="meta"> .gnu</span> : &#123; *(.gnu*) &#125;</span><br><span class="line"><span class="meta"> .ARM</span><span class="number">.</span>exidx : &#123; *(.ARM<span class="number">.</span>exidx*) &#125;</span><br><span class="line"><span class="meta"> .gnu</span><span class="number">.</span>linkonce<span class="number">.</span>armexidx : &#123; *(.gnu<span class="number">.</span>linkonce<span class="number">.</span>armexidx.*) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>其中 <code>ENTRY(_start)</code> 是整个函数的入口，<code>_start</code> 在 <code>arch/arm/lib/vectors.S</code> 中有定义</li>
<li>注意<code>.text</code> 代码段的内容
<ul>
<li><code>__image_copy_start</code> ( <code>uboot</code>拷贝的首地址 )</li>
<li><code>vectors</code> 段用于保存 <em><strong>中断向量表</strong></em></li>
<li><code>arch/arm/cpu/armv7/start.o (.text*)</code> 意思是将 <code>arch/arm/cpu/armv7/start.o</code> 编译出来的代码放到中断向量表后面</li>
<li><code>*(.text*)</code> 用于存放其他的代码段</li>
</ul>
</li>
</ul>
</blockquote>
<br>
<p><em><strong>与地址有关的变量</strong></em></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>数值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__image_copy_start</code></td>
<td><code>0x87800000</code></td>
<td><code>uboot</code> 拷贝的首地址</td>
</tr>
<tr>
<td><code>__image_copy_end</code></td>
<td><code>0x8785dd54</code></td>
<td><code>uboot</code> 拷贝的结束地址</td>
</tr>
<tr>
<td><code>__rel_dyn_start</code></td>
<td><code>0x8785dd54</code></td>
<td><code>.rel.dyn</code> 段起始地址</td>
</tr>
<tr>
<td><code>__rel_dyn_end</code></td>
<td><code>0x878668f4</code></td>
<td><code>.rel.dyn</code> 段结束地址</td>
</tr>
<tr>
<td><code>_image_binary_end</code></td>
<td><code>0x878668f4</code></td>
<td>镜像结束地址</td>
</tr>
<tr>
<td><code>__bss_start</code></td>
<td><code>0x8785dd54</code></td>
<td><code>.bss</code> 段起始地址</td>
</tr>
<tr>
<td><code>__bss_end</code></td>
<td><code>0x878a8e74</code></td>
<td><code>.bss</code> 段结束地址</td>
</tr>
</tbody>
</table>
<blockquote>
<p>除了<code>__image_copy_start</code> 的值 , 其他变量 每次编译的时候可能会变化，如果修改了 <code>uboot</code> 代码、修改了 <code>uboot</code> 配置、选用不同的优化等级等等都会影响到这些值。</p>
</blockquote>
<br>
<hr />
<h5 id="2312-vectorss-入口点_start"><a class="markdownIt-Anchor" href="#2312-vectorss-入口点_start"></a> 2.3.1.2  <code>vectors.S</code>  ( 入口点:<code>_start</code> )</h5>
<blockquote>
<ul>
<li>代码当前入口点：<code>_star</code> 存放在 文件   <code>arch/arm/lib/vectors.S</code></li>
</ul>
</blockquote>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c632.png" alt="image-20230511210751928" /></p>
<br>
<blockquote>
<ul>
<li>_start 后面就是中断向量表</li>
<li>由 <code>.section &quot;.vectors&quot;, &quot;ax&quot;</code> 可以知道 , 中断向量表这部分代码是存放在 <code>.vectors</code> 段里面</li>
</ul>
</blockquote>
<hr />
<h5 id="2313-映射文件-u-bootmap"><a class="markdownIt-Anchor" href="#2313-映射文件-u-bootmap"></a> 2.3.1.3  映射文件 u-boot.map</h5>
<blockquote>
<ul>
<li><code>u-boot.map</code> 是 <code>uboot</code> 的映射文件，可以从此文件看到某个文件或者函数链接到了哪个地址</li>
</ul>
</blockquote>
<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">段 .text 的地址设置为 0x87800000</span><br><span class="line">                0x0000000000000000                . = 0x0</span><br><span class="line">                0x0000000000000000                . = ALIGN (0x4)</span><br><span class="line"></span><br><span class="line">.text           0x0000000087800000    0x3cd64</span><br><span class="line"> *(.__image_copy_start)</span><br><span class="line"> .__image_copy_start</span><br><span class="line">                0x0000000087800000        0x0 arch/arm/lib/built-in.o</span><br><span class="line">                0x0000000087800000                __image_copy_start</span><br><span class="line"> *(.vectors)</span><br><span class="line"> .vectors       0x0000000087800000      0x300 arch/arm/lib/built-in.o</span><br><span class="line">                0x0000000087800000                _start</span><br><span class="line">                0x0000000087800020                _undefined_instruction</span><br><span class="line">                0x0000000087800024                _software_interruptp</span><br><span class="line">                0x0000000087800028                _prefetch_abort</span><br><span class="line">                0x000000008780002c                _data_abort</span><br><span class="line">                0x0000000087800030                _not_used</span><br><span class="line">                0x0000000087800034                _irq</span><br><span class="line">                0x0000000087800038                _fiq</span><br><span class="line">                0x0000000087800040                IRQ_STACK_START_IN</span><br><span class="line"> arch/arm/cpu/armv7/start.o(.text*)</span><br><span class="line"> .text          0x0000000087800300       0xb0 arch/arm/cpu/armv7/start.o</span><br><span class="line">                0x0000000087800300                reset</span><br><span class="line">                0x0000000087800304                save_boot_params_ret</span><br><span class="line">                0x0000000087800340                c_runtime_cpu_setup</span><br><span class="line">                0x0000000087800350                save_boot_params</span><br><span class="line">                0x0000000087800354                cpu_init_cp15</span><br><span class="line">                0x00000000878003a8                cpu_init_crit</span><br><span class="line"> *(.text*)</span><br><span class="line"> .text          0x00000000878003b0       0x24 arch/arm/cpu/armv7/built-in.o</span><br><span class="line">                0x00000000878003b0                lowlevel_init</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>可以看到 <code>.text</code> 的起始地址为 <code>0x87800000</code></li>
<li>镜像启动地址 (<code>.__image_copy_start</code>) 也是  <code>0x87800000</code></li>
<li><code>vectors</code>段 的起始地址也是  <code>0x87800000</code></li>
<li><code>vectors</code> 段 后面则是 <code>arch/arm/cpu/armv7/start.s</code> 和 其他代码段的内容</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="232-u-boot启动流程"><a class="markdownIt-Anchor" href="#232-u-boot启动流程"></a> 2.3.2  U-boot启动流程</h4>
<blockquote>
<p>Uboot 的启动流程可以大致分成两个阶段 :</p>
<ul>
<li>第一阶段多使用汇编 , 主要完成一些板级的硬件初始化 , 如外设硬件初始化 , 如 DRAM , 串口 , 重定位等。</li>
<li>第二阶段通常使用C语言来实现 , 方便实现更加复杂的功能 , 主要完成<code>linux</code> 内核 的启动</li>
</ul>
</blockquote>
<br>
<hr />
<h5 id="2320-补充信息"><a class="markdownIt-Anchor" href="#2320-补充信息"></a> 2.3.2.0 补充信息</h5>
<h6 id="23201-entry-和-endproc-宏"><a class="markdownIt-Anchor" href="#23201-entry-和-endproc-宏"></a> 2.3.2.0.1 ENTRY() 和 ENDPROC() 宏</h6>
<blockquote>
<p>使用<code>ENTRY</code>和<code>ENDPROC</code>两个宏来定义一个名为<code>name</code>的函数 , 这个伪指令实现了指定一个入口的同时数据对齐，同时提供了一个函数入口 :</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(name)</span><br><span class="line">...</span><br><span class="line">ENDPROC(name)</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p>这两个宏定义在<code>#include &lt;linux/linkage.h&gt;</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl  save_boot_params</span><br><span class="line">.align  4                       @4字节对齐</span><br><span class="line">save_boot_params:</span><br><span class="line">bx  lr							@ 带模式的返回</span><br><span class="line"></span><br><span class="line">.type save_boot_params STT_FUNC; @ 说明该标识是函数</span><br><span class="line">.size save_boot_params, .-save_boot_params  @ 计算整个函数的大小</span><br><span class="line"></span><br><span class="line">.weak   save_boot_params   @ 弱标号，如果别处有使用别处的定义，如果没有使用当前定义</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="23202-为什么选择svc-模式"><a class="markdownIt-Anchor" href="#23202-为什么选择svc-模式"></a> 2.3.2.0.2  <em><strong>为什么选择<code>SVC</code> 模式</strong></em></h6>
<blockquote>
<p>通过 设置<code>CPSR</code>寄存器 的<code>bit0 ~ bit4</code> 五位来设置 处理器的工作模式</p>
</blockquote>
<p><em><strong>如下表所示:</strong></em></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c653.png" alt="image-20230515173401632" /></p>
<p><em><strong>在uboot的启动流程中选择<code>SVC</code> 模式</strong></em></p>
<blockquote>
<ul>
<li>7种模式中，除用户<code>usr</code>模式外，其它模式均为 <em><strong>特权模式</strong></em></li>
</ul>
<br>
<ul>
<li>
<p>中止<code>ABT</code>和未定义<code>UND</code>模式</p>
<blockquote>
<ul>
<li>因为此时程序是正常运行的 , 所以不应该设置CPU为这两种模式的其中任何一种</li>
</ul>
</blockquote>
</li>
<li>
<p>快中断<code>FIQ</code>和中断<code>IRQ</code>模式</p>
<blockquote>
<ul>
<li>对于快中断<code>FIQ</code>和中断<code>IRQ</code>来说，此处<code>uboot</code>初始化的时候，中断已经被禁用</li>
<li>即使是注册了终端服务程序后，能够处理中断，那么这两种模式，也是自动切换过去的</li>
<li>所以，此处也不应该设置为这两种模式中的其中任何一种模式</li>
</ul>
</blockquote>
</li>
<li>
<p>用户USR模式</p>
<blockquote>
<ul>
<li>访问uboot初始化，就必须很多的硬件资源 , 而用户模式 <code>USR</code> 是 <em><strong>非特权模式</strong></em> 不能访问系统所有资源, 所以<code>CPU</code>也不能设置成<code>USR</code></li>
</ul>
</blockquote>
</li>
<li>
<p>系统<code>SYS</code>模式 和 管理<code>SVC</code>模式</p>
<blockquote>
<ul>
<li><code>SYS</code>模式和<code>USR</code>模式相比，所用的寄存器组，都是一样的，但是增加了一些访问一些在<code>USR</code>模式下不能访问的资源</li>
<li><code>SVC</code>模式本身就属于特权模式，本身就可以访问那些受控资源 ,  相比 <code>SYS</code> 多了 专属寄存器 <code>R13(sp)</code>、<code>R14（lr）</code> 以及 <em><strong>备份程序状态寄存器</strong></em> （<code>SPSR_svc</code>）</li>
<li>所以 ， 相对<code>SYS</code>模式来说，可以 <em><strong>访问资源的能力相同</strong></em>，但是拥有 <em><strong>更多的硬件资源</strong></em></li>
<li>因为在初始化 <code>uboot</code> 的过程中 ， 要做的事情是初始化系统相关硬件资源，需要 <em><strong>获取尽量多的权限</strong></em>，以方便操作硬件，初始化硬件 ， 所以最终选择 <code>SVC</code>模式</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<br>
<hr />
<h6 id="23203-条件执行指令"><a class="markdownIt-Anchor" href="#23203-条件执行指令"></a> 2.3.2.0.3 条件执行指令</h6>
<blockquote>
<p>为了提高代码密度,减少ARM指令的数量,几乎所有的ARM指令都可以根据CPSR寄存器中的标志位,通过指令组合实现条件执行。</p>
</blockquote>
<p><font face="华文彩云" color=red size=5> 如：</font></p>
<ul>
<li>无条件跳转指令<code>B</code>,我们可以在后面加上条件码组成<code>BEQ</code>、<code>BNE</code>组合指令。</li>
<li><code>BEQ</code>指令表示两个数比较,结果相等时跳转;</li>
<li><code>BNE</code>指令则表示结果不相等时跳转</li>
<li><code>bicne</code> 指令表示 标志位<code>Z= 0</code> 的时候 , 执行清零指令 <code>bic</code></li>
</ul>
<br>
<p><em><strong>ARM指令的条件码</strong></em></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea12916f2c2beb1c0d5c3.png" alt="image-20220910151306942" /></p>
<br>
<p><em><strong>BL跳转指令</strong></em></p>
<blockquote>
<p><strong>格式 :</strong>  BL{条件} 目标地址</p>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>但跳转之前，会在寄存器<code>RL</code>(即<code>R14</code>)中保存PC的当前内容</li>
<li>BL指令一般用在函数调用的场合</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><em><strong>例</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BL Label  ;当程序无条件跳转到标号Label处执行时，同时将当前的PC值保存到R14中</span><br><span class="line">...		  ; 子程序返回后接着从此处继续执行</span><br></pre></td></tr></table></figure>
<hr />
<h6 id="23204-cp15协处理器"><a class="markdownIt-Anchor" href="#23204-cp15协处理器"></a> 2.3.2.0.4  CP15协处理器</h6>
<blockquote>
<p><code>CP15</code> 协处理器一般用于存储系统管理，但是在中断中也会使用到，<code>CP15</code> 协处理器一共有</p>
<p>16 个 32 位寄存器 <code>( c0~c15 )</code>。<code>CP15</code> 协处理器的访问通过如下另个指令完成：</p>
<ul>
<li>
<p><strong>MRC:</strong> 将 <code>CP15</code> 协处理器中的寄存器数据读到 <code>ARM</code> 寄存器中</p>
</li>
<li>
<p><strong>MCR:</strong> 将 <code>ARM</code> 寄存器的数据写入到 <code>CP15</code> 协处理器寄存器中</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">MCR</span><span class="template-variable">&#123;cond&#125;</span><span class="language-xml"> p15, <span class="tag">&lt;<span class="name">opc1</span>&gt;</span>, <span class="tag">&lt;<span class="name">Rt</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRn</span>&gt;</span>, <span class="tag">&lt;<span class="name">CRm</span>&gt;</span>, <span class="tag">&lt;<span class="name">opc2</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>cond:</strong> 指令执行的条件码，如果忽略的话就表示无条件执行</li>
<li><strong>opc1</strong>：协处理器要执行的操作码</li>
<li><strong>Rt</strong>： <code>ARM</code> 源寄存器，要写入到 <code>CP15</code> 寄存器的数据就保存在此寄存器中</li>
<li><strong>CRn</strong>： <code>CP15</code> 协处理器的目标寄存器</li>
<li><strong>CRm</strong>:  协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将<code>CRm</code> 设置为 <code>C0</code>，否则结果不可预测</li>
<li><strong>opc2</strong>：可选的协处理器特定操作码，当不需要的时候要设置为 0</li>
</ul>
</li>
</ul>
</blockquote>
<br>
<p><em><strong>例:</strong></em>  将 <code>CP15</code> 中 <code>C0</code> 寄存器的值读取到 <code>R0</code> 寄存器中，</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MRC</span> <span class="built_in">p15</span>, <span class="number">0</span>, <span class="built_in">r0</span>, <span class="built_in">c0</span>, <span class="built_in">c0</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure>
<br>
<p><em><strong>其中四个寄存器</strong></em></p>
<ul>
<li>通过 <code>c0</code> 寄存器可以获取到处理器内核信息</li>
<li>通过 <code>c1</code> 寄存器可以使能或禁止 MMU、I/D Cache 等；</li>
<li>通过 <code>c12</code> 寄存器可以设置中断向量偏移 ( 如设置中断向量表偏移的时候就需要将新的中断向量表基地址写入 <code>VBAR</code> 中 )</li>
<li>通过 <code>c15</code> 寄存器可以获取 <code>GIC (中断控制器)</code>  基地址</li>
</ul>
<br>
<p><em><strong>例 :</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 设置中断向量表:</span><br><span class="line"> * (OMAP4 spl TEXT_BASE is not 32 byte aligned.</span><br><span class="line"> * Continue to use ROM code vector only in OMAP4 spl)</span><br><span class="line"> */</span><br><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line"></span><br><span class="line">	/* 在CP15 SCTLR寄存器中设置V=0，并 用 VBAR 重新定位向量表 */</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0	@  将CP15协处理器的 C1寄存器值读到r0寄存器</span><br><span class="line">	bic	r0, #CR_V				@  将SCTLR寄存器的bit13位V 清零 , (即此时向量表基地址为 0X00000000，软件可以重定位向量表)</span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0	@   将CP15协处理器的 C1寄存器值写到r0寄存器</span><br><span class="line"></span><br><span class="line">	/* 在CP15 VBAR寄存器中设置向量地址 */</span><br><span class="line">	ldr	r0, =_start</span><br><span class="line">	mcr	p15, 0, r0, c12, c0, 0	@重定位向量表 将VBAR寄存器值设置为 _start , 即整个uboot 的入口地址</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="2321-阶段1-初始化外设硬件"><a class="markdownIt-Anchor" href="#2321-阶段1-初始化外设硬件"></a> 2.3.2.1  阶段1 : 初始化外设硬件</h5>
<h6 id="23211-uboot程序入口点-__start"><a class="markdownIt-Anchor" href="#23211-uboot程序入口点-__start"></a> 2.3.2.1.1  uboot程序入口点 __start</h6>
<blockquote>
<p><em><strong>位置:</strong></em>  <code>arch/arm/lib/vectors.S</code></p>
<p>上电启动后，代码执行到 <code>_start</code> 函数，调用 <code>reset</code> 函数</p>
<p><code>reset</code> 的函数目的是将处理器设置为<code>SVC</code>模式，并且关闭<code>FIQ</code>和<code>IRQ</code>，然后设置中断向量以及初始化 <code>CP15</code> 协处理器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">	.word	CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	b	reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>下面的 <code>8~14 行</code> 就是是 <em><strong>中断向量表</strong></em></p>
</li>
<li>
<p>可以看到 直接跳到<code>reset</code> 函数 (<code>reset</code> 函数直接跳转到<code>save_boot_params</code> 函数)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">	/* Allow the board to save important registers */</span><br><span class="line">	b	save_boot_params</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>save_boot_params</code> 也同样是直接跳转到 <code>save_boot_params_ret</code> 函数</p>
</li>
</ul>
<br>
<hr />
<h6 id="23212-save_boot_params_ret函数"><a class="markdownIt-Anchor" href="#23212-save_boot_params_ret函数"></a> 2.3.2.1.2 save_boot_params_ret函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em> <code>arch/arm/lib/vectors.S</code></p>
</blockquote>
<br>
<blockquote>
<p><code>save_boot_params_ret</code> 函数主要完成以下功能:</p>
<ul>
<li>当前处理器模式不为 <code>HYP</code>模式时 , 将处理器模式设置为 <code>SVC</code>模式 ,并禁用<code>IRQ</code> 和 <code>FIQ</code>两个中断</li>
<li>重定位 <em><strong>中断向量表</strong></em> ,将其定位到<code>uboot</code> 的起始地址 ( 这里取<code>0x8780 0000</code>)</li>
<li>调用<code>cpu_init_cp15</code> 函数 , 设置其他和<code>CP15</code>有关的设置<code>(cache, MMU, tlb)</code> , 打开<code>I-cache</code></li>
<li>调用 <code>cpu_init_crit</code> 函数 , 并最终生成一个属于 <code>IMX6ULL</code> 内部<code>RAM</code>的临时堆栈</li>
<li>调用 <code>_main</code>函数 ,</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">save_boot_params_ret:</span><br><span class="line">	/*</span><br><span class="line">	 * 当前系统不处于 HYP 模式时</span><br><span class="line">	 * 禁用中断(FIQ和IRQ)，也将cpu设置为SVC (管理)模式</span><br><span class="line">	 */</span><br><span class="line">	mrs	r0, cpsr			@ 读cpsr的值 , 并保存到 r0寄存器中</span><br><span class="line">	and	r1, r0, #0x1f		@ 使用位与操作 , 提取 CPSR寄存器的 bit0 ~ bit4 四位, 即用于设置 处理器工作模式的四位 </span><br><span class="line">	teq	r1, #0x1a			@ 检查当前是否是 HYP模式 , 使用teq将 r1 与 0x1a进行异或运算 ,并将结果更新 CPSR标志位 </span><br><span class="line">	bicne	r0, r0, #0x1f		@ 当 CPSR寄存器的标志位Z != 1 (即之前运算结果不为0 , 即不处于HYP模式),清除r0的低5位</span><br><span class="line">	orrne	r0, r0, #0x13		@ 设置处理器模式为 SVC模式</span><br><span class="line">	orr	r0, r0, #0xc0		@ 禁用 FIQ 和 IRQ (SPCR寄存器的 I为和F位 控制IRQ和FIQ,设置为1则禁用)</span><br><span class="line">	msr	cpsr,r0				@ 将寄存器的值写回CPSR</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 设置中断向量表</span><br><span class="line"> * c1寄存器 的bit13位是 &#x27;V&#x27; (向量表控制位), </span><br><span class="line"> * 为0时,向量表基地址为0x00000000(可重定位),</span><br><span class="line"> * 为1时,向量表基地址为0xFFFF0000(不可重定位)</span><br><span class="line"> */</span><br><span class="line">#if !(defined(CONFIG_OMAP44XX) &amp;&amp; defined(CONFIG_SPL_BUILD))</span><br><span class="line">	mrc	p15, 0, r0, c1, c0, 0		@ 读取CP15协处理器的c1寄存器,即SCTLR</span><br><span class="line">	bic	r0, #CR_V					@ CR_V = (1 &lt;&lt; 13) 所以是清除c1寄存器 的bit13位(V) </span><br><span class="line">	mcr	p15, 0, r0, c1, c0, 0		@ 写SCTLR</span><br><span class="line"></span><br><span class="line">	/* 在CP15协处理器的 VBAR寄存器(C12)中 设置向量表的重定位地址 , */</span><br><span class="line">	ldr	r0, =_start				@ 设置向量表的重定位地址 , 即整个uboot起始地址 (0x8780 0000)</span><br><span class="line">	mcr	p15, 0, r0, c12, c0, 0	@ 将r0的值写入 VBAR</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	/* the mask ROM code should have PLL and others stable */</span><br><span class="line">#ifndef CONFIG_SKIP_LOWLEVEL_INIT	</span><br><span class="line">	bl	cpu_init_cp15		@ 调用cpu_init_cp15函数, 用来设置和CP15有关的设置(cache, MMU, tlb),打开I-cache</span><br><span class="line">	bl	cpu_init_crit		@ 调用cpu_init_crit函数 , 再调用lowlevel_init函数	</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	bl	_main				@ 调用_main函数, </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在第33行 , 调用<code>cpu_init_crit</code> , 这个函数内部仅仅调用了<code>lowlevel_init</code>函数</li>
<li><code>lowlevel_init</code> 用于创建一个<code>IMX6ULL</code>内部的 <em><strong>临时堆栈</strong></em></li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>🅰️  <code>SCTLR</code>寄存器 ( <code>CP15</code>的<code>c1</code>寄存器)</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/648168bc1ddac507cc73f368.png" alt="20211223110110" /></p>
<br>
<p>🅱️ <code>save_boot_params_ret</code>   <em><strong>函数调用路径</strong></em></p>
<br>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c701.png" alt="image-20230515204430974" /></p>
<br>
<hr />
<h6 id="23213-lowlevel_init函数"><a class="markdownIt-Anchor" href="#23213-lowlevel_init函数"></a> 2.3.2.1.3 lowlevel_init函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em> <code>arch/arm/cpu/armv7/lowlevel_init.S</code></p>
<br>
<p><code>lowlev el_init</code> 函数主要完成如下功能</p>
<ul>
<li>初始化一个临时堆栈 , 这个堆栈属于 <code>IMX6ULL</code>的内部 <code>RAM</code></li>
<li>设置<code>r9</code>寄存器 , 用于保存 <code>GD</code>结构体的基地址</li>
<li>这个临时堆栈 , 保留了 <code>Global data</code> 和 <code>GBL_DATA</code> 的地址位置</li>
<li>调用早期初始化函数 <code>s_init</code> , 但对于<code>IMX6ULL</code>来说相当于 <em><strong>空函数</strong></em></li>
</ul>
</blockquote>
<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(lowlevel_init)</span><br><span class="line"></span><br><span class="line">/* 设置一个临时堆栈,  暂时还没有Global data(全局数据GD) , 但留出GD的大小*/</span><br><span class="line">	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR  	@ 将sp指针指向 系统初始化指针地址(0X0091FF00) ,定义如后文</span><br><span class="line">	bic	sp, sp, #7 						@ 对sp指针进行8字节对齐 ,对齐原理如后文所示</span><br><span class="line">		</span><br><span class="line">#ifdef CONFIG_SPL_DM</span><br><span class="line">	mov	r9, #0				@条件编译不成立 , 未使用</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">/* 预留出全局数据(GD)的大小 */</span><br><span class="line">#ifdef CONFIG_SPL_BUILD</span><br><span class="line">	ldr	r9, =gdata</span><br><span class="line">#else</span><br><span class="line">	sub	sp, sp, #GD_SIZE		@ 将sp指针减去 GD的大小(GD_SIZE = 248)</span><br><span class="line">	bic	sp, sp, #7				@ 将指针进行8字节对齐 (此时SP =  0X0091FF00-248=0X0091FE08)</span><br><span class="line">	mov	r9, sp					@ 将SP指针地址保存在 r9寄存器, 此时r9保存着 dg 结构体的基地址</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* 将旧的lr(通过ip传递)和当前的lr保存到堆栈中 */</span><br><span class="line">	push	&#123;ip, lr&#125;			@ 将ip和lr压栈</span><br><span class="line"></span><br><span class="line">	/* s_init:</span><br><span class="line">	 * 调用最早期的init函数。这应该只做最基本的初始化,它不应该做以下的事情:</span><br><span class="line">	 * </span><br><span class="line">	 * - 设置DRAM</span><br><span class="line">	 * - 使用全局数据(global_data)</span><br><span class="line">	 * - 清除BSS段</span><br><span class="line">	 * - 尝试启动控制台</span><br><span class="line">	 */	 </span><br><span class="line">	bl	s_init					@ 调用s_init , 对于 IMX6ULL来说是空函数</span><br><span class="line">	pop	&#123;ip, pc&#125;				@ 将lr出栈并赋给pc,将ip出栈赋给ip</span><br><span class="line">ENDPROC(lowlevel_init)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>🅰️  宏<code>CONFIG_SYS_INIT_SP_OFFSET</code>和 宏 <code>CONFIG_SYS_INIT_SP_ADDR</code> 计算:</p>
<blockquote>
<p>这两个宏定义如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define CONFIG_SYS_INIT_RAM_ADDR     IRAM_BASE_ADDR       (这里是RAM基地址, 取0x00900000)</span><br><span class="line">#define CONFIG_SYS_INIT_RAM_SIZE     IRAM_SIZE			  (这里是RAM的大小, 取0X20000 = 128KB)</span><br><span class="line"></span><br><span class="line">#define CONFIG_SYS_INIT_SP_OFFSET \			 			  (值取 0x1FF00)</span><br><span class="line">(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)	(GENERATED_GBL_DATA_SIZE = 256)</span><br><span class="line">#define CONFIG_SYS_INIT_SP_ADDR \						  (值取 0X0091FF00)</span><br><span class="line">(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>IRAM_BASE_ADDR</code> 和  <code>IRAM_SIZE</code> 两个宏都定义在 <code>arch/arm/include/asm/arch-mx6/imx-regs.h</code></p>
</li>
<li>
<p><code>GENERATED_GBL_DATA_SIZE</code> 宏定义在 <code>include/generated/generic-asm-offsets.h</code></p>
</li>
<li>
<p><code>GENERATED_GBL_DATA_SIZE</code> 的含义为  <code>(sizeof(struct global_data) + 15) &amp; ~15</code></p>
</li>
<li>
<p>则可以得到如下值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_INIT_RAM_ADDR = IRAM_BASE_ADDR = 0x00900000</span><br><span class="line">CONFIG_SYS_INIT_RAM_SIZE = 0x00020000 =128KB</span><br><span class="line">GENERATED_GBL_DATA_SIZE  = 256</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算可得:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_INIT_SP_OFFSET = 0x00020000 – 256 = 0x1FF00。</span><br><span class="line">CONFIG_SYS_INIT_SP_ADDR = 0x00900000 + 0X1FF00 = 0X0091FF00，</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<br>
<p>🅱️ <em><strong>sp指针8位对齐</strong></em></p>
<blockquote>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bic sp, sp, #7     @ sp指针8位对齐</span><br></pre></td></tr></table></figure>
<ul>
<li>实现 <em><strong>8位对齐</strong></em> 的原理就是将最低三位清零因为 <code>#7</code> 对应 <code>（0111）</code>，清除后就可以被 <code>8 （1000）</code>整除</li>
<li>不过前提是栈地址要 <em><strong>向下生长</strong></em> <code>( FD | ED)</code>，这样被清除的地址不会与数据冲突</li>
</ul>
</blockquote>
<br>
<p>🆎  <em><strong>此时的堆栈内存情况</strong></em></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c722.png" alt="image-20230515221338851" /></p>
<br>
<p>🔤  <code>s_init</code> 函数</p>
<blockquote>
<p><em><strong>位置:</strong></em>  <code>arch/arm/cpu/armv7/mx6/soc.c</code></p>
<ul>
<li>
<p>在<code>s_init</code>函数里面 , 代码会判断<code>CPU</code>类型</p>
</li>
<li>
<p>如果 CPU 为 MX6SX、MX6UL、MX6ULL 或 MX6SLL 中的任意 一 种 ， 那么就会直接返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||</span><br><span class="line">    is_cpu_type(MXC_CPU_MX6ULL) || is_cpu_type(MXC_CPU_MX6SLL))</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以对 <code>I.MX6UL/I.MX6ULL</code> 来说，<code>s_init</code> 就是个空函数</p>
</li>
</ul>
</blockquote>
<hr />
<h6 id="23214-_main函数"><a class="markdownIt-Anchor" href="#23214-_main函数"></a> 2.3.2.1.4  _main函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em> <code>arch/arm/lib/crt0.S</code></p>
<p><code>_main</code> 函数主要完成以下功能</p>
<ul>
<li>初始化C语言运行环境、堆栈设置</li>
<li>各种板级设备初始化、初始化<code>NAND Flash</code>、<code>SDRAM</code></li>
<li>初始化全局结构体变量<code>GD</code>，在<code>GD</code>里有<code>U-boot</code>实际加载地址</li>
<li>调用<code>relocate_code</code>，将<code>U-boot</code>镜像从<code>Flash</code>复制到<code>RAM</code></li>
<li>从<code>Flash</code>跳到内存<code>RAM</code>中继续执行程序</li>
<li><code>BSS</code>段清零，跳入<code>bootcmd</code>或<code>main_loop</code>交互模式</li>
</ul>
<p><code>_main</code> <em><strong>执行顺序</strong></em> :</p>
<ul>
<li>
<p>设置 可以调用<code>board_init_f()</code> 的初始C运行环境</p>
<blockquote>
<ul>
<li>这个运行环境只提供 <em><strong>一个堆栈</strong></em> 和一个用来存储<code>GD</code> (<code>global data</code>) 结构体的 <em><strong>位置</strong></em></li>
<li>堆栈和储存位置都位于 <code>RAM</code>中( 如<code>SRAM</code> ,  锁定缓存等)中 ,   在这种情况下, 变量 <code>GD</code> 无论是否初始化(BSS段) 都不能使用</li>
<li>只有 常量初始化的数据才能可用 , <code>GD</code> 在被 <code>board_init_f()</code> 调用前 ,应该先被清零 ( 调用<code>board_init_f_init_reserve</code> 函数 清零<code>GD</code>)</li>
</ul>
</blockquote>
</li>
<li>
<p>调用<code>board_init_f()</code> 函数</p>
<blockquote>
<ul>
<li>这个函数 从系统 <em><strong>外部</strong></em> <code>RAM</code> (如<code>DRAM</code>, <code>DDR</code>  …) 执行硬件准备 , 初始化一系列外设，比如串口、定时器，或者打印一些消息等</li>
<li>因为此时 , 系统<code>RAM</code>还不可用 ,  <code>board_init_f()</code> 函数必须 使用当前的<code>GD</code> 变量来储存必须传递到后续阶段的 任何数据 , 所以 初始化 <code>gd</code> 的各个成员变量</li>
<li>这些数据包括 : 重定位的 <em><strong>目的地址</strong></em> 、<em><strong>未来的堆栈</strong></em> 和 <em><strong>未来的GD的内存位置</strong></em>  , 在<code>DRAM</code>最后部分预留各数据的内存空间 (如 <code>uboot</code>、<code>malloc</code>、<code>gd</code>、<code>bd</code>等) , 最终一个完整的内存 <em><strong>分配图</strong></em> , 在后面重定位 <code>uboot</code>时 使用</li>
</ul>
</blockquote>
</li>
<li>
<p>设置中间环境 ， 在DRAM的最后预留 各数据的内存空间 ，方便后面重定位</p>
<blockquote>
<ul>
<li>其中 <em><strong>堆栈</strong></em> 和 <strong><code>GD</code></strong> 是由<code>board_init_f()</code>在系统<code>RAM (DRAM)</code> 中分配的 ,</li>
<li>但是<code>BSS</code>段和已初始化的 非<code>const</code>数据仍不可用</li>
</ul>
</blockquote>
</li>
<li>
<p>调用 <code>relocate_code</code> 函数对uboot 进行真正的数据拷贝 和重定位 (不是 SPL)</p>
<blockquote>
<ul>
<li>这个函数将<code>U-Boo</code>t从当前位置 (<em><strong>片上RAM)</strong></em> 重新定位到由<code>board_init_f()</code>计算的重定位目的地 <em><strong>(DDR)</strong></em></li>
<li>对于<code>SPL</code>,  <code>board_init_f()</code>只返回(到<code>crt0</code>)。在<code>SPL</code>中没有代码重定位。</li>
</ul>
</blockquote>
</li>
<li>
<p>设置 能够 调用<code>board_init_r()</code>的最终环境 , 这个环境 存在以下条件 :</p>
<blockquote>
<ul>
<li>BSS段 ( 已初始化为0 )</li>
<li>已初始化的非 <code>const</code> 数据 ( 初始化为预期值)</li>
<li>在DRAM 上的堆栈</li>
<li>GD 保留了<code>board_init_f()</code> 设置的值</li>
</ul>
</blockquote>
</li>
<li>
<p>调用 <code>c_runtime_cpu_setup</code> 函数 设置关于 CPU 此时的一些 内存设置</p>
</li>
<li>
<p>调用<code>board_init_r</code>函数</p>
<blockquote>
<ul>
<li>进行一些后续的初始化操作 , 如初始化 emmc、中断、环境变量等</li>
<li>在 <code>board_init_r</code> 中读取 <code>uboot</code>控制台指令 ，或跳转到系统内核运行</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<br>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_main)</span><br><span class="line"></span><br><span class="line">/* 设置初始C运行时环境并调用board_init_f(0) */</span><br><span class="line">#if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK)</span><br><span class="line">	ldr	sp, =(CONFIG_SPL_STACK)   </span><br><span class="line">#else</span><br><span class="line">	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)	@ 设置sp指针指向CONFIG_SYS_INIT_SP_ADDR (即0x0091FF00)</span><br><span class="line">#endif</span><br><span class="line">#if defined(CONFIG_CPU_V7M)				@ 条件不成立</span><br><span class="line">	mov	r3, sp</span><br><span class="line">	bic	r3, r3, #7</span><br><span class="line">	mov	sp, r3	</span><br><span class="line">#else</span><br><span class="line">	bic	sp, sp, #7						@ sp指针8字节对齐</span><br><span class="line">#endif</span><br><span class="line">	mov	r0, sp							@ 将sp保存到r0寄存器 , 此时r0 = 0x0091FF00</span><br><span class="line">	bl	board_init_f_alloc_reserve		@ (具体见补充 &#x27;1&#x27; ) 参数通过r0传递,作用是留出早期的 malloc 内存区域和 gd 内存区域 </span><br><span class="line">	mov	sp, r0							@ r0保存着返回值,将sp 设置为返回值 , 即0x0091FA00</span><br><span class="line">    										</span><br><span class="line">/* 在这里设置 gd的值, 在所有c代码之外 */</span><br><span class="line">	mov	r9, r0							@ (具体见 补充 &#x27;2&#x27;) 设置gd (r9)指向 0x0091FA00(r0)，因为 r9 寄存器存放着全局变量 gd 的地址 </span><br><span class="line">	bl	board_init_f_init_reserve	    @ (具体见 补充 &#x27;3&#x27;)用于初始化 gd，即清零处理 , 设置early malloc起始地址 为 (gd即地址 + gd的大小)</span><br><span class="line"></span><br><span class="line">	mov	r0, #0							@ 设置r0为0 ,用于传递参数0 方便后面调用 board_init_f(0) 即形参boot_flags = 0,</span><br><span class="line">	bl	board_init_f					@ (具体见&#x27;2.3.2.1.5&#x27;小节)初始化DDR, 定时器,串口, 预留各数据在DRAM中的内存空间等，</span><br><span class="line">	</span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line"></span><br><span class="line"> /*  设置中间环境(新的sp和gd)并调用 relocate_code (addr_moni)</span><br><span class="line">  *  最后设置 lr 寄存器为 here  ,后面执行其他函数如relocate_code 等, 返回的话 就会返回到here这个地址</span><br><span class="line">  */</span><br><span class="line">	ldr	sp, [r9, #GD_START_ADDR_SP]	 	@ sp = r9 + GD_START_ADDR_SP 即(sp = gd-&gt;start_addr_sp) ,因为r9是 结构体gd的基地址</span><br><span class="line">										@ gd-&gt;start_addr_sp = 0x9EF44E90 ,这是属于DDR的地址,说明新的sp和gd放在ddr中而不是内部RAM</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_CPU_V7M)				@ 条件不成立</span><br><span class="line">	mov	r3, sp							</span><br><span class="line">	bic	r3, r3, #7</span><br><span class="line">	mov	sp, r3</span><br><span class="line">#else</span><br><span class="line">	bic	sp, sp, #7				@ sp做8字节对齐</span><br><span class="line">#endif</span><br><span class="line">	ldr	r9, [r9, #GD_BD]		@(具体见 补充 &#x27;4&#x27;)将 gd-&gt;bd 的数据读入r9寄存器, r9存放的是就的gd基地址,通过 gd-&gt;bd计算新的gd地址</span><br><span class="line">	sub	r9, r9, #GD_SIZE		@ 计算 gd 的新地址</span><br><span class="line">								</span><br><span class="line">	adr	lr, here                @ 将 lr 寄存器 赋值为 here , 这样后面执行其他函数返回的时候就返回到 下面53行here符号的地方 </span><br><span class="line">	ldr	r0, [r9, #GD_RELOC_OFF]		@ r0 = gd-&gt;reloc_off   GD_RELOC_OFF = 68</span><br><span class="line">	add	lr, lr, r0				@ 因为要重定位代码, 要把uboot拷贝到DDR的最后空间去 , 所以lr 中的here要使用重定位后的位置</span><br><span class="line">#if defined(CONFIG_CPU_V7M)		</span><br><span class="line">	orr	lr, #1					@ 条件不成立 , 这行不运行</span><br><span class="line">#endif</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]	@ (r0 = gd-&gt;relocaddr, relocaddr保存uboot的目的地址)赋值后 , r0保存着 uboot 要拷贝的目的地址</span><br><span class="line">	b	relocate_code			@ (具体见 &#x27;2.3.2.1.7&#x27; 小节)调用relocate_code 代码重定位函数 , 赋值将uboot 拷贝到新的地址</span><br><span class="line">here:</span><br><span class="line"></span><br><span class="line">/* 开始重定位向量表 */</span><br><span class="line">	bl	relocate_vectors		@ (具体见 &#x27;2.3.2.1.8&#x27; 小节)调用 relocate_vectors ,重定位中断向量表</span><br><span class="line"></span><br><span class="line">/* 设置最终(完整)环境 */</span><br><span class="line"></span><br><span class="line">	bl	c_runtime_cpu_setup		@ 配置协处理器 ,关闭icache</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FRAMEWORK)		@条件不成立</span><br><span class="line"># ifdef CONFIG_SPL_BUILD</span><br><span class="line">	/* 如果请求,使用DRAM堆栈为其余的SPL堆栈 */</span><br><span class="line">	bl	spl_relocate_stack_gd</span><br><span class="line">	cmp	r0, #0</span><br><span class="line">	movne	sp, r0</span><br><span class="line">	movne	r9, r0</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">/********************************* 下面这段代码用于清除 BSS段   ********************************/</span><br><span class="line">	ldr	r0, =__bss_start	/* bss段开始地址*/			</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_USE_ARCH_MEMSET</span><br><span class="line">	ldr	r3, =__bss_end		/* bss段结束地址 */</span><br><span class="line">	mov	r1, #0x00000000		/* 将r1 赋 零用于清除 bss段 */</span><br><span class="line"></span><br><span class="line">	subs	r2, r3, r0		/* r2 = r3-r0 , r2为bss段的长度 */</span><br><span class="line">	bl	memset</span><br><span class="line">#else </span><br><span class="line">	ldr	r1, =__bss_end		/* this is auto-relocated! */</span><br><span class="line">	mov	r2, #0x00000000		/* prepare zero to clear BSS */</span><br><span class="line"></span><br><span class="line">clbss_l:cmp	r0, r1			/* while not at end of BSS */</span><br><span class="line">#if defined(CONFIG_CPU_V7M)</span><br><span class="line">	itt	lo</span><br><span class="line">#endif</span><br><span class="line">	strlo	r2, [r0]		/* clear 32-bit BSS word */</span><br><span class="line">	addlo	r0, r0, #4		/* move to next */</span><br><span class="line">	blo	clbss_l</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/**********************************************************************/</span><br><span class="line"></span><br><span class="line">#if ! defined(CONFIG_SPL_BUILD)</span><br><span class="line">	bl coloured_LED_init</span><br><span class="line">	bl red_led_on</span><br><span class="line">#endif</span><br><span class="line">	/* 设置 board_init_r(gd_t *id, ulong dest_addr) 两个参数 ,用r0、r1传参 */</span><br><span class="line">	mov     r0, r9                 @ 第一个参数是gd , 所以读取r9保存到r0</span><br><span class="line">	ldr	r1, [r9, #GD_RELOCADDR]	   @ 第二个参数是目的地址 , 所以 r1= gd-&gt;relocaddr</span><br><span class="line">	</span><br><span class="line">	/* 调用 board_init_r 函数*/</span><br><span class="line">#if defined(CONFIG_SYS_THUMB_BUILD)	@条件不成立</span><br><span class="line">	ldr	lr, =board_init_r	</span><br><span class="line">	bx	lr</span><br><span class="line">#else</span><br><span class="line">	ldr	pc, =board_init_r	  @ (具体见 &#x27;2.3.2.1.9&#x27; 小节5)调用board_init_r函数 ,继续完成初始化工作   </span><br><span class="line">#endif</span><br><span class="line">	/* we should not return here. */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(_main)</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>1️⃣     <code>board_init_f_alloc_reserve</code> 函数</p>
<blockquote>
<p><em><strong>位置 :</strong></em>  <code>common/init/board_init.c</code></p>
<p><em><strong>函数功能如下:</strong></em></p>
<ul>
<li>留出早期的 <code>malloc</code> 内存区域和 <code>gd</code> 内存区域</li>
</ul>
</blockquote>
<br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ulong <span class="title function_">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 预留早期 malloc的内存区域 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYS_MALLOC_F)</span></span><br><span class="line">	top -= CONFIG_SYS_MALLOC_F_LEN;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* LAST : 保留 GD 内存区域(四舍五入到16字节的倍数) */</span></span><br><span class="line">	top = rounddown(top-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> global_data), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中<code>CONFIG_SYS_MALLOC_F_LEN=0X400</code></p>
</li>
<li>
<p><code>sizeof(struct global_data)=248</code>  ( <code>GD_SIZE</code> 值)</p>
</li>
<li>
<p>完成后的 <em><strong>内存分配</strong></em> :</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c73b.png" alt="image-20230516151408214" /></p>
</li>
</ul>
<br>
<hr />
<p>2️⃣  全局变量 <code>global_data(gd)</code></p>
<blockquote>
<p><code>uboot</code> 中定义了一个指向 <code>gd_t</code> 的指针 <code>gd</code>，<code>gd</code> 存放在寄存器 <code>r9</code> 里面 ,因此 <code>gd</code>是个 <em><strong>全局变量</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_ARM64</span><br><span class="line">#define DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (&quot;x18&quot;)</span><br><span class="line">#else</span><br><span class="line">#define DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm (&quot;r9&quot;)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><code>gd_t</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> baudrate;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> cpu_clk;	<span class="comment">/* CPU clock in Hz!		*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bus_clk;</span><br><span class="line">	<span class="comment">/* We cannot bracket this with CONFIG_PCI due to mpc5xxx */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pci_clk;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mem_clk;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_LCD) || defined(CONFIG_VIDEO)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> fb_base;	<span class="comment">/* Base address of framebuffer mem */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//.......................//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DM_VIDEO</span></span><br><span class="line">    ulong video_top;		<span class="comment">/* Top of video frame buffer area */</span></span><br><span class="line">    ulong video_bottom; 	<span class="comment">/* Bottom of video frame buffer area */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;<span class="type">gd_t</span>;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<p>3️⃣   <code>board_init_f_init_reserve</code> 函数</p>
<blockquote>
<p><em><strong>位置 :</strong></em>  <code>common/init/board_init.c</code></p>
<p><em><strong>功能 :</strong></em></p>
<ul>
<li>用于初始化 gd , 即清零处理</li>
<li>设置 <code>gd-&gt;malloc_base</code> 为 <em><strong><code>gd</code> 基地址 + <code>gd</code> 大小</strong></em>=<code>0X0091FA00+248</code>=<code>0X0091FAF8</code></li>
<li>并做16字节对齐 , 最终<code>gd-&gt;malloc_base=0X0091FB00</code>，这个也就是 <code>early malloc</code> 的 <em><strong>起始地址</strong></em></li>
</ul>
</blockquote>
<br>
<hr />
<p>4️⃣  通过 <code>gd-&gt;bd</code> 计算新的 <code>gd</code> 地址</p>
<p><em><strong>涉及的代码</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr	r9, [r9, #GD_BD]				// 获取gd -&gt; bd的地址</span><br><span class="line">sub	r9, r9, #GD_SIZE				// 减去bd 结构体占用的空间 即为 gd结构体的空间</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过前文 , 可以得到如下信息 :</p>
<ul>
<li>
<p><code>r9</code>寄存器存放的是 一个指向 <code>gd_t</code>结构体 的指针 <code>gd</code> , 即r9寄存器存放的是 <code>gd</code> 数据结构体 <em><strong>旧的 基地址 ( 片上 RAM, 不是DRAM)</strong></em></p>
</li>
<li>
<p>板信息 <code>bd</code> 是 <code>gd</code>结构体的第一个成员 , 即 <code>gd -&gt; bd</code> 的 <em><strong>首地址</strong></em> 与 gd结构体的 <em><strong>基地址</strong></em> (即<code>r9</code>寄存器保存的值) 是一致的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> &#123;</span></span><br><span class="line">	<span class="type">bd_t</span> *bd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="type">gd_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>gd</code>结构体的 <code>gd -&gt; bd</code> 成员在 调用 <code>board_init_f</code> 函数的时候 就已经被重定位在 <code>DRAM</code>上了 ( 即 <em><strong>新地址</strong></em> )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initcall_run_list(init_sequence_f))		<span class="comment">// 调用initcall_run_list函数来运行初始化序列</span></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;		<span class="comment">// init_sequence_f是initcall_run_list 的传入参数 (一个存放各个函数入口的数组) </span></span><br><span class="line">... </span><br><span class="line">reserve_board, 					<span class="comment">//	在DRAM留出板子 bd 所占的内存区 , 完成后 gd -&gt; bd = 0X9EF44FB0	</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>两个宏其中 <code>GD_BD = 0</code> ; <code>GD_SIZE = 248</code></p>
<ul>
<li>因为bd 是 gd结构体 的第一个成员 所以 <code>gd -&gt; bd = r9 + GD_BD</code></li>
<li><code>GD_SIZE</code> 是 <code>gd</code>结构体的大小 , 为<code>248B</code></li>
</ul>
</li>
<li>
<p>为什么 <code>gd-&gt;bd</code> 减去   <code>gd</code> 的大小就是 <em><strong>新的</strong></em>  <code>gd</code> 的位置</p>
<blockquote>
<ul>
<li>
<p>因为 <code>gd</code>新的地址 (即在<code>DRAM</code>中的地址)  是在 <code>bd</code>数据的下面 ( 即 <em><strong>低地址位置</strong></em> )</p>
</li>
<li>
<p>图为 调用 <code>board_init_f</code> 函数后 在<code>DRAM</code> 中的 <em><strong>内存空间图</strong></em></p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c76e.png" alt="image-20230517172742492" style="zoom: 80%;" />
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<br>
<hr />
<p>5️⃣</p>
<hr />
<h6 id="23215-board_init_f-函数"><a class="markdownIt-Anchor" href="#23215-board_init_f-函数"></a> 2.3.2.1.5  board_init_f 函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em>   <code>common/board_f.c</code></p>
<p><em><strong>功能 :</strong></em></p>
<ul>
<li>
<p>初始化一系列外设，比如串口、定时器，或者打印一些消息等</p>
</li>
<li>
<p>初始化 <code>gd</code> 的各个成员变量， 将<code>uboot</code> 在<code>DRAM</code> 最后面的地址区域 预留区域 ,  方便后面拷贝</p>
<ul>
<li>因为本质上 <code>uboot</code> 是 <code>linux</code> 的引导文件，引导完成后 <code>linux</code> 会在 <code>DRAM</code> 前面的地址区域启动</li>
<li>为了防止 <code>linux</code> 启动后对 <code>uboot</code> 进行干扰，<code>uboot</code> 会将自己重定位到 <code>DRAM</code> 最后面的地址区域</li>
</ul>
<blockquote>
<ul>
<li>拷贝之前需要给 <code>uboot</code> 各部分分配好内存位置和大小 ,比如 <code>gd</code> 应该存放到哪个位置，<code>malloc</code> 内存池应该存放到哪个位置等</li>
<li>这些信息都保存在 <code>gd</code> 的 <em><strong>成员变量</strong></em> 中，因此首先要对 <code>gd</code> 的这些成员变量做初始化</li>
</ul>
</blockquote>
</li>
<li>
<p>在<code>DRAM</code>最后部分预留各数据的内存空间 (如 <code>uboot</code>、<code>malloc</code>、<code>gd</code>、<code>bd</code>等) , 最终一个完整的内存 <em><strong>分配图</strong></em> , 在后面重定位 <code>uboot</code>时 使用</p>
</li>
</ul>
</blockquote>
<br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">board_init_f</span><span class="params">(ulong boot_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_GENERIC_GLOBAL_DATA				<span class="comment">// 条件不成立</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 对于某些架构来说, 全局变量在调用这个函数之前就被被初始化和使用,所以应该保存全局变量的数据</span></span><br><span class="line"><span class="comment">	 * 对于这些架构,应该定义CONFIG_SYS_GENERIC_GLOBAL_DATA这个宏,并在重定位之前使用这里的堆栈来承载全局数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">gd_t</span> data;</span><br><span class="line"></span><br><span class="line">	gd = &amp;data;</span><br><span class="line">    </span><br><span class="line">	zero_global_data();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	gd-&gt;flags = boot_flags;						<span class="comment">//  初始化 gd-&gt;flags=boot_flags=0</span></span><br><span class="line">	gd-&gt;have_console = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_run_list(init_sequence_f))		<span class="comment">// (具体见 补充&#x27;2.3.2.1.6&#x27;小节)通过 initcall_run_list函数来运行初始化序列 , 传入参数是init_sequence_f (一个存放各个函数入口的数组)</span></span><br><span class="line">		hang();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_ARM) &amp;&amp; !defined(CONFIG_SANDBOX) &amp;&amp; \</span></span><br><span class="line"><span class="meta">		!defined(CONFIG_EFI_APP)</span></span><br><span class="line">	<span class="comment">/* NOTREACHED - jump_to_copy() does not return */</span></span><br><span class="line">	hang();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Light up LED1 */</span></span><br><span class="line">	imx6_light_up_led1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>形参 <code>boot_flags</code> 是通过 r0传递的 , <code>r0 = boot_flags = 0</code></li>
<li>调用<code>initcall_run_list</code>函数来运行 <em><strong>初始化序列</strong></em> , 传入参数是<code>init_sequence_f</code>  <em>(一个存放各个函数入口的数组)</em></li>
</ul>
<br>
<hr />
<h6 id="23216-init_sequence_f-数组"><a class="markdownIt-Anchor" href="#23216-init_sequence_f-数组"></a> 2.3.2.1.6  init_sequence_f 数组</h6>
<blockquote>
<p><em><strong>位置 :</strong></em>  <code>common/board_f.c</code></p>
<p><em><strong>功能 :</strong></em></p>
<ul>
<li>是一个存放了各个函数入口的数组</li>
<li>通过<code>initcall_run_list</code> 来一系列初始化序列 , 设置<code>GD</code>的各个成员的值</li>
<li>用于初始化一系列外设，比如串口、定时器，或者打印一些消息等</li>
</ul>
</blockquote>
<br>
<p><em><strong>去除条件编译后的<code>init_sequence_f</code>如下 :</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">setup_mon_len, 			<span class="comment">// 设置gd-&gt;mon_len ,此处为 __bss_end -_start = 0xA8E74, 即整个代码的长度</span></span><br><span class="line">initf_malloc, 			<span class="comment">// 数初始化gd中跟malloc有关的成员变量，比如 malloc_limit (malloc内存池大小), 这里会设置</span></span><br><span class="line">initf_console_record, 	<span class="comment">// 对于 IMX6ULL来说 是空函数</span></span><br><span class="line">arch_cpu_init, 			<span class="comment">// 基本的arch CPU相关设置 </span></span><br><span class="line">initf_dm, 				<span class="comment">// 驱动模型的一些初始化</span></span><br><span class="line">arch_cpu_init_dm, 		<span class="comment">// 函数未实现</span></span><br><span class="line">mark_bootstage, 		<span class="comment">// 设置某些标记</span></span><br><span class="line">board_early_init_f, 	<span class="comment">// 板子相关的</span></span><br><span class="line">timer_init, 			<span class="comment">// 初始化定时器  </span></span><br><span class="line">board_postclk_init, 	<span class="comment">// 对于 I.MX6ULL 来说是设置 VDDSOC 电压</span></span><br><span class="line">get_clocks,				<span class="comment">// get_clocks 函数用于获取一些时钟值，I.MX6ULL 获取的是 sdhc_clk 时钟(即SD卡外设时钟)</span></span><br><span class="line">env_init, 				<span class="comment">// 设置 gd 的env_addr成员,即环境变量的保存地址</span></span><br><span class="line">init_baud_rate, 		<span class="comment">// 初始化波特率,根据环境变量baudrate来初始化 gd-&gt;baudrate  </span></span><br><span class="line">serial_init, 			<span class="comment">// 初始化串口   </span></span><br><span class="line">console_init_f, 		<span class="comment">// 设置 gd-&gt;have_console 为 1，表示有个控制台,同时将之前暂存在缓冲区中的数据通过控制台打印出来</span></span><br><span class="line">display_options, 		<span class="comment">// 通过串口输出一些信息, 这里是uboot 的版本信息   </span></span><br><span class="line">display_text_info, 		<span class="comment">// 打印一些文本信息，如果开启 UBOOT 的 DEBUG 功能的话就会输出 text_base、bss_start、bss_end  </span></span><br><span class="line">print_cpuinfo,	 		<span class="comment">// 打印CPU信息(和运行速度)   </span></span><br><span class="line">show_board_info, 		<span class="comment">// 用于打印板子信息</span></span><br><span class="line">INIT_FUNC_WATCHDOG_INIT <span class="comment">// 初始化看门狗，对于 I.MX6ULL 来说是空函数</span></span><br><span class="line">INIT_FUNC_WATCHDOG_RESET<span class="comment">// 复位看门狗，对于 I.MX6ULL 来说是空函数</span></span><br><span class="line">init_func_i2c, 			<span class="comment">// 用于初始化 I2C</span></span><br><span class="line">announce_dram_init, 	<span class="comment">// 输出字符串 “DRAM:”</span></span><br><span class="line">dram_init, 				<span class="comment">// 配置可用RAM组,并非真正的初始化 DDR,只是设置gd-&gt;ram_size ,即DDR的大小(如 512MB)  </span></span><br><span class="line">post_init_f, 			<span class="comment">// 完成一些测试，初始化 gd-&gt;post_init_f_time</span></span><br><span class="line">INIT_FUNC_WATCHDOG_RESET<span class="comment">// 复位看门狗，对于 I.MX6ULL 来说是空函数</span></span><br><span class="line">testdram, 				<span class="comment">// 测试 DRAM，空函数</span></span><br><span class="line">INIT_FUNC_WATCHDOG_RESET<span class="comment">// 复位看门狗，对于 I.MX6ULL 来说是空函数</span></span><br><span class="line">INIT_FUNC_WATCHDOG_RESET<span class="comment">// 复位看门狗，对于 I.MX6ULL 来说是空函数</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 到这里为止 , 已经映射了DRAM并开始工作, </span></span><br><span class="line"><span class="comment">* 可以开始重定位代码 并继续从 DRAM 运行</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">* 在RAM末端预留内存(按顺序从上到下):</span></span><br><span class="line"><span class="comment">* - mmu的TLB表 (reserve_mmu = 0x4000 = 16KB , 64K字节对齐)</span></span><br><span class="line"><span class="comment">* - 跟踪调试的内存 (reserve_trace = 0)</span></span><br><span class="line"><span class="comment">* - uboot 所占用的内存区域 (reserve_uboot = 0xA8EF4 , 4K字节对齐)</span></span><br><span class="line"><span class="comment">* - malloc 区域 (reserve_malloc = 0x01002000 =16MB + 8KB)</span></span><br><span class="line"><span class="comment">* - 板子bd结构体的内存 (reserve_board = 80B)</span></span><br><span class="line"><span class="comment">* - `gd_t` 的内存区域 (240B)</span></span><br><span class="line"><span class="comment">* -  栈空间 (16字节对齐)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">setup_dest_addr, 		<span class="comment">// (补充 &#x27;1&#x27;)设置目的地址,设置gd-&gt;ram_size; gd-&gt;ram_top; gd-&gt;relocaddr 这三个值</span></span><br><span class="line">reserve_round_4k, 		<span class="comment">// 对 gd-&gt;relocaddr 做 4KB 对齐 , 这里的值0XA0000000，已经是 4K 对齐了，所以调整后不变</span></span><br><span class="line">reserve_mmu, 			<span class="comment">// (补充 &#x27;2&#x27;)留出 MMU 的 TLB 表的位置, 分配完后会对 gd-&gt;relocaddr 做 64K 字节对齐</span></span><br><span class="line">reserve_trace, 			<span class="comment">// 留出跟踪调试的内存，I.MX6ULL 没有用到</span></span><br><span class="line">reserve_uboot, 			<span class="comment">// (补充 &#x27;3&#x27;)留出重定位后的 uboot 所占用的内存区域, 大小由gd-&gt;mon_len 所指定, 分配完后做 4K字节对齐</span></span><br><span class="line">reserve_malloc, 		<span class="comment">// (补充 &#x27;4&#x27;)留出 malloc 区域, 调整 gd-&gt;start_addr_sp 位置;malloc 区域由宏TOTAL_MALLOC_LEN定义</span></span><br><span class="line">reserve_board, 			<span class="comment">// (补充 &#x27;5&#x27;)留出板子 bd 所占的内存区，bd 是结构体 bd_t，bd_t 大小为80字节 , 后续根据 gd-&gt;bd 计算出新的 gd 的位置 ,用于uboot重定位</span></span><br><span class="line">setup_machine, 			<span class="comment">// 设置机器 ID，linux 启动的时候会和这个机器 ID 匹配，如果匹配的话 linux 就会启动正常 ; IMX6ULL使用设备树,所以此函数无效</span></span><br><span class="line">reserve_global_data, 	<span class="comment">// (补充 &#x27;6&#x27;)保留出 gd_t 的内存区域，gd_t 结构体大小为 248 字节</span></span><br><span class="line">reserve_fdt, 			<span class="comment">// 留出设备树相关的内存区域, I.MX6ULL 的 uboot 没有用到,所以此函数无效</span></span><br><span class="line">reserve_arch, 			<span class="comment">// 空函数</span></span><br><span class="line">reserve_stacks,			<span class="comment">// (补充 &#x27;7&#x27;)留出栈空间, 先对 gd-&gt;start_addr_sp 减去 16，然后做 16 字节对齐,如果使能IRQ的话也要留出对应内存 ,这里没有使用</span></span><br><span class="line">setup_dram_config, 		<span class="comment">// (补充 &#x27;8&#x27;)设置gd-&gt;bd-&gt;bi_dram[0].start 和 gd-&gt;bd-&gt;bi_dram[0].size,后面会传递给 linux内核, 告诉 linux DRAM 的起始地址和大小</span></span><br><span class="line">show_dram_config, 		<span class="comment">// 显示 DRAM 的配置</span></span><br><span class="line">display_new_sp, 		<span class="comment">// 显示新的 sp 位置，即 gd-&gt;start_addr_sp 存放的值</span></span><br><span class="line">INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">reloc_fdt, 				<span class="comment">// 重定位 fdt，没有用到</span></span><br><span class="line">setup_reloc, 			<span class="comment">// (补充 &#x27;9&#x27;) 设置 gd 的其他一些成员变量，供后面重定位的时候使用，并且将以前的 gd 拷贝到 gd-&gt;new_gd 处</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>1️⃣  <code>setup_dest_addr</code> 函数</p>
<blockquote>
<p><code>setup_dest_addr</code> 函数 主要用于设置目的地址 , 主要用于输出以下三个 值:</p>
<ul>
<li><code>gd-&gt;ram_size</code>   ( RAM的大小 ) 这里是 <code>0x20000000</code> , 512MB</li>
<li><code>gd-&gt;ram_top</code> ( RAM的最高地址 ) 这里是 <code>0x80000000</code> + <code>0x20000000</code> = <code>0xA0000000</code></li>
<li><code>gd-&gt;relocaddr</code> (重定位后的最高地址 ) 这里是<code>0xA000000</code></li>
</ul>
</blockquote>
<br>
<hr />
<p>2️⃣ <code>reserve_mmu</code> 函数</p>
<blockquote>
<p>留出 <code>MMU</code> 的 <code>TLB</code> 表的位置，分配 <code>MMU</code> 的 <code>TLB</code> 表内存以后会对 <code>gd-&gt;relocaddr</code> 做 64K 字节对齐</p>
<p>完成之后的 <code>gd-&gt;arch.tlb_size</code>、<code>gd-&gt;arch.tlb_addr</code> 和 <code>gd-&gt;relocaddr</code> 如下所示:</p>
<ul>
<li><code>gd-&gt;arch.tlb_size</code> :  <code>MMU</code>的<code>TLB</code>表大小 (这里为 <code>0x4000</code>)</li>
<li><code>gd-&gt;arch.tlb_addr</code> :  <code>MMU</code> 的 <code>TLB</code> 表起始地址，<code>64KB</code> 对齐以后 ( 这里为 <code>0x9FFF0000</code>)</li>
<li><code>gd-&gt;relocaddr</code> :  <code>relocaddr</code> 地址 ( 这里为 <code>0x9FFF0000</code>)</li>
</ul>
</blockquote>
<br>
<hr />
<p>3️⃣ <code>reserve_uboot</code> 函数</p>
<blockquote>
<ul>
<li>留出重定位后的 <code>uboot</code> 所占用的内存区域 ,</li>
<li><code>uboot</code> 所占用大小由<code>gd-&gt;mon_len</code> 所指定，留出 uboot 的空间以后还要对 <code>gd-&gt;relocaddr</code> 做 4K 字节对齐</li>
<li>并且重新设置 <code>gd-&gt;start_addr_sp</code></li>
</ul>
<p>完成之后, <code>gd-&gt;mon_len</code> , <code>gd-&gt;start_addr_sp</code> , <code>gd-&gt;relocaddr</code> 如下所示:</p>
<ul>
<li><code>gd-&gt;mon_len</code> : <code>uboot</code> 所占的大小 ( 这里为 <code>0xA8EF4</code>)</li>
<li><code>gd-&gt;start_addr_sp</code> : 重设 <code>gd-&gt;start_addr_sp</code>  指针 ( 这里为 <code>0x9FF47000</code>)</li>
<li><code>gd-&gt;relocaddr</code> :  <code>relocaddr</code> 地址 ( 这里为 <code>0x9FF47000</code>)</li>
</ul>
</blockquote>
<br>
<hr />
<p>4️⃣  <code>reserve_malloc</code> 函数</p>
<blockquote>
<ul>
<li><code>reserve_malloc</code> 函数 留出 <code>malloc</code> 区域，</li>
<li>调整 <code>gd-&gt;start_addr_sp</code> 位置，</li>
<li><code>malloc</code> 区域由宏<code>TOTAL_MALLOC_LEN</code> 定义</li>
</ul>
<p><em><strong>宏定义如下 :</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MALLOC_LEN (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>CONFIG_SYS_MALLOC_LEN</code> 为 <code>16MB=0X1000000</code></li>
<li><code>CONFIG_ENV_SIZE</code>=<code>8KB=0X2000</code></li>
<li>因此 <code>TOTAL_MALLOC_LEN=0X1002000</code> (即<code>malloc</code> 的区域大小为 <code>0X1002000</code>)</li>
</ul>
</blockquote>
<br>
<p>可以得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TOTAL_MALLOC_LEN=0X1002000</span><br><span class="line">gd-&gt;start_addr_sp=0X9EF45000  @0X9FF47000-16MB-8KB=0X9EF45000</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<p>5️⃣   <code>reserve_board</code> 函数</p>
<blockquote>
<ul>
<li><code>reserve_board</code> 函数，用于留出板子 <code>bd</code> 所占的内存区</li>
<li><code>bd</code> 是结构体 <code>bd_t</code>，<code>bd_t</code> 大小为 80字节</li>
</ul>
<p>调整之后结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;start_addr_sp=0X9EF44FB0</span><br><span class="line">gd-&gt;bd=0X9EF44FB0		@ 调用完board_init_f这个函数之后 , 这个根据gd-&gt;bd, 来获取重定位后 , 新的gd的地址</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<p>6️⃣   <code>reserve_global_data</code> 函数</p>
<blockquote>
<p>保留出 <code>gd_t</code> 的内存区域，<code>gd_t</code> 结构体大小为 <code>248B</code></p>
<p><em><strong>完成后结果如下 :</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;start_addr_sp=0X9EF44EB8    @0X9EF44FB0-248=0X9EF44EB8</span><br><span class="line">gd-&gt;new_gd=0X9EF44EB8</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<p>7️⃣  <code>reserve_stacks</code> 函数</p>
<blockquote>
<ul>
<li><code>reserve_stacks</code> 函数 用于 <em><strong>留出栈空间</strong></em></li>
<li>先对 <code>gd-&gt;start_addr_sp</code> 减去 16 , 然后做 <em><strong>16字节对齐</strong></em></li>
<li>如果使能 <code>IRQ</code> 的话还要留出 <code>IRQ</code> 相应的内存 , 这里不使能</li>
</ul>
<p>完成后结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;start_addr_sp=0X9EF44E90    </span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<p>8️⃣  <code>setup_dram_config</code> 函数</p>
<blockquote>
<ul>
<li><code>setup_dram_config</code> 函数 用于设置 <code>dram</code>信息</li>
<li>即设置  <code>gd-&gt;bd-&gt;bi_dram[0].start</code> 和 <code>gd-&gt;bd-&gt;bi_dram[0].size</code> 两个成员</li>
<li>用于后续传递给 linux 内核 , 告诉linux DRAM 的起始地址和大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gd-&gt;bd-&gt;bi_dram[0].start=0x80000000</span><br><span class="line">gd-&gt;bd-&gt;bi_dram[0].size=0x20000000</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>即传递给linux内核 , DRAM 的起始地址为 <code>0x80000000</code> , 大小为 <code>0X20000000</code>(512MB)</li>
</ul>
</blockquote>
</blockquote>
<br> 
<hr />
<p>9️⃣ <code>setup_reloc</code> 函数</p>
<blockquote>
<ul>
<li><code>setup_reloc</code> 函数 用于设置 gd其他一些成员变量 , 供后面重定位的时候使用</li>
<li>并将之前的 gd拷贝到 gd-&gt;new_gd处</li>
<li>重定位后 ,  uboot 的新地址为 <code>0X9FF4700</code> ;</li>
<li>新的gd首地址为 <code>0X9EF44EB8</code> ;</li>
<li>新的 sp为<code>0X9EF44E90</code></li>
</ul>
</blockquote>
 <br>
<hr />
<p>🔟  重定位后的内存分配图</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64789ca7f024cca17394c76e.png" alt="image-20230517172742492" /></p>
<br>
<hr />
<h6 id="23217-relocate_code-函数"><a class="markdownIt-Anchor" href="#23217-relocate_code-函数"></a> 2.3.2.1.7   relocate_code 函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em> <code>arch/arm/lib/relocate.S</code></p>
<p><em><strong>功能 :</strong></em></p>
<ul>
<li>代码拷贝 , 将<code>uboot</code> 拷贝到 <code>DDR</code>中 ,即<code>uboot</code>重定位 到 <code>DRAM</code>的高地址</li>
<li>重定位就是 <code>uboot</code> 将自身拷贝到 <code>DRAM</code> 的另一个地放去继续运行  <em>(DRAM 的高地址处)</em></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_code)</span><br><span class="line"></span><br><span class="line">/************************************** 获取各个地址 ********************************************/</span><br><span class="line"></span><br><span class="line">	ldr	r1, =__image_copy_start			@ r1保存寄存器源地址 , 即0x8780 0000 , (__image_copy_start)在链接文件中 , 使用零长度数组标记代码段</span><br><span class="line">	subs	r4, r0, r1					@ 保存偏移量 , r0为 gd-&gt;relocaddr = 0x9FF4 7000 (即uboot拷贝的首地址) r4 = r0-r1 为偏移量</span><br><span class="line">	beq	relocate_done					@ 判断r4是否为0, 即r0 - r1 运算结果 z = 0 ,如果是,则说明不用拷贝,直接执行relocate_done函数</span><br><span class="line">	ldr	r2, =__image_copy_end			@ r2=__image_copy_end, 使用r2保存 拷贝之前的代码结束地址 (片上RAM)</span><br><span class="line"></span><br><span class="line">/*************************完成拷贝工作 , 拷贝 r1到r2这段地址的内容, 并写到目的地址 r0中去 *********************/</span><br><span class="line">copy_loop:</span><br><span class="line">	ldmia	r1!, &#123;r10-r11&#125;				@ 从r1 开始 即(__image_copy_start) , 拷贝2个32位数据到 r10和r11中 , 拷贝完成后 ,r1的值会更新</span><br><span class="line">	stmia	r0!, &#123;r10-r11&#125;		 		@ 将r10和 r11的值写到目的地址 r0 即(gd-&gt;reloc_of), 写完后 , r0的值会更新</span><br><span class="line">	cmp	r1, r2							@ 比较r1 和 r2是否相等 , 即确定是否拷贝完成</span><br><span class="line">	blo	copy_loop						@ 没有则跳转回 copy_loop 继续拷贝 (检查CPSR 寄存器C 标志位是否为0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*********************** 重定位.rel.dyn 段 , .rel.dyn 段是存放.text 段中需要重定位地址的集合 ***********/</span><br><span class="line">	</span><br><span class="line">	ldr	r2, =__rel_dyn_start	@ r2 =__rel_dyn_start, 即 .rel.dyn 段的起始地址</span><br><span class="line">	ldr	r3, =__rel_dyn_end		@ r3 =__rel_dyn_end,  </span><br><span class="line">fixloop:</span><br><span class="line">	ldmia	r2!, &#123;r0-r1&#125;		@ 从起始地址开始 , 每次取两个 4字节数据放到r0和r1寄存器, r0存放低4字节(即Label 地址); r1存放高4字节(即Label 标志)</span><br><span class="line">	and	r1, r1, #0xff			@ 取r1的低8位</span><br><span class="line">	cmp	r1, #23					@ 判断r1 中的值是否等于 23(0x17)</span><br><span class="line">	bne	fixnext					@  r1 不等于 23说明不是描述 Label的,执行fixnext,否则的话就继续执行下面的代码</span><br><span class="line"></span><br><span class="line">	/* relative fix: increase location by offset */</span><br><span class="line">	add	r0, r0, r4				@ r0 保存着 Label 值，r4 保存着重定位后的地址偏移，r0+r4 就得到了重定位后的Label 值  </span><br><span class="line">	ldr	r1, [r0]				@ 读取重定位后 Label 所保存的变量地址 </span><br><span class="line">	add	r1, r1, r4				@ r1+r4 可得到重定位后的变量地址 , </span><br><span class="line">	str	r1, [r0]				@ 重定位后的变量地址写入到重定位后的 Label 中</span><br><span class="line">fixnext:</span><br><span class="line">	cmp	r2, r3					@ 比较 r2 和 r3，查看.rel.dyn 段重定位是否完成</span><br><span class="line">	blo	fixloop					@ 如果 r2 和 r3 不相等，说明.rel.dyn 重定位还未完成 ,继续重定位 .rel.dyn段</span><br><span class="line"></span><br><span class="line">relocate_done:</span><br><span class="line"></span><br><span class="line">#ifdef __XSCALE__</span><br><span class="line"></span><br><span class="line">/*在xscale上，icache必须无效并且写缓冲区耗尽, 即使禁用缓存*/</span><br><span class="line"></span><br><span class="line">	mcr	p15, 0, r0, c7, c7, 0	@ 禁用 icache (指令 cache) </span><br><span class="line">	mcr	p15, 0, r0, c7, c10, 4	@ 将写缓冲区耗尽 </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef __ARM_ARCH_4__</span><br><span class="line">	mov	pc, lr</span><br><span class="line">#else</span><br><span class="line">	bx	lr</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_code)</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>1️⃣    重定位后 寻址会不会有问题</p>
<blockquote>
<p>重定位以后，运行地址就和链接地址不同了 , 但寻址的时候却不会出问题 , 原因如下:</p>
<ul>
<li>首先 <code>uboot</code> 函数寻址时使用到了 <code>bl</code> 指令，而 <code>bl</code> 指令时位置无关指令</li>
<li><code>bl</code> 指令是相对寻址的 <em><strong>(pc+offset)</strong></em> ，因此 <code>uboot</code> 中函数调用是与 <em><strong>绝对位置</strong></em> 无关的</li>
<li>其次函数对变量的访问没有直接进行，而是使用了一个第三方偏移地址，叫做 <code>Label</code></li>
<li>这个第三方偏移地址就是实现 <em><strong>重定位</strong></em> 后运行不会出错的重要原因</li>
<li><code>uboot</code> 对于重定位后链接地址和运行地址不一致的解决方法就是 采用位置无关码，</li>
<li>在使用 <code>ld</code> 进行链接的时候使用选项“-<code>pie</code>”生成位置无关的可执行文件生成一个<code>.rel.dyn</code> 段，<code>uboot</code> 就是靠这个<code>.rel.dyn</code> 来解决重定位问题的</li>
</ul>
</blockquote>
<br>
<hr />
<h6 id="23218-relocate_vectors-函数"><a class="markdownIt-Anchor" href="#23218-relocate_vectors-函数"></a> 2.3.2.1.8  relocate_vectors 函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em>  <code>arch/arm/lib/relocate.S</code></p>
<p><em><strong>功能 :</strong></em>  <code>relocate_vectors</code> 函数用于重定位向量表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(relocate_vectors)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CPU_V7M					@ 是 Cortex-M 内核执行的语句 ,因此条件无效</span><br><span class="line"></span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]			@ r0 = gd-&gt;relocaddr </span><br><span class="line">	ldr	r1, =V7M_SCB_BASE</span><br><span class="line">	str	r0, [r1, V7M_SCB_VTOR]</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_HAS_VBAR					@ 支持向量表偏移则条件成立 , 这里条件成立</span><br><span class="line"></span><br><span class="line">   /*如果ARM处理器有安全扩展，使用VBAR重新定位异常向量。*/</span><br><span class="line"></span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]			@ gd-&gt;relocaddr为重定位后的 uboot首地址</span><br><span class="line">	mcr p15, 0, r0, c12, c0, 0 			@ 将r0的值写入 CP15 的VBAR寄存器中 , 即将新的向量表写入到 寄存器 VBAR中</span><br><span class="line">	#else								@ VBAR是向量表基地址寄存器。设置中断向量表偏移的时候就需要 将新的中断向量表基地址写入 VBAR 中</span><br><span class="line"></span><br><span class="line">	/* 将重新定位的中断向量表复制到正确的地址, 在CP15 的c1寄存器的 V 位给出了中断向量表的基地址 0x00000000*/</span><br><span class="line">	ldr	r0, [r9, #GD_RELOCADDR]			@ r0 = gd-&gt;relocaddr , 目的地址</span><br><span class="line">	mrc	p15, 0, r2, c1, c0, 0	/* V bit (bit[13]) in CP15 c1 */</span><br><span class="line">	ands	r2, r2, #(1 &lt;&lt; 13)</span><br><span class="line">	ldreq	r1, =0x00000000		/* If V=0 */</span><br><span class="line">	ldrne	r1, =0xFFFF0000		/* If V=1 */</span><br><span class="line">	ldmia	r0!, &#123;r2-r8,r10&#125;</span><br><span class="line">	stmia	r1!, &#123;r2-r8,r10&#125;</span><br><span class="line">	ldmia	r0!, &#123;r2-r8,r10&#125;</span><br><span class="line">	stmia	r1!, &#123;r2-r8,r10&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	bx	lr</span><br><span class="line"></span><br><span class="line">ENDPROC(relocate_vectors)</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="23219-board_init_r函数"><a class="markdownIt-Anchor" href="#23219-board_init_r函数"></a> 2.3.2.1.9  board_init_r函数</h6>
<blockquote>
<p><em><strong>位置 :</strong></em>    <code>common/board_r.c</code></p>
<p><em><strong>功能 :</strong></em></p>
<ul>
<li>在前面 的 <code>board_init_f</code>函数并没有 对所有的外设进行初始化 , 还需要做一些后续的初始化工作</li>
<li>这些后续初始化 工作就是由 <code>board_init_r</code> 函数来完成的</li>
<li>跟前面的 <code>board_init_f</code> 函数一样也是通过 调用 <code>initcall_run_list</code> 来运行初始化序列</li>
<li>函数集合 init_sequence_r 用于存放一系列初始化函数</li>
</ul>
</blockquote>
<br>
<p>函数集合 <code>init_sequence_r</code> 如下所示 (已删去大量条件编译)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">init_fnc_t</span> init_sequence_r[] = &#123;</span><br><span class="line">	initr_trace,					<span class="comment">// 初始化和调试跟踪有关的内容</span></span><br><span class="line">	initr_reloc,					<span class="comment">// 设置 gd-&gt;flags，标记重定位完成。</span></span><br><span class="line">	initr_caches,					<span class="comment">// 初始化 cache，使能 cache</span></span><br><span class="line">	initr_reloc_global_data,		<span class="comment">// 初始化重定位后 gd 的一些成员变量</span></span><br><span class="line">	initr_barrier,					<span class="comment">// I.MX6ULL 未用到</span></span><br><span class="line">	initr_malloc,					<span class="comment">// 初始化 malloc</span></span><br><span class="line">	initr_console_record,			<span class="comment">// 初始化控制台相关的内容，I.MX6ULL 未用到，空函数。</span></span><br><span class="line">	bootstage_relocate,				<span class="comment">// 启动状态重定位</span></span><br><span class="line">	initr_bootstage,				<span class="comment">// 初始化 bootstage</span></span><br><span class="line">	board_init, 					<span class="comment">// 板级初始化，包括 74XX 芯片，I2C、FEC、USB 和 QSPI 等。这里执行的是 mx6ull_alientek_emmc.c 文件中的 board_init 函数。</span></span><br><span class="line">	stdio_init_tables,				<span class="comment">// stdio 相关初始化</span></span><br><span class="line">	initr_serial,					<span class="comment">// 初始化串口</span></span><br><span class="line">	initr_announce,					<span class="comment">// 与调试有关，通知已经在 RAM 中运行</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	power_init_board,				<span class="comment">// 初始化电源芯片</span></span><br><span class="line">	initr_flash,					<span class="comment">// 对于 I.MX6ULL 此函数无效</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET		</span><br><span class="line">	initr_nand,						<span class="comment">// 如果有NAND的话 初始化 NAND</span></span><br><span class="line">	initr_mmc,						<span class="comment">// 如果有emmc的话 初始化emmc</span></span><br><span class="line">	initr_env,						<span class="comment">// 初始化环境变量</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_secondary_cpu,			<span class="comment">// 初始化其他 CPU 核，I.MX6ULL 只有一个核，因此此函数没用</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	stdio_add_devices,				<span class="comment">// 各种输入输出设备的初始化，如 LCD driver，I.MX6ULL 使用 drv_video_init 函数初始化 LCD</span></span><br><span class="line">	initr_jumptable,				<span class="comment">// 初始化跳转表</span></span><br><span class="line">	console_init_r,					<span class="comment">// 控制台初始化，初始化完成以后此函数会调用 stdio_print_current_devices 函数来打印出当前的控制台设备</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	interrupt_init,					<span class="comment">// 初始化中断</span></span><br><span class="line">	initr_enable_interrupts,		<span class="comment">// 使能中断</span></span><br><span class="line">	initr_ethaddr,					<span class="comment">// 初始化网络地址，也就是获取 MAC 地址。读取环境变量 &quot;ethaddr&quot; 的值</span></span><br><span class="line">	board_late_init,				<span class="comment">// 板子后续初始化，如果环境变量存储在 EMMC 或者 SD 卡中的话 , 此函数会调用 board_late_mmc_env_init 函数初始化 EMMC/S</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	initr_net,						<span class="comment">// 初始化网络设备</span></span><br><span class="line">	INIT_FUNC_WATCHDOG_RESET</span><br><span class="line">	run_main_loop,					<span class="comment">// 主循环 , 处理命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="2322-阶段2-bootz启动linux-内核"><a class="markdownIt-Anchor" href="#2322-阶段2-bootz启动linux-内核"></a> 2.3.2.2 阶段2 : bootz启动linux 内核</h5>
<blockquote>
<p>在uboot内核启动流程中 ,   已经完成了以下工作 :</p>
<ul>
<li>
<p>设置 <code>CPU</code> 工作模式</p>
<blockquote>
<ul>
<li>禁用 中断 (<code>FIQ</code>、<code>IRQ</code>)</li>
<li>将<code>CPU</code>设置为 <code>SVC</code>模式</li>
</ul>
</blockquote>
</li>
<li>
<p>给linux 内核传递参数 如 <code>DRAM</code> 的 <em><strong>起始地址和大小</strong></em></p>
</li>
<li>
<p>关闭 <code>MMU</code> 、关闭 数据<code>cache</code>等</p>
</li>
</ul>
</blockquote>
<br>
<p>通过 <code>bootz</code> 启动<code>linux</code> 内核流程如下</p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/648169661ddac507cc75fcc9.png" alt="20220213220954" style="zoom: 80%;" />
<br>
<hr />
<h6 id="23221-images-全局变量"><a class="markdownIt-Anchor" href="#23221-images-全局变量"></a> 2.3.2.2.1 images 全局变量</h6>
<blockquote>
<p>启动 <code>Linux</code> 内核的时候会用到一个重要的全局变量 ,</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bootm_headers_t</span> images;</span><br></pre></td></tr></table></figure>
<p><code>bootm_headers_t</code> 是个 <code>boot</code> 头结构体，在文件 <code>include/image.h</code> 中的定义 . 其中的<code>os</code> 成员变量是 <code>image_info_t</code> 类型的，为  <em><strong>系统镜像信息</strong></em></p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line">	<span class="type">image_info_t</span> os;		 <span class="comment">/* OS 镜像信息 */</span></span><br><span class="line">	ulong ep; 				<span class="comment">/* OS 入口点 */</span></span><br></pre></td></tr></table></figure>
<p>结构体 <code>image_info_t</code> 是系统 <em><strong>镜像信息结构体</strong></em> ，具体如下：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_info</span> &#123;</span></span><br><span class="line">	ulong start, end; 					<span class="comment">/* blob 开始和结束位置*/</span></span><br><span class="line">	ulong image_start, image_len; 		<span class="comment">/* 镜像起始地址(包括 blob)和长度 */</span></span><br><span class="line">	ulong load; 						<span class="comment">/* 系统镜像加载地址*/</span></span><br><span class="line">	<span class="type">uint8_t</span> comp, type, os; 			<span class="comment">/* 镜像压缩、类型，OS 类型 */</span></span><br><span class="line">	<span class="type">uint8_t</span> arch; 						<span class="comment">/* CPU 架构 */</span></span><br><span class="line">&#125; <span class="type">image_info_t</span>;</span><br></pre></td></tr></table></figure>
  <br>
<p>下面的 11 个***宏定义*** 表示 <code>U-BOOT</code> 的不同阶段</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_START 				(0x00000001)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOS 				(0x00000002)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOTHER 			(0x00000004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_LOADOS 				(0x00000008)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_RAMDISK 			(0x00000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FDT 				(0x00000020)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_CMDLINE 			(0x00000040)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_BD_T 			(0x00000080)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_PREP 			(0x00000100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_FAKE_GO 			(0x00000200)		<span class="comment">/*&#x27;Almost&#x27; run the OS*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_GO 				(0x00000400)</span></span><br><span class="line">	<span class="type">int</span> state;</span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<h6 id="23222-bootz-命令"><a class="markdownIt-Anchor" href="#23222-bootz-命令"></a> 2.3.2.2.2  bootz 命令</h6>
<blockquote>
<p>bootz 命令完成以下的工作 :</p>
<ul>
<li>
<p><code>do_bootz</code> 函数</p>
<blockquote>
<p><code>bootz_start</code>   函数</p>
<blockquote>
<ul>
<li>在 <code>bootz_srart</code> 函数中设置 <code>images</code> 的 <code>ep</code> 成员变量，也就是系统镜像的入口点 ,  使用 <code>bootz</code> 命令启动系统的时候就会设置系统在 <code>DRAM</code> 中的存储位置，这个存储位置就是系统镜像的入口点，因此 <code>images-&gt;ep=0X80800000</code></li>
<li>查询镜像文件是否为 <code>linux</code> 镜像文件 ,  以及用于查询设备树文件 ( <code>dbt</code>)  ,</li>
</ul>
</blockquote>
<br>
<ul>
<li>调用函数 <code>bootm_disable_interrupts</code> 关闭中断</li>
<li>设置 <code>images.os.os</code> 为 <code>IH_OS_LINUX</code>，也就是设置系统镜像为 <code>Linux</code>  ( 后面会用到 <code>images.os.os</code> 来挑选具体的启动函数 )</li>
</ul>
<br>
<p><code>do_bootm_states</code> 函数</p>
<blockquote>
<ul>
<li>
<p>在<code>do_bootz</code> 函数的最后 调用 了 <code>do_bootm_states</code> 函数 , 用于根据不同的 <code>BOOT</code> 状态执行不同的代码段，判断 <code>BOOT</code> 的状态 , 然后根据<code>BOOT</code>的状态执行不同的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states &amp; BOOTM_STATE_XXX</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过函数 <code>bootm_os_get_boot_func</code> 来查找系统启动函数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_fn = bootm<span class="constructor">_os_get_boot_func(<span class="params">images</span>-&gt;<span class="params">os</span>.<span class="params">os</span>)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>参数 images-&gt;os.os 就是系统类型 , 即之前设置的 <code>IH_OS_LINUX</code></li>
<li><code>bootm_os_get_boot_func</code> 的返回值 就是 找到的 <code>Linux</code> 系统启动函数为  <code>do_bootm_linux</code></li>
</ul>
</blockquote>
</li>
</ul>
<br>
<ul>
<li>
<p><em><strong>(见 ‘2.3.2.2.3’  小节)</strong></em>  <code>do_bootm_linux</code> 函数</p>
<blockquote>
<ul>
<li>
<p><code>do_bootm_linux</code> 函数最终会 跳转执行 <code>boot_prep_linux</code> 和  <code>boot_jump_linux</code> 函数</p>
</li>
<li>
<p><code>boot_prep_linux</code> 主要用于 处理环境变量 <code>bootargs</code> ,  <code>bootargs</code> 保存着 传递给 <code>linux</code>内核的参数</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">boot_prep_linux</span><span class="hljs-params">(<span class="hljs-keyword">bootm_headers_t</span> *images)</span>
</span>&#123;
    <span class="hljs-keyword">char</span> *commandline = getenv(<span class="hljs-string">"bootargs"</span>);　　　　　　<span class="hljs-comment">//从环境变量中获取 bootargs 的值</span>

　　。。。。。。。
        setup_board_tags(&amp;params);　　　　　　
        setup_end_tag(gd-&gt;bd);　　　　<span class="hljs-comment">//将 tag 参数保存在指定位置</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"FDT and ATAGS support not compiled in - hanging\n"</span>);
        hang();
    &#125;
    do_nonsec_virt_switch();
&#125;
</code></pre>
</li>
<li>
<p><code>boot_jump_linux</code> 函数 , 保存机器ID  <em>(如果不使用设备树的话这个机器 ID 会被传递给 Linux</em></p>
<p><em>内核)</em> ,  并最终调用 <code>kernel_entry</code> 函数 ,进入<code>Linux</code>内核</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
</blockquote>
<br>
<hr />
<h6 id="23223-do_bootm_linux-函数"><a class="markdownIt-Anchor" href="#23223-do_bootm_linux-函数"></a> 2.3.2.2.3  <code>do_bootm_linux</code> 函数</h6>
<blockquote>
<p><em><strong>位置</strong></em>  <code>arch/arm/lib/bootm.c</code></p>
<p><em><strong>功能</strong></em>  调用<code>boot_prep_linux</code> 和  <code>boot_jump_linux</code> 两个函数, 并最终启动 <code>linux</code> 内核</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_bootm_linux</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params"><span class="type">bootm_headers_t</span> *images)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* No need for those on ARM */</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_BD_T || flag &amp; BOOTM_STATE_OS_CMDLINE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; BOOTM_STATE_OS_PREP) &#123;</span><br><span class="line">		boot_prep_linux(images);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag &amp; (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) &#123;</span><br><span class="line">	boot_jump_linux(images, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	boot_prep_linux(images);</span><br><span class="line">	boot_jump_linux(images, flag);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p>可以看到 <code>do_bootm_linux</code> 函数 最终调用了  <code>boot_prep_linux</code> 和 <code>boot_jump_linux</code> 两个函数</p>
<br>
<hr />
<p><font face="华文彩云" color=red size=5> 补充：</font></p>
<p>1️⃣   <code>boot_jump_linux</code> 函数</p>
<blockquote>
<p><em><strong>位置 :</strong></em>    <code>arch/arm/lib/bootm.c</code></p>
<p><em><strong>功能 :</strong></em></p>
<blockquote>
<ul>
<li>
<p>保存机器 ID，如果不使用 <em><strong>设备树</strong></em> 的话这个机器 ID 会被传递给 <code>Linux</code> ,  <code>linux</code>内核会查找 是否存在 与这个ID匹配的项目,那么 <code>Linux</code> 内核就会启动  ( 如果使用 <em><strong>设备树</strong></em> 的话 ,这个 ID 就无效了  )</p>
</li>
<li>
<p>调用 <code>kernel_entry</code> 函数进入 <code>Linux</code> 内核</p>
<blockquote>
<ul>
<li>
<p><code>kernel_entry</code> 函数 并不是 uboot 定义的 , 而是Linux 内核定义的 ,  Linux 内核镜像文件的第一行代码就是函数 <code>kernel_entry</code> 函数 , 因此要首先获取  <code>kernel_entry</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_entry = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>, uint))images-&gt;ep;</span><br></pre></td></tr></table></figure>
<ul>
<li>而 <code>images-&gt;ep</code> 保存着 <code>Linux</code> 内核镜像的起始地址 , 起始地址保存的是 <code>Linux</code> 内核的第一行代码</li>
</ul>
</li>
<li>
<p><code>Linux</code> 内核一开始是 <em><strong>汇编代码</strong></em>，因此函数 <code>kernel_entry</code> 就是个汇编函数 , 向汇编函数传递参数要使用 <code>r0、r1 和 r2</code>  <em>(参数数量不超过3个的时候)</em></p>
<blockquote>
<ul>
<li>kernel_entry 函数 有三个参数  <code>zero，arch，params</code></li>
<li>第一个参数  <code>zero</code> 为 0</li>
<li>第二个参数为机器 <code>ID</code></li>
<li>第三个参数 <code>ATAGS</code> 或者 <em><strong>设备树(DTB)</strong></em> 首地址，<code>ATAGS</code> 是传统的方法，用于传递一些命令行信息啥的，如果使用设备树的话就要传递设备树(<code>DTB</code>)。</li>
<li>当使用设备树时 ,  <code>r2</code> 应该是设备树的起始地址，而设备树地址保存在 <code>images</code> 的 <code>ftd_addr</code> 成员变量中</li>
<li>如果不使用设备树的话，<code>r2</code> 应该是 <code>uboot</code> 传递给 <code>Linux</code> 的参数起始地址 , 即 环境变量 <code>bootargs</code> 的值</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">boot_jump_linux</span><span class="params">(<span class="type">bootm_headers_t</span> *images, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> machid = gd-&gt;bd-&gt;bi_arch_number;　　　　　　<span class="comment">//获取机器id (在 board/samsung/jz2440/jz2440.c 中设置，为 MACH_TYPE_SMDK2410(193))</span></span><br><span class="line">    <span class="type">char</span> *s;</span><br><span class="line">    <span class="type">void</span> (*kernel_entry)(<span class="type">int</span> zero, <span class="type">int</span> arch, uint params);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> r2;</span><br><span class="line">    <span class="type">int</span> fake = (flag &amp; BOOTM_STATE_OS_FAKE_GO);</span><br><span class="line"></span><br><span class="line">    kernel_entry = (<span class="type">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>, uint))images-&gt;ep;　　　　<span class="comment">//获取 kernel的入口地址，此处应为 30000000</span></span><br><span class="line"></span><br><span class="line">    s = getenv(<span class="string">&quot;machid&quot;</span>);　　　　　　　　						<span class="comment">//从环境变量里获取机器id　(本例中还未在环境变量里设置过机器 id)</span></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;　　　　　　　　　　　　							<span class="comment">//判断环境变量里是否设置机器id</span></span><br><span class="line">        strict_strtoul(s, <span class="number">16</span>, &amp;machid);　　　　				<span class="comment">//如果设置则用环境变量里的机器id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Using machid 0x%lx from environment\n&quot;</span>, machid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug(<span class="string">&quot;## Transferring control to Linux (at address %08lx)&quot;</span> \</span><br><span class="line">        <span class="string">&quot;...\n&quot;</span>, (ulong) kernel_entry);</span><br><span class="line">    bootstage_mark(BOOTSTAGE_ID_RUN_OS);</span><br><span class="line">    announce_and_cleanup(fake);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IMAGE_ENABLE_OF_LIBFDT &amp;&amp; images-&gt;ft_len)</span><br><span class="line">        r2 = (<span class="type">unsigned</span> <span class="type">long</span>)images-&gt;ft_addr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r2 = gd-&gt;bd-&gt;bi_boot_params;　　　				　<span class="comment">//获取 tag参数地址，gd-&gt;bd-&gt;bi_boot_params在 setup_start_tag 函数里设置</span></span><br><span class="line"><span class="keyword">if</span> (!fake) kernel_entry(<span class="number">0</span>, machid, r2); &#125;　			　<span class="comment">//进入内核</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="23224-补充"><a class="markdownIt-Anchor" href="#23224-补充"></a> 2.3.2.2.4 补充</h6>
<p>1️⃣  内核镜像格式<code>vmlinuz</code>和<code>zImage</code>和<code>uImage</code></p>
<ul>
<li>
<p><code>uboot</code>经过编译直接生成的elf格式的可执行程序是<code>u-boot</code>，这个程序类似于<code>windows</code>下的<code>exe</code>格式，在操作系统下是可以直接执行的。但是这种格式不能用来烧录下载。我们用来烧录下载的是<code>u-boot.bin</code>，这个东西是由<code>u-boot</code>使用<code>arm-linux-objcopy</code>工具进行加工（主要目的是去掉一些无用的）得到的。这个<code>u-boot.bin</code>就叫 <em><strong>镜像（image）</strong></em> ，镜像就是用来烧录到 <code>EMMC</code> 中执行的。</p>
</li>
<li>
<p><code>linux</code>内核经过编译后也会生成一个<code>elf</code>格式的可执行程序，叫<code>vmlinux</code>或<code>vmlinuz</code>，这个就是原始的  <em><strong>未经任何处理加工</strong></em> 的原版内核<code>elf</code>文件；嵌入式系统部署时烧录的一般不是这个<code>vmlinuz/vmlinux</code>，而是要用<code>objcopy</code>工具去制作成烧录镜像格式（就是<code>u-boot.bin</code>这种，但是内核没有<code>.bin</code>后缀），经过制作加工成烧录镜像的文件就叫<code>Image</code>（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</p>
</li>
<li>
<p>原则上<code>Image</code>就可以直接被烧录到<code>Flash</code>上进行启动执行（类似于<code>u-boot.bin</code>），但是实际上并不是这么简单。实际上<code>linux</code>的作者们觉得<code>Image</code>还是太大了所以对<code>Image</code>进行了压缩，并且在<code>image</code>压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫<code>zImage</code>。</p>
</li>
<li>
<p><code>uboot</code>为了启动<code>linux</code>内核，还发明了一种内核格式叫<code>uImage</code>。<code>uImage</code>是由<code>zImage</code>加工得到的，<code>uboot</code>中有一个工具，可以将<code>zImage</code>加工生成<code>uImage</code>。注意：<code>uImage</code>不关<code>linux</code>内核的事，<code>linux</code>内核只管生成<code>zImage</code>即可，然后<code>uboot</code>中的<code>mkimage</code>工具再去由<code>zImage</code>加工生成<code>uImage</code>来给<code>uboot</code>启动。这个加工过程其实就是在<code>zImage</code>前面加上<code>64</code>字节的<code>uImage</code>的 <em><strong>头信息</strong></em> 即可。</p>
</li>
<li>
<p>原则上<code>uboot</code>启动时应该给他<code>uImage</code>格式的内核镜像，但是实际上<code>uboot</code>中也可以支持<code>zImage</code>，是否支持就看x210_sd.h中是否定义了<code>LINUX_ZIMAGE_MAGIC</code>这个宏。可以看出：有些<code>uboot</code>是支持<code>zImage</code>启动的，有些则不支持。但是所有的<code>uboot</code>肯定都支持<code>uImage</code>启动。</p>
</li>
<li>
<p>如果直接在<code>kernel</code>底下去<code>make uImage</code>会提供<code>mkimage command not found</code>。解决方案是去<code>uboot/tools</code>下<code>cp mkimage</code> <code>/usr/local/bin/</code>，复制<code>mkimage</code>工具到系统目录下。再去<code>make uImage</code>即可。</p>
</li>
<li>
<p>因此如果通过<code>uboot</code>启动内核，<code>Linux</code>必须为<code>uImage</code>格式 ( 或部分支持<code>zImage</code>)。</p>
</li>
</ul>
<br>
<hr />
<p>2️⃣ <em><strong>给内核传递参数</strong></em></p>
<p><em><strong>怎么从<code>uboot</code> 跳转 内核启动</strong></em></p>
<blockquote>
<p>只要 <em><strong>直接修改PC寄存器的值为Linux内核所在的地址</strong></em> , 这样CPU就会从内核所在的地址 去取指令 , 从而执行内核代码</p>
</blockquote>
<p><em><strong>为什么要给内核传递参数呢？</strong></em></p>
<blockquote>
<p>在 <code>uboot</code>启动的第一阶段 , <code>uboot</code> 基本完成了 硬件的初始化 , 但内核 对于此时 开发板的环境 一无所知 , 所以要启动 <code>Linux</code> 内核 , <code>uboot</code> 必须要给 内核传递一些必要的信息 , 来告知内核 <em><strong>当前所处的环境</strong></em></p>
</blockquote>
<br>
<p><em><strong>如何给内核传递参数</strong></em></p>
<blockquote>
<ul>
<li><code>uboot</code> 通过寄存器 <code>r0、r1 和 r2</code> 将参数传递给内核</li>
</ul>
<p><em><strong>例如</strong></em></p>
<ul>
<li><code>uboot</code>把 <em><strong>机器ID通过R1传递给内核</strong></em> ，<code>Linux</code>内核运行的时候，首先就从<code>R1</code>中读取机器<code>ID</code>来判断是否支持当前机器。这个机器ID实际上就是开发板 <em><strong>CPU的ID</strong></em>，每个厂家生产出一款<code>CPU</code>的时候都会给它指定一个唯一的<code>ID</code> ( 当然使用设备树的话,  情况会有所不同)</li>
<li></li>
<li>*<strong>R2存放的是块内存的基地址</strong>  ，这块内存中存放的是<code>uboot</code>给<code>Linux</code>内核的其他参数。这些参数有内存的 <em><strong>起 始地址、内存大小、    Linux    内核启动后挂载文件系统的方式等信息</strong></em>  。很明显，参数有多个，不同的参数有不同的内容，为了让<code>Linux</code>内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时候需要  <em><strong>按照双方规定的格式存放</strong></em></li>
</ul>
</blockquote>
<br>
<hr />
<p>3️⃣ <em><strong>参数结构</strong></em></p>
<blockquote>
<ul>
<li>在 uboot 和 内核传递参数的过程中 ,  <strong>除了约定好参数存放的地址外，还要规定参数的结构</strong>。Linux2.4.x以后的内核都期望以<strong>标记列表</strong> <code>（tagged_list）</code>的形式来传递启动参数。</li>
<li>标记，就是一种数据结构；标记列表，就是挨着存放的多个标 记。标记列表以标记 <code>ATAG_CORE</code> 开始，以标记 <code>ATAG_NONE</code> 结束。</li>
</ul>
</blockquote>
<br>
<p><em><strong>标记数据结构 <code>tag</code></strong></em></p>
<blockquote>
<p>标记的数据结构为<code>tag</code>，它由一个<code>tag_header</code>结构和一个联合（<code>union</code>）组成。<code>tag_header</code>结构表示标记的 <em><strong>类型及长度</strong></em>，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的  <em><strong>联合（union）</strong></em> ，比如表示内存时使用<code>tag_mem32</code>，表示命令行时使用 <code>tag_cmdline</code>。 (  具体见 <code>arch\arm\include\asm\setup.h</code> )</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tag_header</span> <span class="title">hdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_core</span>		<span class="title">core</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_mem32</span>	<span class="title">mem</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_videotext</span>	<span class="title">videotext</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_ramdisk</span>	<span class="title">ramdisk</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_initrd</span>	<span class="title">initrd</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_serialnr</span>	<span class="title">serialnr</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_revision</span>	<span class="title">revision</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_videolfb</span>	<span class="title">videolfb</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_cmdline</span>	<span class="title">cmdline</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Acorn specific</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_acorn</span>	<span class="title">acorn</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * DC21285 specific</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tag_memclk</span>	<span class="title">memclk</span>;</span></span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>可以看出 :</strong></em></p>
<ul>
<li><code>struct_tag</code>结构体由<code>struct tag_header+联合体union</code>构成</li>
<li>结构体<code>struct tag_header</code>用来描述每个<code>tag</code>的头部信息，如<code>tag</code>的 <em><strong>类型</strong></em> ，<code>tag</code>的 <em><strong>大小</strong></em></li>
<li>联合体<code>union</code>用来描述每个传递给<code>Linux</code>内核的 <em><strong>参数信息</strong></em>。</li>
</ul>
</blockquote>
<br>
<hr />

    </div>

    
    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------已经到底啦！ <i class="fa fa-paw"></i>-------------</div>
    
</div>

  
</div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> 单片机</a>
              <a href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> c语言</a>
              <a href="/tags/arm/" rel="tag"><i class="fa fa-tag"></i> arm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/05/12/Linux%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E2%80%94%E2%80%94%20%E6%9D%82%E9%A1%B9/" rel="prev" title="Linux 学习笔记(一) —— 杂项">
                  <i class="fa fa-chevron-left"></i> Linux 学习笔记(一) —— 杂项
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/06/02/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E2%80%94%E2%80%94%20%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84/" rel="next" title="IMX6ULL学习笔记(一) —— 寄存器组">
                  IMX6ULL学习笔记(一) —— 寄存器组 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">




<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yezhaotin</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->


<!-- <br /> -->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<!-- <span id="times">载入时分秒...</span> -->
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("4/6/2023 8:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); 
        if(String(snum).length ==1 ){snum = "0" + snum;}
        // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ye2020" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" integrity="sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8=" crossorigin="anonymous">





<script type="text/javascript"
    count="150"
    opacity: 1
    src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":250,"height":400,"position":"lift","hOffset":150,"vOffset":-30},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>

</html>


  <!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>