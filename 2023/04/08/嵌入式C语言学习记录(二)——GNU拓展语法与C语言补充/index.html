<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"right","width":300,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="version :    v1.0      「2022.9.11」   最后补充 author：  Y.Z.T.  摘要： 记录汇总自己在嵌入式开发过程中 学习的一些零散知识 简介:  简单汇总,方便自己查看">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充">
<meta property="og:url" content="http://example.com/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/index.html">
<meta property="og:site_name" content="Y.Z.T">
<meta property="og:description" content="version :    v1.0      「2022.9.11」   最后补充 author：  Y.Z.T.  摘要： 记录汇总自己在嵌入式开发过程中 学习的一些零散知识 简介:  简单汇总,方便自己查看">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea18f16f2c2beb1c15734.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea19516f2c2beb1c16403.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/64311ac50d2dde577739895b.webp">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea19c16f2c2beb1c16d0d.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1a916f2c2beb1c1806c.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1b016f2c2beb1c18a66.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1b616f2c2beb1c1914d.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1bc16f2c2beb1c19b07.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1c316f2c2beb1c1a38f.png">
<meta property="og:image" content="https://pic.imgdb.cn/item/632ea1e216f2c2beb1c1c7ed.png">
<meta property="article:published_time" content="2023-04-08T07:16:44.000Z">
<meta property="article:modified_time" content="2023-05-12T07:02:36.239Z">
<meta property="article:author" content="yezhaotin">
<meta property="article:tag" content="c语言">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="单片机">
<meta property="article:tag" content="gun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/632ea18f16f2c2beb1c15734.png">


<link rel="canonical" href="http://example.com/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/","path":"2023/04/08/嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充/","title":"嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充 | Y.Z.T</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>


</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Y.Z.T</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4%EF%B8%8F%E2%83%A3-gnu-%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95"><span class="nav-text"> 4️⃣ GNU 拓展语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text"> 4.1 指定初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 4.2  语句表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#421-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-text"> 4.2.1 使用实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-typeof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text"> 4.3   typeof关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-container_of%E5%AE%8F"><span class="nav-text"> 4.4  container_of宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#441-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-text"> 4.4.1 结构体的储存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#442-container_of%E5%AE%8F%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 4.4.2  container_of宏实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4421-type-0-member-%E8%A7%A3%E6%9E%90"><span class="nav-text"> 4.4.2.1 (((type *)0)-&gt;member) 解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4422-const-typeof-type-0-member-_mptr-ptr"><span class="nav-text"> 4.4.2.2 const typeof( ((type *)0)-&gt;member ) *_mptr &#x3D; (ptr);</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4423-offsetoftype-member"><span class="nav-text"> 4.4.2.3 offsetof(TYPE, MEMBER)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4424-type-char-_mptr-offsetoftype-member"><span class="nav-text"> 4.4…2.4  (type *)((char *)_mptr - offsetof(type, member) );</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#445-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-text"> 4.4.5 使用实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E9%9B%B6%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84"><span class="nav-text"> 4.6  零长度数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-__attribute__-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text"> 4.7  __attribute__  关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#471-%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="nav-text"> 4.7.1 变量属性说明’</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4711-%E5%B1%9E%E6%80%A7-section"><span class="nav-text"> 4.7.1.1 属性: section</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4712-%E5%B1%9E%E6%80%A7-aligned"><span class="nav-text"> 4.7.1.2 属性: aligned</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4713-%E5%B1%9E%E6%80%A7packed"><span class="nav-text"> 4.7.1.3 属性：packed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4714-%E5%B1%9E%E6%80%A7-deprecated"><span class="nav-text"> 4.7.1.4 属性: deprecated</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#472-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="nav-text"> 4.7.2 函数属性说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4721-%E5%B1%9E%E6%80%A7-format"><span class="nav-text"> 4.7.2.1 属性 : format</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#47211-%E6%8B%93%E5%B1%95-%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 4.7.2.1.1 拓展 ——变参函数的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#47212-%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-text"> 4.7.2.1.2 变参函数的优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#47213-%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 4.7.2.1.3  简单日志打印函数的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#47214-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96"><span class="nav-text"> 4.7.2.1.4  日志打印函数优化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4722-%E5%B1%9E%E6%80%A7-weak"><span class="nav-text"> 4.7.2.2 属性:  weak</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4723-%E5%B1%9E%E6%80%A7-alias"><span class="nav-text"> 4.7.2.3 属性 : alias</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4724-%E5%B1%9E%E6%80%A7-noinline-always_inline"><span class="nav-text"> 4.7.2.4 属性:  noinline &amp; always_inline</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#473-%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="nav-text"> 4.7.3 类型属性说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-text"> 4.8  内建函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#481-__builtin_return_addresslevel"><span class="nav-text"> 4.8.1   __builtin_*return_*address(LEVEL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#482-__builtin_constant_pexp"><span class="nav-text"> 4.8.2 __builtin_constant_p(EXP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#483-__builtin_expectexpc"><span class="nav-text"> 4.8.3 __builtin_expect(exp,c)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F"><span class="nav-text"> 4.9 可变参数宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#491-%E6%8B%93%E5%B1%95-%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="nav-text"> 4.9.1 拓展 —— 宏定义中的特殊符号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#492-%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E7%AC%A6%E5%AF%B9%E5%AE%8F%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="nav-text"> 4.9.2 通过##连接符对宏进行优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%EF%B8%8F%E2%83%A3-c%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85"><span class="nav-text"> 5️⃣ C语言补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F"><span class="nav-text"> 5.1 内联函数与宏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#511-%E5%AE%8F%E4%B8%8E%E5%B8%A6%E5%8F%82%E5%AE%8F"><span class="nav-text"> 5.1.1 宏与带参宏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5111-%E5%B8%A6%E5%8F%82%E5%AE%8F"><span class="nav-text"> 5.1.1.1 带参宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5112-%E6%80%BB%E7%BB%93"><span class="nav-text"> 5.1.1.2 总结：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#512-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text"> 5.1.2  内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5121-%E5%AE%9A%E4%B9%89"><span class="nav-text"> 5.1.2.1 定义：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#513-%E5%AE%8F%E4%B8%8E%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text"> 5.1.3 宏与内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5131-%E6%80%BB%E7%BB%93"><span class="nav-text"> 5.1.3.1 总结：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#514%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8static%E4%BF%AE%E9%A5%B0"><span class="nav-text"> 5.1.4内联函数为什么用static修饰</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="nav-text"> 5.2 预定义宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-pragma"><span class="nav-text"> 5.3 #pragma</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#531-pragma-packn"><span class="nav-text"> 5.3.1  #pragma pack(n)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5311-pragma-pack-%E5%92%8C-__attribute__packed-%E5%92%8C-__attribute__aligned"><span class="nav-text"> 5.3.1.1 #pragma pack 和  __attribute__(packed) 和 __attribute__(aligned)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#532-pragma-message"><span class="nav-text"> 5.3.2  #pragma message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#533-pragma-once"><span class="nav-text"> 5.3.3  #pragma once</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-assert%E6%96%AD%E8%A8%80"><span class="nav-text"> 5.4  assert断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-%E5%85%B1%E7%94%A8%E4%BD%93-union"><span class="nav-text"> 5.5 共用体 union</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#551-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-text"> 5.5.1  数据传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#552-%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text"> 5.5.2 管理状态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#553-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%86%E5%88%86%E7%BB%84%E5%90%88"><span class="nav-text"> 5.5.3 数据的拆分组合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-const%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text"> 5.6 const关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#561%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text"> 5.6.1修饰局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#562%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-text"> 5.6.2常量指针与指针常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#563-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text"> 5.6.3 修饰函数的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#564-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text"> 5.6.4 修饰函数的返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#565-%E4%BF%AE%E9%A5%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text"> 5.6.5 修饰全局变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-staic%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text"> 5.7 staic关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#571-static%E5%AE%9A%E4%B9%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text"> 5.7.1 static定义局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5711-%E8%A1%A5%E5%85%85-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="nav-text"> 5.7.1.1 补充 —— 内存空间分布</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#572-static%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text"> 5.7.2 static定义全局变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#573-static%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-text"> 5.7.3 static定义函数</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yezhaotin"
      src="/images/photo.jpg">
  <p class="site-author-name" itemprop="name">yezhaotin</p>
  <div class="site-description" itemprop="description">呜呜呜</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ye2020" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ye2020" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yezhaotin@outlook.com" title="E-Mail → mailto:yezhaotin@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%BA%8C)%E2%80%94%E2%80%94GNU%E6%8B%93%E5%B1%95%E8%AF%AD%E6%B3%95%E4%B8%8EC%E8%AF%AD%E8%A8%80%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photo.jpg">
      <meta itemprop="name" content="yezhaotin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Y.Z.T">
      <meta itemprop="description" content="呜呜呜">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充 | Y.Z.T">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          嵌入式C语言学习记录(二)——GNU拓展语法与C语言补充
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-08 15:16:44" itemprop="dateCreated datePublished" datetime="2023-04-08T15:16:44+08:00">2023-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-12 15:02:36" itemprop="dateModified" datetime="2023-05-12T15:02:36+08:00">2023-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <br>
<blockquote>
<p><strong>version :</strong>    <em>v1.0</em>      <em>「2022.9.11」</em>   最后补充</p>
<p><strong>author：</strong>  <em>Y.Z.T.</em><br />
<br></p>
<p><strong>摘要：</strong> 记录汇总自己在嵌入式开发过程中 学习的一些零散知识</p>
<p><strong>简介:</strong>  简单汇总,方便自己查看</p>
</blockquote>
<br>
<span id="more"></span>
<p>(👇 第一部分)<br />
<a target="_blank" rel="noopener" href="https://ye2020.github.io/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%E2%80%94%E2%80%94ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/#more">嵌入式C语言学习记录(一) —— ARM指令集与作用域</a><br />
(👇 pdf  版)<br />
<a target="_blank" rel="noopener" href="https://download.csdn.net/download/weixin_51330198/86701430?spm=1001.2014.3001.5501">pdf文件</a></p>
<br>
<hr />
<br>
<hr />
<br>
<h2 id="4️⃣-gnu-拓展语法"><a class="markdownIt-Anchor" href="#4️⃣-gnu-拓展语法"></a> 4️⃣ GNU 拓展语法</h2>
<blockquote>
<ul>
<li>ANSIC(C89)、(C99)、(C11)表示的是C语言标准</li>
<li><strong>GNU拓展语法</strong>是GUN编译器对C语言标准的拓展</li>
</ul>
</blockquote>
<br>
<h3 id="41-指定初始化"><a class="markdownIt-Anchor" href="#41-指定初始化"></a> 4.1 指定初始化</h3>
<p><code>GNU C</code> 支持指定初始化<strong>数组元素</strong>和 <strong>结构体成员</strong></p>
<p><font face="华文彩云" color=red size=5>初始化数组元素示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">10</span>] = <span class="number">1</span>,[<span class="number">30</span>] = <span class="number">2</span>&#125;;				<span class="comment">// 给指定几个元素初始化</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">100</span>] = &#123;[<span class="number">10</span> ... <span class="number">30</span>] = <span class="number">1</span>,[<span class="number">40</span> ... <span class="number">60</span>] = <span class="number">2</span>&#125;; <span class="comment">// 给某个索引范围的数组元素初始化</span></span><br></pre></td></tr></table></figure>
<br>
<blockquote>
<p><code>GNU C</code> 支持使用 <code>…</code> 表示范围拓展 , 不仅可以使用在<strong>数组初始化</strong>中 , 也可以使用在<code>switch-case</code> 中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> ... <span class="number">4</span>:</span><br><span class="line">            <span class="comment">/* do something */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        	</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>初始化结构体成员示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;<span class="type">test_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">test_t</span> test1 = &#123;<span class="string">&quot;name1&quot;</span>,<span class="number">10</span>&#125;;		<span class="comment">// C语言标准初始化方式(即固定顺序直接初始化)</span></span><br><span class="line">	</span><br><span class="line">    <span class="type">test_t</span> test2 = 						<span class="comment">// GNU C初始化方式(直接通过结构域名.name和.age,给结构体变量的某一个指定成员直接赋值)</span></span><br><span class="line">    &#123;</span><br><span class="line">        .name = <span class="string">&quot;name2&quot;</span>,</span><br><span class="line">        .age  =<span class="number">20</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h3 id="42-语句表达式"><a class="markdownIt-Anchor" href="#42-语句表达式"></a> 4.2  语句表达式</h3>
<ul>
<li>
<p><strong>表达式:</strong>   <em>表达式就是由一系列操作符和操作数构成的式子。</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i++ + <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>语句 :</strong>  在表达式后加一个 <code>;</code>  就构成了一条基本语句 ,  <code>;</code> 表示一条语句的结束</p>
</li>
<li>
<p><strong>语句表达式 :</strong></p>
<ul>
<li>GNU C对C语言标准作了扩展,允许在一个表达式里内嵌语句;</li>
<li>允许在表达式内部使用局部变量、for循环和goto跳转语句;</li>
</ul>
<br>
<p><strong>语句表达式格式:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;表达式<span class="number">1</span> ; 表示<span class="number">2</span> ; 表达式<span class="number">3</span> ;&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>语句表达式 <strong>最外面使用小括号<code>( )</code></strong> 括起来,里面一对 <strong>大括号<code>&#123; &#125;</code></strong> 包起来的是代码块,</li>
<li>代码块里允许内嵌各种语句。语句的格式可以是一般表达式,也可以是循环、跳转语句。</li>
<li>语句表达式的值为内嵌语句中<strong>最后一个表达式的值</strong>。</li>
</ul>
</blockquote>
</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<p>使用语句表达式求值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = </span><br><span class="line">   (&#123;</span><br><span class="line">       <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">           s = s + i;</span><br><span class="line">       	   s;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>在上面的程序中,通过语句表达式实现了从1到10的累加求和</li>
<li>因为语句表达式的值等于最后一个表达式的值,所以在for循环的后面,我们要添加一个<code>s</code>;</li>
<li><code>s</code>语句表示整个语句表达式的值 , 如果不加这一句,结果是<code>sum=0</code>。</li>
<li>如果将这一行语句改为<code>100</code>,最后<code>sum</code>的值就变成了100,这是因为语句表达式的值总等于<strong>最后一个表达式的值</strong>.</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="421-使用实例"><a class="markdownIt-Anchor" href="#421-使用实例"></a> 4.2.1 使用实例</h4>
<blockquote>
<ul>
<li>语句表达式的主要用途在于定义功能复杂的宏。</li>
<li>使用语句表达式来定义宏,不仅可以实现复杂的功能,还能避免宏定义带来的歧义和漏洞。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<p>定义一个宏 , 求两个数的最大值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ANSIC */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))	<span class="comment">// 经典宏陷阱 , 在 MAX(i++ , j++); 时会出现累加两次问题</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GNU C */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (&#123;		\				<span class="comment">// 在语句表达式中定义两个临时变量,分别来暂时存储i和j的值,然后使用临时变量进行比较</span></span></span><br><span class="line">		<span class="type">int</span> _x = x;			\				<span class="comment">// 这样就避免了两次自增、自减问题。</span></span><br><span class="line">		<span class="type">int</span> _y = y;			\</span><br><span class="line">		_x &gt; _y ? _x : _y;	\</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* GNU C 优化*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>   max(x,y) (&#123;		\</span></span><br><span class="line"><span class="meta">    	typeof(x) _x = (x); \				<span class="comment">// typeof 关键字是GNUC 拓展的,用于获取一个变量或表达式的类型</span></span></span><br><span class="line">    	typeof(x) _y = (y); \				<span class="comment">// 使用typeof关键字来自动获取宏的 两个参数类型</span></span><br><span class="line">    	(<span class="type">void</span>)(&amp;_x == &amp;_y);	\</span><br><span class="line">    	_x &gt; _y ? _x : _y;	\</span><br><span class="line">&#125;)   </span><br></pre></td></tr></table></figure>
<p><font face="华文彩云" color=red size=5>备注：</font>  <strong>为什么存在 <code>(void) (&amp;_x == &amp;_y);</code>  这个看似很多余的语句</strong></p>
<blockquote>
<p>它的作用有两个 :</p>
<ul>
<li>一是用来给用户提示一个警告,对于不同类型的指针比较,编译器会发出一个警告,提示两种数据的类型不同。</li>
<li>二是两个数进行比较运算 , 运算的结果却没有用到,有些编译器可能会给出一个<code>warning</code>,加一个<code>(void)</code>后,就可以消除这个警告。</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="43-typeof关键字"><a class="markdownIt-Anchor" href="#43-typeof关键字"></a> 4.3   <code>typeof</code>关键字</h3>
<blockquote>
<ul>
<li><code>typeof</code>是<code>GNU C</code>扩展的一个关键字 , 用来获取一个变量或表达式的类型。</li>
<li>使用<code>typeof</code>可以获取一个变量或表达式的类型。<code>typeof</code>的参数有两种形式 : <strong>表达式</strong>或<strong>类型</strong>。</li>
</ul>
</blockquote>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">typeof(i) j = <span class="number">20</span>;		<span class="comment">// typeof(i) 就等于int, typeof(i)j=20 就相当于int j=20,</span></span><br><span class="line">typeof(<span class="type">int</span> *) a;		<span class="comment">//  typeof(int*)a;相当于int*a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;				<span class="comment">// f()函数的返回值类型是int,</span></span><br><span class="line">typeof(f()) k;			<span class="comment">// typeof(f())k ; 就相当于int k;</span></span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>其他用法：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof (<span class="type">int</span> *) y;				<span class="comment">//把y定义为指向int类型的指针,相当于int *y;</span></span><br><span class="line">typeof (<span class="type">int</span>) *y;				<span class="comment">//定义一个执行int类型的指针变量y</span></span><br><span class="line">typeof (*x) y;					<span class="comment">//定义一个指针x所指向类型的指针变量y</span></span><br><span class="line">typeof (<span class="type">int</span>) y[<span class="number">4</span>];				<span class="comment">//相当于定义一个int y[4]</span></span><br><span class="line">typeof (*x) y[<span class="number">4</span>];				<span class="comment">//把y定义为指针x指向的数据类型的数组</span></span><br><span class="line">typeof (typeof (<span class="type">char</span> *)[<span class="number">4</span>]) y;	<span class="comment">//相当于定义字符指针数组 char *y[4];</span></span><br><span class="line">typeof (<span class="type">int</span> x[<span class="number">4</span>]) y; 			<span class="comment">//相当于定义 int y[4]</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h3 id="44-container_of宏"><a class="markdownIt-Anchor" href="#44-container_of宏"></a> 4.4  container_of宏</h3>
<blockquote>
<p><strong>作用 :</strong>  根据结构体某一成员的地址,获取这个<mark>结构体的首地址</mark>。</p>
<p><strong>实现原理 :</strong></p>
<ul>
<li>结构体中各个成员的地址在数值上等于结构体各成员相对于<strong>结构体首地址的偏移</strong>。</li>
<li>直接用结构体成员的地址 , 减去该成员在结构体内的偏移,就可以得到该结构体的首地址了。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>宏定义原型：</font></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea18f16f2c2beb1c15734.png" alt="image-20220912130718233" /></p>
<br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) 	(&#123; 					\											\</span></span><br><span class="line"><span class="meta">		const typeof( ((type *)0)-&gt;member ) *_mptr = (ptr);		\</span></span><br><span class="line"><span class="meta">		(type *)((char *)_mptr - offsetof(type, member) );	&#125;)</span></span><br></pre></td></tr></table></figure>
<p>可以看到这个宏有<strong>三个参数:</strong></p>
<ul>
<li><code>type</code>为结构体类型;</li>
<li><code>member</code>为结构体内的成员;</li>
<li><code>ptr</code>为结构体内成员<code>member</code>的地址。</li>
</ul>
<br>
<hr />
<br>
<h4 id="441-结构体的储存空间"><a class="markdownIt-Anchor" href="#441-结构体的储存空间"></a> 4.4.1 结构体的储存空间</h4>
<p><span id="two" name="two"></span></p>
<p><strong>编译器</strong>在给一个<strong>结构体变量</strong>分配储存空间时,有以下特点:</p>
<ul>
<li>根据每个成员的<strong>数据类型</strong>和<strong>字节对齐方式</strong>,编译器会按照结构体中各个成员的顺序,在内存中分配<strong>一片连续的空间</strong>来存储它们</li>
<li>结构体中的<strong>每个成员变量</strong>,从结构体首地址开始依次存放,每个成员变量相对于结构体首地址,都有一个<strong>固定偏移</strong>。</li>
<li>在<strong>同一个编译环境</strong>下 , 各个成员相对于结构体首地址的<strong>偏移是固定不变</strong>的 . (当然 使用<code>#pragma pack(x)</code> 或 <code>typedef __packed struct</code> 改变字节对齐方式 ,同时也会改变地址编译 )</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">//暂且将链表放在结构体的第一位</span></span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    <span class="type">int</span> math;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct student</code> 的<mark>地址偏移</mark></p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea19516f2c2beb1c16403.png" alt="image-20220912134256201" style="zoom: 80%;" />
<br>
<p><font face="华文彩云" color=red size=5>示例2：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> 				//  <span class="title">A</span> 对齐为 4 ，大小为 16</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">int</span> a;				<span class="comment">// a 偏移为 0 </span></span><br><span class="line">    <span class="type">char</span> b;				<span class="comment">// b 偏移为 4</span></span><br><span class="line">    <span class="type">int</span> c; 				<span class="comment">// c 偏移为 8（大于 4 + 1 的 4 的最小整数倍）</span></span><br><span class="line"> 	<span class="type">char</span> d; 			<span class="comment">//  d 偏移为 12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">char</span> a1; 			<span class="comment">// a1偏移为 0</span></span><br><span class="line">    <span class="type">int</span> a2; 			<span class="comment">// a2移为 4</span></span><br><span class="line">    <span class="type">char</span> a3; 			<span class="comment">// a3移为 8</span></span><br><span class="line">    <span class="type">short</span> a4; 			<span class="comment">// a4移为 10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct B</code>  的<mark>地址偏移</mark></p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/64311ac50d2dde577739895b.webp" alt="在这里插入图片描述" style="zoom:80%;" />
<br>
<blockquote>
<p><strong>可以看到 ：</strong></p>
<ul>
<li>结构体中成员变量在内存中存储的其实是<strong>偏移地址</strong></li>
<li>也就是说<strong>结构体A的地址+成员变量的偏移地址 = 结构体成员变量的起始地址</strong></li>
<li>因此，可以根据结构体变量的起始地址和成员变量的偏移地址来反推出结构体A的地址。</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="442-container_of宏实现"><a class="markdownIt-Anchor" href="#442-container_of宏实现"></a> 4.4.2  <code>container_of</code>宏实现</h4>
<h5 id="4421-type-0-member-解析"><a class="markdownIt-Anchor" href="#4421-type-0-member-解析"></a> 4.4.2.1 <code>(((type *)0)-&gt;member)</code> 解析</h5>
<p><font face="华文彩云" color=red size=5>测试代码：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;age=%p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;num = %p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;math= %p\n&quot;</span>, &amp;((<span class="keyword">struct</span> student*)<span class="number">0</span>)-&gt;math);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>运行结果：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;age = <span class="number">00000000</span></span><br><span class="line">&amp;math= <span class="number">00000004</span> </span><br><span class="line">&amp;num = <span class="number">00000008</span></span><br></pre></td></tr></table></figure>
<p><strong>如上所示:</strong></p>
<blockquote>
<ul>
<li><code>((TYPE *)0)</code>将0转换为type类型的结构体指针 (即转换为一个指向结构体类型为<code>student</code>的常量指针)</li>
<li>因为常量指针的值为0,即可以看作结构体<strong>首地址为0</strong></li>
<li>所以结构体中每个<strong>成员变量的地址</strong>即该成员相对于结构体<strong>首地址的偏移</strong>。</li>
<li><code>(((type *)0)-&gt;member)</code> 引用结构体中<code>MEMBER</code>成员。</li>
</ul>
</blockquote>
<br>
<hr />
<h5 id="4422-const-typeof-type-0-member-_mptr-ptr"><a class="markdownIt-Anchor" href="#4422-const-typeof-type-0-member-_mptr-ptr"></a> 4.4.2.2 const typeof( ((type *)0)-&gt;member ) *_mptr = (ptr);</h5>
<p><strong>这句代码意思是:</strong></p>
<ul>
<li>
<p>用<code>typeof()</code>获取结构体里<code>member</code>成员属性的类型，</p>
</li>
<li>
<p><code>typeof( ((type *)0)-&gt;member )</code> 表达式使用<code>typeof</code>关键字 ,来获取结构体成员 <code>MEMBER</code>的数据类型</p>
</li>
<li>
<p>然后定义一个该类型的<strong>临时指针变量<code>__mptr</code></strong>， 用来储存宏中参数<code>ptr</code>的值</p>
</li>
<li>
<p>并将<code>ptr</code>所指向的<code>member</code>的<strong>地址</strong>赋给<code>__mptr</code>；</p>
</li>
<li>
<p>因为结构体成员的数据类型可以是任何数据类型 , 为了让这个宏兼容各种数据类型 , 所以定义了一个临时指针变量<code>__mptr</code></p>
</li>
</ul>
<br>
<hr />
<h5 id="4423-offsetoftype-member"><a class="markdownIt-Anchor" href="#4423-offsetoftype-member"></a> 4.4.2.3 <code>offsetof(TYPE, MEMBER)</code></h5>
<blockquote>
<p><strong>作用 :</strong>  这个宏的作用就是求出 <code>MEMBER</code>相对于0地址的一个偏移值。</p>
<p><strong>原理 :</strong>　将0强制转换为一个指向<code>TYPE</code>类型的结构体常量指针 , 然后通过这个常量指针访问成员,获取成员<code>MEMBER</code>的地址, 其大小在数值上等于<code>MEMBER</code>成员在结构体<code>TYPE</code>中的偏移</p>
</blockquote>
<br>
<p>可以看到这个宏有<strong>两个参数:</strong></p>
<ul>
<li><code>TYPE</code>为结构体类型;</li>
<li><code>MEMBER</code>为结构体<code>TYPE</code>内的成员;</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<p><code>size_t</code>是标准C库中定义的，在32位架构中被普遍定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<p>而在64位架构中被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">size_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使程序有很好的移植性，因此内核使用<code>size_t</code>和，而不是<code>int</code>，<code>unsigned</code>。</p>
</blockquote>
<br>
<hr />
<h5 id="4424-type-char-_mptr-offsetoftype-member"><a class="markdownIt-Anchor" href="#4424-type-char-_mptr-offsetoftype-member"></a> 4.4…2.4  <code>(type *)((char *)_mptr - offsetof(type, member) );</code></h5>
<br>
<p><strong>这句代码的意思是:</strong></p>
<ul>
<li>取结构体某个成员<code>member</code>的地址,减去这个成员在结构体type中的偏移,得到结构体<code>type</code>的首地址。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ul>
<li>把 <code>__mptr</code> 转换成 <code>char *</code> 类型， 因为 <strong><code>offsetof</code>宏</strong> 得到的偏移量是以字节为单位。</li>
<li>在语句表达式的最后  因为返回的是结构体的首地址 , 所以整个地址还必须强制转换一下,转换为<code>TYPE *</code></li>
<li>即返回一个指向 <strong><code>TYPE</code>结构体类型</strong>的<strong>指针</strong>,所以最后一个表达式中会出现一个强制类型转换<code>(TYPE *)</code></li>
</ul>
<br>
<hr />
<h4 id="445-使用实例"><a class="markdownIt-Anchor" href="#445-使用实例"></a> 4.4.5 使用实例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        Student stu;						<span class="comment">// 定义结构体类型变量</span></span><br><span class="line">        Student *sptr = <span class="literal">NULL</span>;</span><br><span class="line">        stu.id = <span class="number">123456</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(stu.name,<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">        stu.math = <span class="number">90</span>;</span><br><span class="line">    </span><br><span class="line">        sptr = container_of(&amp;stu.id,Student,id);</span><br><span class="line">   	<span class="comment">/*  宏展开为 */</span></span><br><span class="line">    <span class="comment">//  sptr = (&#123; const unsigned char  *__mptr = (&amp;stu.id); </span></span><br><span class="line">    <span class="comment">//            (Student *)( (char *)__mptr - ((size_t) &amp;((Student *)0)-&gt;id) );&#125;);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">    </span><br><span class="line">        sptr = container_of(&amp;stu.name,Student,name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">        sptr = container_of(&amp;stu.math,Student,id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sptr=%p\n&quot;</span>,sptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h3 id="46-零长度数组"><a class="markdownIt-Anchor" href="#46-零长度数组"></a> 4.6  零长度数组</h3>
<p>零长度数组定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>它的特点是 <strong>不占用内存存储空间</strong></p>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">0</span>];		</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>int a[0]</code> 仅仅意味着程序中通过<code>buffer</code>结构体实例的<code>a[index]</code>成员可以访问<code>len</code>之后的第<code>index</code>个地址</li>
<li>它并 没有为<code>a[]</code>数组分配内存，因此<code>sizeof（struct buffer）=sizeof（int）</code>。</li>
</ul>
</blockquote>
<br>
<p><mark>用途:</mark>  <strong>零长度数组</strong>一般很少单独使用，它常常作为结构体的一个成员，构成一个<strong>变长结构体</strong>。</p>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> len;	<span class="comment">// len 标志着下面数据的长度</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">0</span>];	<span class="comment">// 数组名data是一个指针常量，标识着成员变量len后面的那个地址，但其本身并不占空间。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">int</span> this_length = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">    buf = (<span class="keyword">struct</span> buffer *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> buffer)+ this_length);</span><br><span class="line">    buf-&gt;len = this_length;</span><br><span class="line">	<span class="built_in">memset</span>(buf-&gt;a, <span class="string">&#x27;a&#x27;</span>, this_length);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(buf-&gt;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buf);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>sizeof(buffer) + 20，即24个字节大小。其中4个字节用来存储结构体指针 buf 指向的结构体类型变量，另外20个字节空间，才是我们真正使用的内存空间。</li>
<li>使用零长度数组 ,使得这个<strong>结构体的长度</strong>可以随着程序动态的变化</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font>   <strong>零长度数组</strong>要放在结构体的最后</p>
<br>
<hr />
<h3 id="47-__attribute__-关键字"><a class="markdownIt-Anchor" href="#47-__attribute__-关键字"></a> 4.7  <code>__attribute__</code>  关键字</h3>
<br>
<blockquote>
<p><mark>说明 :</mark></p>
<ul>
<li><code>__attribute__</code>是<code>GNU C</code> 新增的一个关键字 ,  可以用来设置<strong>函数属性</strong>、<strong>变量属性</strong>和<strong>类型属性</strong>。</li>
<li>函数属性可以把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</li>
</ul>
<p><mark>语法格式 :</mark>  <code>__atttribute__((ATTRIBUTE))</code></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font></p>
<ul>
<li>
<p><code>__attribute__</code>前后都有<strong>两个</strong>下划线</p>
</li>
<li>
<p><code>__attribute__</code>后面是<strong>两对小括号</strong> , 不能只写一对</p>
</li>
<li>
<p>括号里面的 <code>ATTRIBUTE</code>表示要声明的属性</p>
<ul>
<li>
<p>可以同时添加多个属性说明</p>
</li>
<li>
<p>可以选择若干个单独的<code>__attribute__</code>，或者把它们写在一起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写在一起 */</span></span><br><span class="line"><span class="type">char</span> c2 __attribute__((packed,aligned(<span class="number">4</span>)));			<span class="comment">// 各个属性之间用逗号隔开</span></span><br><span class="line">__attribute__((packed,aligned(<span class="number">4</span>))) <span class="type">char</span> c2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 单独 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">     __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span></span><br><span class="line">     __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>)))</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>如上所示 , 属性声明要<strong>紧挨着变量</strong> ,以上<code>C2</code>变量两种定义方式都是可行的</p>
</li>
</ul>
<br>
<hr />
<h4 id="471-变量属性说明"><a class="markdownIt-Anchor" href="#471-变量属性说明"></a> 4.7.1 变量属性说明’</h4>
<blockquote>
<p>举例说明其中几种属性</p>
</blockquote>
<br> 
<blockquote>
<p><mark>变量属性:</mark></p>
<ul>
<li>cleanup</li>
<li>aligned</li>
<li>packed</li>
<li>common</li>
<li>nocommon</li>
<li>deprecated</li>
<li>mode</li>
<li>section</li>
<li>shared</li>
<li>tls_model</li>
<li>transparent_union</li>
<li>unused</li>
<li>vector_size</li>
<li>weak</li>
<li>dllimport</li>
<li>dlexport</li>
</ul>
</blockquote>
<p><br> (官方文档 👇)</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Variable-Attributes.html#Variable-Attributes">(变量属性说明 - 官方文档)</a></p>
<hr />
<h5 id="4711-属性-section"><a class="markdownIt-Anchor" href="#4711-属性-section"></a> 4.7.1.1 属性: <code>section</code></h5>
<blockquote>
<p><strong>作用:</strong>  在程序编译时 , 将一个<strong>函数</strong>或变量放到 目标文件( .o文件) 的指定段中 , 即放到指定的<code>section</code>中</p>
<p><strong>格式：</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font></p>
<p>一段源程序代码在编译生成可执行文件的过程中,<strong>函数</strong>和<strong>变量</strong>是放在不同段中的 , 如图所示:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea19c16f2c2beb1c16d0d.png" alt="image-20220913221409508" /></p>
<ul>
<li>一个可执行文件主要由<strong>代码段</strong>、<strong>数据段</strong>、<strong>BSS段</strong>构成。</li>
<li><strong>代码段</strong>主要存放编译生成的可执行指令代码;</li>
<li><strong>数据段</strong>和<strong>BSS段</strong>用来存放全局变量、未初始化的全局变量</li>
<li>代码段、数据段和BSS段构成了一个可执行文件的主要部分。</li>
<li>此外还有其他的段 ,如<strong>只读数据段</strong>、<strong>符号表</strong> 、还包含其他一些<code>section</code></li>
</ul>
<p><br><font face="华文彩云" color=red size=5>说明：</font></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1a916f2c2beb1c1806c.png" alt="image-20220913222112669" /></p>
<p>​													<mark>从C程序到可执行文件</mark></p>
<br>
<hr />
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_val = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> uninit_val __attribute__((section(<span class="string">&quot;.data&quot;</span>)));</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>__atttribute__</code> 的 <code>section</code> 属性，显式指定一个函数或变量，在编译时放到指定的 <code>section</code> 里面</li>
<li>未初始化的全局变量是放在 <code>.bss section</code> 中的，即放在 <strong>BSS 段</strong>中</li>
<li>现在通过 <code>section</code> 属性，把这个未初始化的全局变量放到<strong>数据段</strong> <code>.data</code> 中。</li>
</ul>
<br>
<hr />
<p><span id="six" name="six"></span></p>
<h5 id="4712-属性-aligned"><a class="markdownIt-Anchor" href="#4712-属性-aligned"></a> 4.7.1.2 属性: <code>aligned</code></h5>
<blockquote>
<p><strong>作用 :</strong>　指定一个变量或类型的对齐方式（使被设置的对象<strong>占用更多的空间</strong>）</p>
<p><strong>注意 :</strong>  对齐的字节数必须是<strong>2的幂次方</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font>  定义一个变量在内存中以<strong>指定字节数</strong>对齐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x __attribute__ ((aligned (<span class="number">16</span>))) = <span class="number">0</span>;    <span class="comment">// 以16字节地址对齐</span></span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文行楷" color=red size=5>结构体对齐：</font></p>
<p>由前文 <a href="#two">结构体储存方式</a> 可知道 :</p>
<ul>
<li>结构体作为一种复合数据类型，编译器在给一个结构体变量分配存储空间时，会进行地址对齐;</li>
<li>结构体整体对齐要按结构体所有成员中最大成员字节数的整数倍进行对齐.</li>
<li>结构体成员按不同的顺序排放,可能会导致结构体整体长度不一致</li>
</ul>
<p><br><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为12 ((1 + (3)) + 4 + 2 = 10 ,补齐后为12)</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充3字节</span></span><br><span class="line">     <span class="type">int</span> b ;		<span class="comment">// 偏移为4; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> c ;		<span class="comment">// 偏移为8; 占用2字节; 填充2字节</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为8 ((1+(1)) + 2 + 4 = 8 )</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充1字节</span></span><br><span class="line">     <span class="type">short</span> b ;		<span class="comment">// 偏移为2; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;		<span class="comment">// 偏移为4; 占用4字节; 填充4字节</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<br>
<blockquote>
<p>用<code>__attribute__(aligned())</code>属性</p>
<p>不仅可以显性指定结构体<strong>某个成员的地址对齐</strong> ; 也可以显式指定<strong>整个结构体</strong>的对齐方式</p>
</blockquote>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 让 short 型的变量 b 按4字节对齐 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>								<span class="comment">// 结构体size为12 ((1 + (3)) + 4 + 4 = 12)</span></span><br><span class="line">     <span class="type">char</span> a;								<span class="comment">// 偏移为0; 占用1字节; 填充3字节</span></span><br><span class="line">     <span class="type">short</span> b __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">// 偏移为4; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;								<span class="comment">// 偏移为8; 占用4字节; 填充0字节</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显式指定结构体整体以16字节对齐 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>			<span class="comment">// 结构体size为16 ((1+(1)) + 2 + 4 = 8 ; 末尾填充8个字节后长度为16)</span></span><br><span class="line">     <span class="type">char</span> a;								<span class="comment">// 偏移为0; 占用1字节; 填充1字节</span></span><br><span class="line">     <span class="type">short</span> b;								<span class="comment">// 偏移为2; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c ;								<span class="comment">// 偏移为4; 占用4字节; 填充4字节</span></span><br><span class="line"> &#125;__attribute__((aligned(<span class="number">16</span>)));</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>特别注意：</font></p>
<ul>
<li>
<p>修改字节对齐方式 ,最大不能超过编译器允许的最大值;</p>
</li>
<li>
<p>如果连接器最大只支持16字节对齐，那么此时定义32字节对齐也是按16字节对齐</p>
</li>
</ul>
<br>
<hr />
<p><span id="five" name="five"></span></p>
<h5 id="4713-属性packed"><a class="markdownIt-Anchor" href="#4713-属性packed"></a> 4.7.1.3 <strong>属性：<code>packed</code></strong></h5>
<blockquote>
<p><strong>作用 :</strong>　指定一个变量或类型尽量使用<strong>最小的地址对齐方式</strong>来分配地址（一般用来设置<strong>减少地址对齐</strong>）</p>
<p><strong>注意 :</strong>  对齐的字节数必须是<strong>2的幂次方</strong></p>
<p><strong>用途 :</strong> 如用于封装结构体 , 为防止因内存空洞 导致与实际连续的寄存器地址不符合 ,则可以使用该属性.</p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>							<span class="comment">// 结构体size为7 ((1+ 2 + 4 = 7)</span></span><br><span class="line">     <span class="type">char</span> a;							<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> b __attribute__((packed));	<span class="comment">// 偏移为1; 占用2字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> c __attribute__((packed));		<span class="comment">// 偏移为3; 占用4字节; 填充0字节</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>实际应用：</font></p>
<blockquote>
<ul>
<li>在实际应用中 , 经常可以看到<code>aligned</code> 和 <code>packed</code> <strong>一起使用</strong>，即对一个变量或类型<strong>同时使用</strong> <code>aligned</code> 和 <code>packed</code> 属性声明。</li>
<li>这样做的好处是，既<strong>避免了</strong>结构体内因地址对齐产生的<strong>内存空洞</strong>，又<strong>指定了</strong>整个结构体的<strong>对齐方式</strong>。</li>
</ul>
</blockquote>
<br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>							<span class="comment">// 结构体size为8 ((1+ 2 + 4 = 7 ; 末尾填充1个字节后 ,长度变为8)</span></span><br><span class="line">    <span class="type">char</span> a;							<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">    <span class="type">short</span> b ;							<span class="comment">// 偏移为1; 占用2字节; 填充0字节</span></span><br><span class="line">    <span class="type">int</span> c ;							<span class="comment">// 偏移为3; 占用4字节; 填充1字节</span></span><br><span class="line">&#125;__attribute__((packed,aligned(<span class="number">8</span>)));</span><br></pre></td></tr></table></figure>
<p><strong>如上所示 :</strong></p>
<ul>
<li>结构体 <code>data</code> 虽然使用 <code>packed</code> 属性声明，整个<strong>长度变为7</strong>；</li>
<li>同时又使用了 <code>aligned(8)</code> 指定其按<strong>8字节地址</strong>对齐，所以编译器要在结构体后面<strong>填充1个字节</strong></li>
<li>这样整个结构体的<strong>大小就变为8字节</strong>，按8字节地址对齐。</li>
</ul>
<br>
<hr />
<h5 id="4714-属性-deprecated"><a class="markdownIt-Anchor" href="#4714-属性-deprecated"></a> 4.7.1.4 属性: <code>deprecated</code></h5>
<blockquote>
<p><strong>作用 :</strong>　弃用，如果在源文件在任何地方地方使用<code>__attribute__((deprecated))</code> 函数,编译器将会<strong>发出警告.</strong></p>
<p><strong>注意 :</strong>  该<code>deprecated</code>属性也可用于<strong>函数</strong>和<strong>类型</strong></p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((deprecated))  <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   test(<span class="number">1</span>);		<span class="comment">// 输出警告: void test(int a) is deprecated </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br> <font face="华文彩云" color=red size=5>注意：</font></p>
<p>警告仅在<strong>使用时</strong>出现，并且仅在类型应用于本身未被声明为<strong>已弃用</strong>的<strong>标识符、变量或函数</strong>时才会出现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 变量 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> old_var __attribute__ ((deprecated));</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> old_var;					<span class="comment">// 这里不出现警告</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">new_fn</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> old_var;					<span class="comment">// 警告仅在这里出现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">old_fn</span> <span class="params">()</span> __<span class="title function_">attribute__</span> <span class="params">((deprecated))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">old_fn</span> <span class="params">()</span>;						<span class="comment">// 这里不出现警告</span></span><br><span class="line"><span class="type">int</span> (*fn_ptr)() = old_fn;			<span class="comment">// 出现警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> T1 __attribute__ ((deprecated));</span><br><span class="line">T1 x;											<span class="comment">// 出现警告 </span></span><br><span class="line"><span class="keyword">typedef</span> T1 T2;									<span class="comment">// 出现警告</span></span><br><span class="line">T2 y;											<span class="comment">// 不出现警告 ，因为未明确弃用 T2。</span></span><br><span class="line"><span class="keyword">typedef</span> T1 T3 __attribute__ ((deprecated));		<span class="comment">// 不出现警告，因为T3 已被明确弃用</span></span><br><span class="line">T3 z __attribute__ ((deprecated));				<span class="comment">// 不出现警告, 因为T3 已被明确弃用</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="472-函数属性说明"><a class="markdownIt-Anchor" href="#472-函数属性说明"></a> 4.7.2 函数属性说明</h4>
<blockquote>
<p>举例说明其中几种属性</p>
</blockquote>
<br>
<blockquote>
<p><mark>函数属性:</mark></p>
<table>
<thead>
<tr>
<th>alias</th>
<th>const</th>
<th>dllimport</th>
</tr>
</thead>
<tbody>
<tr>
<td>always_inline</td>
<td>destructor</td>
<td>eightbit_data</td>
</tr>
<tr>
<td>cdecl</td>
<td>deprecated</td>
<td>far</td>
</tr>
<tr>
<td>fastcall</td>
<td>format</td>
<td>format_arg</td>
</tr>
<tr>
<td>constructor</td>
<td>dllexport</td>
<td>function_vector</td>
</tr>
<tr>
<td>interrupt</td>
<td>long_call/short_call</td>
<td>malloc</td>
</tr>
<tr>
<td>model</td>
<td>naked</td>
<td>near</td>
</tr>
<tr>
<td>no_instrument_function</td>
<td>noinline</td>
<td>nonnull</td>
</tr>
<tr>
<td>noreturn</td>
<td>nothrow</td>
<td>pure</td>
</tr>
<tr>
<td>regparm</td>
<td>saveall</td>
<td>section</td>
</tr>
<tr>
<td>sentinel</td>
<td>signal</td>
<td>tiny_data</td>
</tr>
<tr>
<td>unused</td>
<td>used</td>
<td>weak</td>
</tr>
</tbody>
</table>
</blockquote>
<br>
<p>(官方文档 👇)</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html#Function-Attributes">(函数属性说明 - 官方文档)</a></p>
<br>
<hr />
<h5 id="4721-属性-format"><a class="markdownIt-Anchor" href="#4721-属性-format"></a> 4.7.2.1 属性 : <code>format</code></h5>
<blockquote>
<p><strong>作用 :</strong></p>
<blockquote>
<ul>
<li>指定变参函数的参数格式检查 (用于解决在使用可变参数的函数调用时 , <strong>编译器检查不出可变参数的类型或者个数是否正确</strong>的问题)</li>
<li>作用是提示编译器检查函数调用的过程中，可变参数部分按照printf或其他的规则进行检查;</li>
<li>若参数的个数或者类型不匹配，编译过程中将会发出警告</li>
</ul>
</blockquote>
<br>
<p><strong>用途 ：</strong>　比如实现对自定义的打印函数 传入的可变参数的检查</p>
<p><strong>格式:</strong>　<code>format (archetype, string-index, first-to-check)</code></p>
<blockquote>
<ul>
<li><strong><code>archetype</code>参数 :</strong> <code>printf</code>, <code>scanf</code>,<code>strftime</code> , <code>strfmon</code></li>
<li><strong><code>string-index</code>参数 :</strong> 指定哪个参数是格式字符串参数（从 1 开始）</li>
<li><strong><code>first-to-check</code>参数 :</strong>  是要检查格式字符串的第一个参数的编号*(即从函数的第几个参数开始按上述规则进行检查)<em>。对于无法检查参数的函数，将第三个参数指定为零。</em>(在这种情况下，编译器只检查格式字符串的一致性)*</li>
<li>C++有隐式的<code>this</code>函数 , <code>string-index</code>, <code>first-to-check</code>应该向后一位开始</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font> 以自定义的打印函数为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如下所示:</span></span><br><span class="line"><span class="comment">			printf参数表示: 告诉编译器按照 printf 函数的检查标准来检查</span></span><br><span class="line"><span class="comment">			第二个参数1表示: 格式化字符串在LOG函数的第一个传入参数</span></span><br><span class="line"><span class="comment">			第二个参数2表示: LOG函数中要替代&quot;%&quot;占位符的参数排在第二位 ; (即“…”里的第一个参数在LOG函数参数总数排在第2)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>  __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>)))</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如下所示:</span></span><br><span class="line"><span class="comment">			LOG函数多了个新的传入参数num , 则</span></span><br><span class="line"><span class="comment">            format函数的 string-index和first-to-check参数应向后移动一位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOG</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> *fmt, ...)</span>  __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>;</span><br></pre></td></tr></table></figure>
  <br>
<hr />
<h6 id="47211-拓展-变参函数的实现"><a class="markdownIt-Anchor" href="#47211-拓展-变参函数的实现"></a> 4.7.2.1.1 拓展 ——变参函数的实现</h6>
<blockquote>
<p>简单介绍怎么设计一个 变参函数 , 打印传入的实参</p>
</blockquote>
<p><br><span id="three" name="three"></span></p>
<p><strong>基本思路:</strong></p>
<ul>
<li>变参函数的参数存储由一个<strong>连续的</strong>参数列表组成，列表里存放的是每个参数的地址。</li>
<li>有一个固定参数<code>count</code> , 该参数后面连续储存着后面一系列参数的地址</li>
<li>通过获取<code>count</code>的地址 , 再通过<code>&amp;count + 1</code>就可以依次访问下一个地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">(<span class="type">int</span> count, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *args;							<span class="comment">// 用于保存下一个参数地址(用char *类型指针实现,以兼容更多数据类型) )</span></span><br><span class="line">    args = &amp;count + <span class="number">4</span>;					<span class="comment">// 获取第一个可变参数的地址(涉及指针运算,注意每个地址大小都是4字节)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*args: %d\n&quot;</span>, *args);</span><br><span class="line">        args+=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);			<span class="comment">// 依次打印出1,2,3,4,5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="47212-变参函数的优化"><a class="markdownIt-Anchor" href="#47212-变参函数的优化"></a> 4.7.2.1.2 变参函数的优化</h6>
<blockquote>
<p>可通过调用<strong>变参函数宏</strong> 来获取参数列表 , 解决解析参数的问题</p>
</blockquote>
 <br>
<p><font face="华文彩云" color=red size=5>说明：</font></p>
<ul>
<li><code>va_list</code></li>
</ul>
<blockquote>
<ul>
<li>通过一个类型为 <code>va_list</code> 的对象，包含了参数信息 , 称为<strong>参数指针</strong></li>
<li>它包含了栈中至少一个参数的位置 , 可以使用这个参数指针从一个可选参数移动到下一个可选参数</li>
<li>va_list 类型被定义在头文件 stdarg.h 中。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">va_list argptr;  <span class="comment">// 用 va_list 类型定义参数指针，以获取可选参数。</span></span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_start</code></li>
</ul>
<blockquote>
<ul>
<li>宏 <code>va_start</code> 使用第一个可选参数的位置来初始化 <strong>参数指针</strong>。</li>
<li>该宏的第二个参数必须是该函数最后一个有名称参数的名称。</li>
<li>必须先调用该宏，才可以开始使用可选参数。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_start</span><span class="params">(va_list argptr, lastparam)</span>; </span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_arg</code></li>
</ul>
<blockquote>
<ul>
<li>展开宏 va_arg 会得到当前 argptr 所引用的可选参数</li>
<li>同时将 <strong>参数指针</strong> 移动到列表中的下一个参数。</li>
<li>宏 <code>va_arg</code> 的第二个参数是刚刚被读入的参数的类型。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title function_">va_arg</span><span class="params">(va_list argptr, type)</span>;</span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_end</code></li>
</ul>
<blockquote>
<ul>
<li>当不再需要使用参数指针时，必须调用宏 <code>va_end</code></li>
<li>如果想使用宏 <code>va_start</code> 或者宏 <code>va_copy</code> 来重新初始化一个之前用过的参数指针，也必须先调用宏 <code>va_end</code>。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_end</span><span class="params">(va_list argptr)</span>;</span><br></pre></td></tr></table></figure>
<br>
<ul>
<li><code>va_copy</code></li>
</ul>
<blockquote>
<ul>
<li>宏 <code>va_copy</code> 使用当前的 src 值来初始化参数指针 dest。</li>
<li>就可以使用 <code>dest</code> 中的备份获取从 <code>src</code> 所引用的位置开始的<strong>参数列表</strong></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">va_copy</span><span class="params">(va_list dest, va_list src)</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>优化后：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>						<span class="comment">// 可变参数宏定义在stdarg.h中</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_print</span><span class="params">(<span class="type">int</span> count,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list args;						<span class="comment">// 定义一个参数指针</span></span><br><span class="line">    va_start(args,count);				<span class="comment">// 初始化参数指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = va_arg(args,<span class="type">int</span>);		<span class="comment">// 取得int类型的可变参数值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*args: %d\n&quot;</span>, val);		<span class="comment">// 打印取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_print(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h6 id="47213-简单日志打印函数的实现"><a class="markdownIt-Anchor" href="#47213-简单日志打印函数的实现"></a> 4.7.2.1.3  简单日志打印函数的实现</h6>
<blockquote>
<p>通过<code>vsnprintf</code>函数 , 解决<strong>打印功能</strong>实现的问题</p>
</blockquote>
<br>
<p><font face="黑体" color=red size=5>printf系列函数说明：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; 			   <span class="comment">//输出到标准输出</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">//输出到文件</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;    <span class="comment">//输出到字符串str中</span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">//按size大小输出到字符串str中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数功能与上面的一一对应相同，只是在函数调用时，把上面的...对应的一个个变量用va_list调用所替代。在函数调用前ap要通过va_start()宏来动态获取。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief     	vsnprintf函数说明</span></span><br><span class="line"><span class="comment">  * @param[out] str : 把生成的格式化的字符串存放在这里</span></span><br><span class="line"><span class="comment">  * @param[in]  size ：接受的最大字符数(无符号数) (非字节数，UNICODE一个字符两个字节),防止产生数组越界.</span></span><br><span class="line"><span class="comment">  * @param[in]  format :指定输出格式的字符串，它决定了需要提供的可变参数的类型、个数和顺序。</span></span><br><span class="line"><span class="comment">  * @param[in]  ap  :va_list变量.</span></span><br><span class="line"><span class="comment">  * @retval    执行成功，返回最终生成字符串的长度，</span></span><br><span class="line"><span class="comment">  *       	   若生成字符串的长度大于size，则将字符串的前size个字符复制到str，同时将原串的长度返回（不包含终止符）；</span></span><br><span class="line"><span class="comment">  *            执行失败，返回负值，并置errno</span></span><br><span class="line"><span class="comment">  * @attention  none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>代码实现：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">log_printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> log_str[LOG_OUTPUT_MAX_LEN];			<span class="comment">// 输出缓冲区(把生成的格式化的字符串存放在这里)</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;								<span class="comment">// 用于记录当前已使用的长度</span></span><br><span class="line">    va_list arg;								<span class="comment">// 定义一个可变参数指针</span></span><br><span class="line">    va_start(arg, fmt);							<span class="comment">// 初始化参数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* len累加用于记录已使用的缓冲区长度 ;  </span></span><br><span class="line"><span class="comment">     	(LOG_OUTPUT_MAX_LEN - len)表示缓冲区剩余长度*/</span>   	</span><br><span class="line">    len += vsnprintf(log_str, LOG_OUTPUT_MAX_LEN - len, fmt, arg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &amp;log_str[len]等效于( log_str + len ) 表示地址偏移,将目标缓冲区指向字符串尾部 */</span></span><br><span class="line">    len += <span class="built_in">snprintf</span>(&amp;log_str[len],LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[len = %d]&quot;</span>,len)	<span class="comment">//&amp;log_str[len]等同于log_str + len</span></span><br><span class="line">    </span><br><span class="line">	va_end(arg);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* 将格式化字符串输出,此处是用串口输出 */</span></span><br><span class="line">    __log_output((<span class="type">uint8_t</span> *)log_str, len);		<span class="comment">//  类似printf(&quot;%s&quot;,log_str);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    log_printf(<span class="string">&quot;test \r\n&quot;</span> );</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>运行结果：</font ></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1b016f2c2beb1c18a66.png" alt="image-20220917215405446" /></p>
<br>
<hr />
<h6 id="47214-日志打印函数优化"><a class="markdownIt-Anchor" href="#47214-日志打印函数优化"></a> 4.7.2.1.4  日志打印函数优化</h6>
<blockquote>
<p><strong>优化方向:</strong></p>
<ul>
<li>添加打印等级 , 根据设置的打印等级，模块打印的 log 信息也会不一样</li>
<li>添加<code>format</code>属性声明 , 用于让编译器在编译的时候 , 检查<code>log_printf</code>函数的参数格式</li>
</ul>
</blockquote>
<br>
<p><span id="four" name="four"></span></p>
<p><font face="华文彩云" color=red size=5>代码实现一：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************** log.c ************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_OUTPUT_LEVEL 4			<span class="comment">// 输出等级(最大为4)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TIMESTAMP_EN 0			<span class="comment">// 时间信息输出使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FUNCTION_EN  0			<span class="comment">// 函数信息输出使能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FILE_LINE_EN 0			<span class="comment">// 文件信息输出使能</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASSERT   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARINING 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级输出信息表 */</span></span><br><span class="line"><span class="type">char</span> *LOG_LEVEL_TAGS[<span class="number">6</span>] = &#123;<span class="string">&quot;NULL&quot;</span>, <span class="string">&quot;ASSERT&quot;</span>, <span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;WARNING&quot;</span>, <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;DEBUG&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief     	将打印信息缓存到缓冲区</span></span><br><span class="line"><span class="comment">  * @param[out] buff : 把生成的格式化的字符串存放在这里</span></span><br><span class="line"><span class="comment">  * @param[in]  size ：接受的最大字符数(传入vsnprintf)</span></span><br><span class="line"><span class="comment">  * @param[in]  fmt  : 格式化字符串</span></span><br><span class="line"><span class="comment">  * @retval    执行成功，返回最终生成字符串的长度，</span></span><br><span class="line"><span class="comment">  *       	   </span></span><br><span class="line"><span class="comment">  * @attention  none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">log_printf_to_buffer</span><span class="params">(<span class="type">char</span> *buff, <span class="type">int</span> size, <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;					<span class="comment">// 用于记录当前已使用的长度</span></span><br><span class="line">    va_list arg;  </span><br><span class="line">    va_start(arg, fmt);</span><br><span class="line">   </span><br><span class="line">    len += vsnprintf(buff, size, fmt, arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************** log.h ************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为需要打印实时信息,如运行时间,当前函数和调用位置等 ; 所以使用函数宏的方式 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __log_with_level(level, ...)                                                                                                              \</span></span><br><span class="line"><span class="meta">    do                                                                                                                                       \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                                                        \</span></span><br><span class="line"><span class="meta">        char log_str[LOG_OUTPUT_MAX_LEN];                                                                                                    \</span></span><br><span class="line"><span class="meta">        int len = 0;                                                                                                                         \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> ((level &lt;= LOG_OUTPUT_LEVEL) &amp;&amp; (level &lt;= 5))                                                                             \</span></span><br><span class="line"><span class="meta">        &#123;                                                                                                                                    \</span></span><br><span class="line"><span class="meta">            len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;\r\n&quot;</span>);                                                                \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (LOG_TIMESTAMP_EN)                                                                                                            \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s]&quot;</span>,__TIME__ );                                                  \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s][%s]&quot;</span>, <span class="string">&quot;LOG&quot;</span>, LOG_LEVEL_TAGS[level]);                              \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (LOG_FUNCTION_EN)                                                                                                             \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;[%s]&quot;</span>, __FUNCTION__);                                              \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> ((LOG_FILE_LINE_EN) &amp;&amp; (level &lt;= LOG_ERROR))                                                                                  \</span></span><br><span class="line"><span class="meta">            &#123;                                                                                                                                \</span></span><br><span class="line"><span class="meta">                len += snprintf(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, <span class="string">&quot;(%s,%d)&quot;</span>, __FILE__, __LINE__);                                     \</span></span><br><span class="line"><span class="meta">            &#125;                                                                                                                                \</span></span><br><span class="line"><span class="meta">            len += log_printf_to_buffer(&amp;log_str[len], LOG_OUTPUT_MAX_LEN - len, __VA_ARGS__);                                               \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;%s&quot;</span>,log_str);                                                                                                            \</span></span><br><span class="line"><span class="meta">                                                                                                                                             \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                                                                    \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 各输出等级打印函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_assert(...) __log_with_level(LOG_ASSERT, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_error(...) __log_with_level(LOG_ERROR, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_waring(...) __log_with_level(LOG_WARINING, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(...) __log_with_level(LOG_INFO, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong>  为什么要使用do { … } while(0)</p>
<ul>
<li>为了防止宏在条件、选择等分支中展开后 ，产生歧义</li>
<li>使用do { … } while(0)这种结构 ， 在宏展开后，是一个代码块，避免发生歧义</li>
</ul>
<p><br><strong>缺陷:</strong></p>
<ul>
<li>因为 <code>__attribute__</code>  关键字不能作用于宏 , 所以没办法让编译器进行可变参数的检查</li>
<li>也无法使用<strong>内联函数</strong> , 因为使用了变参数列表 , 所以内联函数无法展开</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>代码实现二：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_OUTPUT_LEVEL 3			<span class="comment">// 输出等级(最大为4)</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	0: 关闭打印</span></span><br><span class="line"><span class="comment">	1: 只打印错误信息</span></span><br><span class="line"><span class="comment">	2: 打印警告和错误信息</span></span><br><span class="line"><span class="comment">	3: 打印所有信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印等级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARINING 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO     3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印函数 */</span></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_warn(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 若打印等级不符合,则只输出空函数 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> (LOG_OUTPUT_LEVEL &gt;= LOG_WARINING)   </span></span><br><span class="line">    <span class="type">char</span> log_str[LOG_OUTPUT_MAX_LEN];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, fmt);</span><br><span class="line">    </span><br><span class="line">    len += vsnprintf(log_str, LOG_OUTPUT_MAX_LEN - len, fmt, arg);</span><br><span class="line">    </span><br><span class="line">    va_end(arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,log_str);  </span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_info(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((format(<span class="built_in">printf</span>,<span class="number">1</span>,<span class="number">2</span>))) Log_error(<span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="4722-属性-weak"><a class="markdownIt-Anchor" href="#4722-属性-weak"></a> 4.7.2.2 属性:  <code>weak</code></h5>
<blockquote>
<p><strong>作用 :</strong>　将一个<strong>强符号</strong>转换为<strong>弱符号</strong> , 可用于函数和变量</p>
<p><strong>用途 :</strong>   主要用于定义可以在用户代码中覆盖的库函数</p>
<p><strong>格式:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  __attribute__((weak))  func(<span class="type">void</span>);			<span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span>  num  __attribte__((weak);						<span class="comment">// 变量声明</span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li><strong>强符号：</strong> 函数名、初始化的全局变量名；</li>
<li><strong>弱符号：</strong> 未初始化的全局变量名。</li>
</ul>
<br>
<p><strong>不同场景下的同名符号:</strong></p>
<ul>
<li><strong>（强符号 + 强符号）:</strong> 在一个工程中同时定义两个同名的<strong>函数</strong>或<strong>全局变量</strong> , 在链接器链接目标文件的时候会报<strong>重定义错误</strong></li>
<li><strong>(强符号 + 弱符号) :</strong>   在一个工程中同时定义两个同名的<strong>初始化全局变量</strong>或<strong>未初始化全局变量</strong> , 编译器一般会<strong>选用强符号</strong>，<strong>丢掉弱符号</strong>。</li>
<li><strong>(弱符号 + 弱符号) :</strong>  谁的体积大，即谁在内存中存储空间大，使用谁。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func.c</span></span><br><span class="line"><span class="type">int</span> a __attribute__((weak)) = <span class="number">1</span>;		<span class="comment">// 将一个初始化的全局变量声明为弱符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> __attribute__((weak)) func(<span class="type">void</span>);	<span class="comment">// 将一个函数声明为弱符号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main：a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (func)							<span class="comment">// 在调用弱符号函数时 , 先判断函数地址是否为0</span></span><br><span class="line">        func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><strong>输出结果:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span>: <span class="selector-tag">a</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如上所示 ：</strong></p>
<ul>
<li>链接器在链接时会选择 main.c 中的这个强符号(即a = 4)</li>
<li>当函数被声明为一个弱符号时 , 如果链接器找不到定义时 , 不会报错 ,而是将这个弱符号设置为0</li>
<li>只有当程序运行时 , 调用到这个函数时 , 才会产生内存错误</li>
</ul>
</blockquote>
<br>
<hr />
<h5 id="4723-属性-alias"><a class="markdownIt-Anchor" href="#4723-属性-alias"></a> 4.7.2.3 属性 : <code>alias</code></h5>
<blockquote>
<p><strong>作用 :</strong>  用于给函数定义一个别名</p>
<p><strong>用途 :</strong>  主要与<code>weak</code>属性一起使用 , 通过<code>alias</code>属性对旧的函数接口做封装 , 起一个新接口的名字</p>
<p><strong>格式 :</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* __f()函数定义一个别名f() , 可以通过调用f()函数来直接调用_f() */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((alias(<span class="string">&quot;__f&quot;</span>)))</span>;  </span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>将<code>alias</code> 有时会和 <code>weak</code> <code>属性一起使用</code></li>
<li>如果<code>mian.c</code>新定义了<code>f()</code>函数 , 则调用的新定义的<code>f()</code>函数</li>
<li>当<code>f()</code> 没有定义时 , 就会调用<code>_f()</code>函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f.c</span></span><br><span class="line"><span class="type">void</span> __f(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;__f()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 给_f()函数声明一个别名f(), 并声明为弱符号函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((weak,alias(<span class="string">&quot;__f&quot;</span>)))</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="type">void</span> __attribute__((weak)) f(<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f()\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<br>
<h5 id="4724-属性-noinline-always_inline"><a class="markdownIt-Anchor" href="#4724-属性-noinline-always_inline"></a> 4.7.2.4 属性:  <code>noinline</code> &amp; <code>always_inline</code></h5>
<blockquote>
<p><strong>作用:</strong></p>
<blockquote>
<ul>
<li><strong>noinline:</strong>  通过声明<code>noinline</code>使指定的内联函数<strong>不展开</strong></li>
<li><strong>always_inline:</strong> 通过声明<code>always_inline</code>使指定的内联函数<strong>展开</strong></li>
</ul>
</blockquote>
<p><strong>用途:</strong></p>
<blockquote>
<ul>
<li>因为通过inline关键字修饰的函数 , 并不一定在编译时会展开</li>
<li>如函数体太大、存在循环、存在指针、函数调用频繁等情况 ，编译器一般不会做内联展开</li>
<li>通过使用<code>noinline</code>和<code>always_inline</code> 来<strong>显式的</strong>指定编译器是否做内联展开</li>
</ul>
</blockquote>
<p><strong>格式：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> __attribute__((noinline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span>  <span class="keyword">inline</span> __attribute__((always_inline)) <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h4 id="473-类型属性说明"><a class="markdownIt-Anchor" href="#473-类型属性说明"></a> 4.7.3 类型属性说明</h4>
<br>
<blockquote>
<p><mark>类型属性 :</mark></p>
<ul>
<li>aligned</li>
<li>packed</li>
<li>transparent_union</li>
<li>unused</li>
<li>deprecated</li>
<li>may_alias</li>
</ul>
</blockquote>
<br>
<p>(官方文档 👇)</p>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Type-Attributes.html#Type-Attributes">(类型属性说明 - 官方文档)</a></p>
<br>
<hr />
<h3 id="48-内建函数"><a class="markdownIt-Anchor" href="#48-内建函数"></a> 4.8  内建函数</h3>
<blockquote>
<p><strong>内建函数 :</strong></p>
<blockquote>
<ul>
<li>GNU C提供了大量内建函数 , 内建函数是在编译器内部实现的函数 , 可以如关键字一样直接调用</li>
<li>通常以<code>__builtin</code>开头</li>
<li>主要是在编译器内部使用 , 为编译器服务的</li>
</ul>
</blockquote>
<p><br><strong>用途:</strong></p>
<blockquote>
<ul>
<li>用来处理变长参数列表；</li>
<li>用来处理程序运行异常、编译优化、性能优化；</li>
<li>查看函数运行中的底层信息、堆栈信息等；</li>
<li>C 标准库函数的内建版本。</li>
</ul>
</blockquote>
<p><br><strong>说明 :</strong></p>
<blockquote>
<ul>
<li>在开发中 , 一般不会使用内建函数</li>
<li>因为有些函数 , 有助于我们对程序运行的底层机制、编译优化等的理解</li>
<li>而且在Linux内核中也经常会使用 ， 所以还是应该去了解</li>
</ul>
</blockquote>
</blockquote>
 <br>
<hr />
<blockquote>
<p>简单介绍几种常见的内建函数</p>
</blockquote>
<h4 id="481-__builtin_return_addresslevel"><a class="markdownIt-Anchor" href="#481-__builtin_return_addresslevel"></a> 4.8.1   <code>__builtin_*return_*address(LEVEL)</code></h4>
<blockquote>
<p><strong>作用 :</strong></p>
<ul>
<li>
<p>返回当前函数或其调用者的返回地址</p>
</li>
<li>
<p>参数<code>LEVEL</code>指定调用栈的级数;</p>
<blockquote>
<ul>
<li>0 : 表示当前函数的返回地址;</li>
<li>1 :表示当前函数的调用者的返回地址;</li>
<li>2: 获取上二级函数的返回地址</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> *p;</span><br><span class="line">     p = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;main return address: %p\n&quot;</span>,p);		<span class="comment">// 获取当前函数的返回地址</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li>C 语言函数在<strong>调用过程</strong>中，会将当前函数的<strong>返回地址</strong>、<strong>寄存器等现场信息</strong>保存在堆栈中，然后才会跳到被调用函数中去执行。</li>
<li>当被调用函数执行结束后，根据保存在堆栈中的返回地址，就可以直接返回到原来的函数中继续执行。</li>
</ul>
<br>  
<hr />
<h4 id="482-__builtin_constant_pexp"><a class="markdownIt-Anchor" href="#482-__builtin_constant_pexp"></a> 4.8.2 <code>__builtin_constant_p(EXP)</code></h4>
<blockquote>
<p><strong>作用 :</strong>  用于判断参数<code>EXP</code>在编译时 是否为<strong>常量</strong></p>
<p><strong>说明 :</strong>  如果<code>EXP</code>是常量返回 1 ; 否则返回 0</p>
<p><strong>用途 ;</strong>  主要用于宏定义中 , 根据宏的参数是常量还是变量 , 实现的方法也不同</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 根据参数是否为常数 , 实现不同的版本 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _dma_cache_sync(addr, sz, dir)        		\</span></span><br><span class="line"><span class="meta">do &#123;                            			  		\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_constant_p(dir))          		\</span></span><br><span class="line"><span class="meta">        __inline_dma_cache_sync(addr, sz, dir); 	\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span>                        					\</span></span><br><span class="line"><span class="meta">        __arc_dma_cache_sync(addr, sz, dir);   	    \</span></span><br><span class="line"><span class="meta">&#125;                           					    \</span></span><br><span class="line"><span class="meta">while (0);</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="483-__builtin_expectexpc"><a class="markdownIt-Anchor" href="#483-__builtin_expectexpc"></a> 4.8.3 <code>__builtin_expect(exp,c)</code></h4>
<blockquote>
<p><strong>作用 :</strong>  用于为编译器提供分支预测信息 ,</p>
<p><strong>说明 :</strong>   无论参数<code>C</code>的值是什么 , 该内建函数的返回值都是<code>exp</code> , <code>c</code>必须是编译时的常数</p>
<p><strong>用途 ：</strong> <code>Linux</code>内核编程时常用的<code>likely（）</code>和<code>unlikely（）</code>就是通过<code>__builtin_expect(exp,c)</code>实现的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将参数x转换为布尔类型 , 然后与1和0直接做比较 , 告诉编译器x为真或假的可能性很高 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> likely_notrace(x) __builtin_expect(!!(x), 1) 		<span class="comment">// 告诉编译器x发生的概率很高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely_notrace(x) __builtin_expect(!!(x), 0)		<span class="comment">// 告诉编译器x发生的概率很低</span></span></span><br></pre></td></tr></table></figure>
<p><br><font face="华文彩云" color=red size=5>注意：</font ></p>
<blockquote>
<p>为什么要进行两次取非操作</p>
<ul>
<li>为了把传入参数转换为布尔类型</li>
<li>如果参数x是0, 两次取非后还是0</li>
<li>如果参数是非0 , 两次取非后会变成1</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="49-可变参数宏"><a class="markdownIt-Anchor" href="#49-可变参数宏"></a> 4.9 可变参数宏</h3>
<blockquote>
<p><strong>说明 :</strong></p>
<blockquote>
<p>在标准<code>C</code>语言中支持可变参数函数( 具体见<a href="#three">变参函数的实现</a> ) ;</p>
<p>而在<code>GNU C</code>中，宏也可以接受可变数目的参数</p>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font >变参宏的实现形式其实跟变参函数差不多 :</p>
<ul>
<li>用 <code>...</code> 表示<strong>变参列表</strong>，变参列表由不确定的参数组成，各个参数之间用逗号隔开。</li>
<li>可变参数宏使用 <code>__VA_ARGS__</code> 预定义<strong>标识符</strong>来表示前面的变参列表</li>
<li>预处理器在将<strong>宏展开</strong>时，会用变参列表<strong>替换</strong>掉宏定义中的所有 <code>__VA_ARGS__</code> 标识符。</li>
<li>也可以用<code>args...</code>表示变参列表 , 在后面的宏定义中直接使用<code>arg</code>表示变参</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用__VA_ARGS__ */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(...) __log_with_level(LOG_INFO, __VA_ARGS__)	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用args... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _log_info(args...) __log_with_level(LOG_INFO, arg)	</span></span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="491-拓展-宏定义中的特殊符号"><a class="markdownIt-Anchor" href="#491-拓展-宏定义中的特殊符号"></a> 4.9.1 拓展 —— 宏定义中的特殊符号</h4>
<blockquote>
<p>宏定义语句中存在一些特殊的符号 ：</p>
<ul>
<li>
<p>语句连接符 <code>\</code> ： 用于在复杂宏定义中 ， 将上下行连接起来 ， 表示上下行同属于一行</p>
</li>
<li>
<p>符号<code>#</code> ：将其后面的宏参数进行<strong>字符串化</strong>操作，简单说就是在对它所引用的<strong>宏变量</strong> 通过替换后在其左右各加上一个双引号。</p>
</li>
<li>
<p>符号<code>#@</code> :  将标记转换为相应的单个字符 , 注意：仅对单一标记转换有效 .</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> B(x) #@x     <span class="comment">// B(1) 即&#x27;1&#x27; ; B(a)即&#x27;a&#x27; ; 对B(abc)无效</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>义参数连接符 <code>##</code>：主要用于将宏定义中的两个<code>token</code>链接起来，这里的<code>token</code>可以是宏的变量，也可以是任意参数或者标记。(宏展开时会将<code>##</code> 两边的字符合并 , 并删除<code>##</code>这个连接符)</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> f(a,b) a##b     <span class="comment">// 输入f(a,1)输出为a1</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<h4 id="492-通过连接符对宏进行优化"><a class="markdownIt-Anchor" href="#492-通过连接符对宏进行优化"></a> 4.9.2 通过<code>##</code>连接符对宏进行优化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(fmt, ...) printf(fmt, __VA_ARGS__)  <span class="comment">// 定义一个简单的可变参数宏 </span></span></span><br></pre></td></tr></table></figure>
<p><strong>如上所示 :</strong></p>
<ul>
<li>
<p>如上的定义方式存在漏洞　：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;test&quot;,);		// 如果变参为空时,宏展开后会产生语法错误</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以使用<code>##</code>连接符来避免产生这个语法错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define LOG(<span class="built_in">fmt</span>, ...) <span class="built_in">printf</span>(<span class="built_in">fmt</span>, <span class="comment">##__VA_ARGS__)</span></span> </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当变参列表非空时，## 的作用是连接 <code>fmt</code>，和变参列表，各个参数之间用逗号隔开，宏可以正常使用</p>
</li>
<li>
<p>当变参列表为空时，<code>##</code>会将固定参数 <code>fmt</code> 后面的逗号删除掉，这样宏也就可以正常使用了。</p>
</li>
</ul>
<br>
<hr />
<br>
<h2 id="5️⃣-c语言补充"><a class="markdownIt-Anchor" href="#5️⃣-c语言补充"></a> 5️⃣ C语言补充</h2>
<h3 id="51-内联函数与宏"><a class="markdownIt-Anchor" href="#51-内联函数与宏"></a> 5.1 内联函数与宏</h3>
<h4 id="511-宏与带参宏"><a class="markdownIt-Anchor" href="#511-宏与带参宏"></a> 5.1.1 宏与带参宏</h4>
<p>宏定义<code>#define</code>  本质是替换，从宏变成最终替换文本的过程称为<mark>宏展开</mark>。</p>
<br>
<h5 id="5111-带参宏"><a class="markdownIt-Anchor" href="#5111-带参宏"></a> 5.1.1.1 带参宏</h5>
<p>带参宏的用法与函数调用不完全相同，可能存在部分<strong>陷阱</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="number">5</span>;</span><br><span class="line">	SQUARE(x+<span class="number">2</span>);</span><br><span class="line">    SQUARE(++x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意 ：</strong> 上面两个运行结果分别是 <mark>17</mark> ；<mark>42</mark></p>
<p><strong>原因如下:</strong></p>
<ul>
<li><code>SQUARE(x+2);</code> 被替换成（5+2 * 5 +2 = 17）</li>
<li><code>SQUARE(++x);</code> 被替换成（++x * ++x = 6*7 =42）</li>
</ul>
</blockquote>
<br>
<h5 id="5112-总结"><a class="markdownIt-Anchor" href="#5112-总结"></a> 5.1.1.2 总结：</h5>
<ul>
<li>宏起到的作用只是替换，而不提供计算；</li>
<li>宏是在代码处不加任何验证的简单替代</li>
<li>宏不可以在运行时调试</li>
</ul>
<hr />
<h4 id="512-内联函数"><a class="markdownIt-Anchor" href="#512-内联函数"></a> 5.1.2  内联函数</h4>
<h5 id="5121-定义"><a class="markdownIt-Anchor" href="#5121-定义"></a> 5.1.2.1 定义：</h5>
<blockquote>
<p>一个用<code>inline</code>声明的函数称为内联函数 , 内联函数一般前面会使用<code>static</code>和<code>extern</code>修饰</p>
</blockquote>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">double</span> <span class="title function_">square</span><span class="params">(<span class="type">double</span> x)</span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内联函数可以定义在头文件中，因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题</strong></p>
<hr />
<br>
<ul>
<li><code>inline</code>是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。</li>
<li><strong>对于短小的代码来说，inline可以带来一定的效率提升</strong>，而且和函数宏相比，<code>inline</code> <strong>更安全可靠</strong>。</li>
<li>可是这个是以<strong>增加空间消耗为代价</strong>的 , 因为内联函数相当于<strong>代码复制</strong>，在运行时，将内联的代码复制上去。</li>
</ul>
<br>
<p><strong>内联函数一般使用情况：</strong></p>
<ul>
<li>一个函数不断被重复调用。</li>
<li>函数体积小</li>
<li>且函数不包含<strong>指针赋值</strong>、<strong>递归</strong>、<strong>循环</strong>等语句。</li>
</ul>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>一般来说，我们写小程序没有必要定义成<code>inline</code></li>
<li>但是如果要完成一个工程项目，<mark>当一个简单函数被调用多次时</mark>，则应该考虑用<code>inline</code>。</li>
<li>使用static和inline关键字修饰它 , 并可以视情况使用<code>noinline</code>或<code>always_inline</code>进行声明</li>
</ul>
<br>
<hr />
<h4 id="513-宏与内联函数"><a class="markdownIt-Anchor" href="#513-宏与内联函数"></a> 5.1.3 宏与内联函数</h4>
<p>相比于函数宏 , 内联函数具有以下<strong>优势:</strong></p>
<ul>
<li>参数类型检查。内联函数虽然具有宏的展开特性，但其本质仍是函数，编译过程中，编译器仍可以对其进行参数检查，而宏就不具备这个功能。</li>
<li>便于调试。函数支持的调试功能有断点、单步……，内联函数也同样可以。</li>
<li>返回值。内联函数有返回值，返回一个结果给调用者。这个优势是相对于 ANSI C 而言的。不过现在宏也可以有返回值和类型了，比如使用<strong>语句表达式</strong>定义的宏。</li>
<li>接口封装。有些内联函数可以用来封装一个接口，而宏不具备这个特性。</li>
</ul>
<br>
<hr />
<h5 id="5131-总结"><a class="markdownIt-Anchor" href="#5131-总结"></a> 5.1.3.1 总结：</h5>
<ul>
<li>宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入调用处，而减少了普通函数调用时的资源消耗。</li>
<li>宏<strong>不是函数</strong>，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体。</li>
<li><code>inline</code>函数<strong>是函数</strong>，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；</li>
</ul>
<br>
<hr />
<h4 id="514内联函数为什么用static修饰"><a class="markdownIt-Anchor" href="#514内联函数为什么用static修饰"></a> 5.1.4内联函数为什么用static修饰</h4>
<blockquote>
<p>内联函数为什么定义在头文件中</p>
<blockquote>
<ul>
<li>内联函数的使用方法和宏类似</li>
<li>通过定义在头文件中 , 任何想要使用该内联函数的源文件 ,只需要包含该头文件 ,而不需要重新定义一遍</li>
</ul>
</blockquote>
<br>
<p>内联函数为什么要用static修饰</p>
<blockquote>
<ul>
<li>因为我们使用 inline 定义的内联函数，编译器<strong>不一定会内联展开</strong></li>
<li>那么当多个文件都包含这个内联函数的定义时，编译时就有可能报<strong>重定义错误</strong>。</li>
<li>而使用 static 修饰，可以将这个函数的<strong>作用域</strong>局限在各自<strong>本地文件内</strong>，避免了重定义错误。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<br>
<hr />
<h3 id="52-预定义宏"><a class="markdownIt-Anchor" href="#52-预定义宏"></a> 5.2 预定义宏</h3>
<blockquote>
<p>C标准规定了一些预定义宏( 前文关于<a href="#four">日志函数优化</a> 部分就使用了部分预定义宏)</p>
</blockquote>
<br>
<p><mark>预定义宏:</mark></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1b616f2c2beb1c1914d.png" alt="image-20220920221113126" /></p>
<br>
<p><strong>注意:</strong>  使用时注意这些宏的作用域</p>
<hr />
<h3 id="53-pragma"><a class="markdownIt-Anchor" href="#53-pragma"></a> 5.3 #pragma</h3>
<blockquote>
<p><strong>作用 ：</strong> <code>#pragma</code> 是一个C语言中的预处理指令，用于设定编译器的状态或者指示编译器完成一些特定的动作</p>
<p><strong>注意:</strong></p>
<blockquote>
<ul>
<li><code>#pragma</code> 所定义的很多指示字是编译器特有的</li>
<li><code>#pragma</code> 在不同的编译器间是不可移植的</li>
<li>预处理器将忽略它不认识的 <code>#pragma</code> 指令</li>
</ul>
</blockquote>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>示例：</font ></p>
<p><code>ARM-MDK</code>下支持的<code>#pragma</code>指令:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1bc16f2c2beb1c19b07.png" alt="image-20220922201802679" /></p>
<hr />
<blockquote>
<p>介绍其中几种 , 但不同编译器对其指令的支持不同</p>
</blockquote>
<br>
<h4 id="531-pragma-packn"><a class="markdownIt-Anchor" href="#531-pragma-packn"></a> 5.3.1  #pragma pack(n)</h4>
<blockquote>
<p><strong>作用  :</strong>   告诉编译器 ,  <em><strong>结构体或类</strong></em> 内部的成员变量相对于 <em><strong>第一个变量</strong></em> 的地址的偏移量的对齐方式</p>
<p><strong>注意  :</strong></p>
<blockquote>
<ul>
<li>在参数n缺省的情况下 , 编译器按自然边界对齐</li>
<li>当变量所需的自然对齐边界比n大时 , 按照n对齐</li>
<li>否则按自然边界对齐</li>
</ul>
</blockquote>
</blockquote>
<br>
<p>[👇  关于结构体对齐,  前文已经介绍过了 ]</p>
<p>(<a href="#two">结构体对齐</a>)</p>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)		<span class="comment">// 使结构体按一字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span>		<span class="comment">// 结构体size为7 (1 + 4 + 2 = 7)</span></span><br><span class="line">     <span class="type">char</span> a;		<span class="comment">// 偏移为0; 占用1字节; 填充0字节</span></span><br><span class="line">     <span class="type">int</span> b ;		<span class="comment">// 偏移为1; 占用4字节; 填充0字节</span></span><br><span class="line">     <span class="type">short</span> c ;		<span class="comment">// 偏移为5; 占用2字节; 填充0字节</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>如上所示:</strong></p>
<ul>
<li>结构体成员的大小取其内部<strong>长度最大</strong>的数据成员作为其大小;</li>
<li>因为pack 参数默认为 8，所以对齐参数为 4 ;</li>
<li>一般的 pack 对齐格式分别是 1，2，4，8，16;</li>
<li>在默认的对齐格式，也就是<code>#pragmapack()</code> 的情况下，会在结构体中挑选占用字节最多的类型</li>
</ul>
<br>
<hr />
<h5 id="5311-pragma-pack-和-__attribute__packed-和-__attribute__aligned"><a class="markdownIt-Anchor" href="#5311-pragma-pack-和-__attribute__packed-和-__attribute__aligned"></a> 5.3.1.1 <code>#pragma pack</code> 和  <code>__attribute__(packed)</code> 和 <code>__attribute__(aligned)</code></h5>
<br>
<ul>
<li>
<p><code>#pragma pack</code>设置结构体和联合体的字节对齐方式 , 一般参数是 1，2，4，8，16;</p>
<br>
</li>
<li>
<p><code>__attribute__ ((__packed__))</code>关键字用于指定一个<strong>变量或类型</strong>以最小的方式对齐</p>
<ul>
<li>用于告诉编译器 , <strong>不对结构体进行</strong>对齐处理 , 即按照它原有的类型大小分配空间</li>
<li><code>__attribute__ ((__packed__))</code>是个<strong>类型属性</strong>可用于单独的结构体成员,也可用于变量</li>
</ul>
<br>
</li>
<li>
<p><code>__attribute__((aligned(n)))</code> 作用与<code>#pragma pack</code>类似, 也是指定<strong>变量或类型</strong>对齐方式</p>
<ul>
<li><code>__attribute__((aligned(n)))</code>同样是一个<strong>类型属性</strong> , 不仅可以显性指定结构体<strong>某个成员的地址对齐</strong> ; 也可以显式指定<strong>整个结构体</strong>的对齐方式</li>
<li><code>__attribute__((aligned(n)))</code>的参数必须的<strong>2的幂次方</strong></li>
</ul>
</li>
</ul>
<br>
<p>[👇 关于和 , 可查看前文  ]</p>
<p>(<a href="#five"><strong>attribute</strong>(packed)</a> ; <a href="#six"><strong>attribute</strong>(aligned)</a>)</p>
<hr />
<h4 id="532-pragma-message"><a class="markdownIt-Anchor" href="#532-pragma-message"></a> 5.3.2  <code>#pragma message</code></h4>
<blockquote>
<p><strong>作用 :</strong>  在编译到该处代码时会在 <em><strong>编译输出窗口</strong></em> 中将制定 消息文本 打印出来。</p>
<p><strong>格式 :</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;消息文本&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>用途 :</strong>  可用于在版本更替的时候 , 输出版本信息等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(version V1.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V1.0...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(version V1.3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V1.3...&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(version V2.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;version V2.0...&quot;</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<hr />
<h4 id="533-pragma-once"><a class="markdownIt-Anchor" href="#533-pragma-once"></a> 5.3.3  <code>#pragma once</code></h4>
<blockquote>
<p><em><strong>作用 :</strong></em>   <code>#pragma once</code> 用于保证头文件只被编译一次</p>
<p><em><strong>注意 :</strong></em>   <code>#pragma once</code> 不一定会被编译器支持</p>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLOBAL_H_				<span class="comment">// 条件编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GLOBAL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><em><strong>如上所示 :</strong></em></p>
<ul>
<li>条件编译
<ul>
<li>被 C 语言所支持的，并不是只包含一次头文件 , 而是包含多次</li>
<li>通过宏控制 , 可以保证头文件里面的内容只被嵌入一次</li>
<li>由于在编译之前 , 预处理器还是处理了多次 , 所以效率上比较低</li>
</ul>
</li>
<li><code>#pragma once</code>
<ul>
<li>是告诉预处理器当前文件只编译一次，所以说效率较高</li>
<li>通过与条件编译指令一起使用 , 即保证了移植性 , 又保证了效率</li>
</ul>
</li>
</ul>
<br>
<hr />
<h3 id="54-assert断言"><a class="markdownIt-Anchor" href="#54-assert断言"></a> 5.4  assert断言</h3>
<blockquote>
<p><em><strong>作用 :</strong></em>  计算表达式 <code>expression</code> ，如果其值为假（即为0），那么它先向<code>stderr</code>打印一条出错信息，然后通过调用 <code>abort</code> 来终止程序运行</p>
<br>
<p><em><strong>宏原型 :</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span> <span class="params">(<span class="type">int</span> expression)</span>;</span><br></pre></td></tr></table></figure>
<p>参数<code>expression</code>可以是一个条件表达式或逻辑表达式:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(n != <span class="number">0</span> );</span><br></pre></td></tr></table></figure>
<br>
<p><em><strong>说明 :</strong></em></p>
<blockquote>
<ul>
<li>assert宏的原型定义在<code>&lt;assert.h&gt;</code>中</li>
<li><strong>assert是宏，而不是函数。</strong></li>
<li><code>assert</code> 的调用会增加额外的开销 ;</li>
<li>一般可以用于在函数开始出 <em><strong>检验传入参数</strong></em> 的合法性</li>
<li>在调试结束后，可以通过插入 <code>#define NDEBUG</code> 来禁用 <code>assert</code> 调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NDEBUG宏和assert宏原型 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(e) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(e)  \</span></span><br><span class="line"><span class="meta">    ((void) ((e) ? ((void)0) : __assert (#e, __FILE__, __LINE__)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<br>
<p><em><strong>注意 :</strong></em></p>
<blockquote>
<ul>
<li><strong>每个assert只检验一个条件</strong> ( 存在多个条件时 , 无法<strong>直观的判断是哪个条件失败</strong>)</li>
<li>因为<code>assert</code>只在<code>DEBUG</code>个生效 , 所以不能使用改变环境的语句 <em><strong>(如 :   <code>assert(i++ &lt; 100)</code>)</strong></em></li>
</ul>
</blockquote>
<br>
<p><em><strong>优点 :</strong></em></p>
<ul>
<li>使用<code>assert()</code>能自动标识出文件和出问题的行号</li>
<li>而且提供了一种无需更改代码就能开启或关闭的断言机制</li>
</ul>
</blockquote>
<br>
<hr />
<h3 id="55-共用体-union"><a class="markdownIt-Anchor" href="#55-共用体-union"></a> 5.5 共用体 <code>union</code></h3>
<blockquote>
<p><em><strong>一般形式:</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">成员表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br>
<p><em><strong>结构体和共用体的区别在于 :</strong></em></p>
<ul>
<li>结构体的各个成员会 <em><strong>占用不同的内存</strong></em> ，互相之间没有影响；</li>
<li>而共用体的所有成员 <em><strong>占用同一段内存</strong></em> ，修改一个成员会影响其余所有成员。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用实例：</font ></p>
<hr />
<h4 id="551-数据传输"><a class="markdownIt-Anchor" href="#551-数据传输"></a> 5.5.1  数据传输</h4>
<blockquote>
<p>用于传输浮点数据</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">f_data</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte[<span class="number">4</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样在进行数据传输的时候会方便很多，比如<strong>串口传输</strong>只需要把这个数组 <code>byte[4]</code> 进行传输就可以了。</p>
<br>
<hr />
<h4 id="552-管理状态变量"><a class="markdownIt-Anchor" href="#552-管理状态变量"></a> 5.5.2 管理状态变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sys_status</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> all_status;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> status1 : <span class="number">1</span>;   <span class="comment">// FALSE / TRUE</span></span><br><span class="line">        <span class="type">bool</span> status2 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status3 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status4 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status5 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status6 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status7 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status8 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status9 : <span class="number">1</span>;   <span class="comment">//</span></span><br><span class="line">        <span class="type">bool</span> status10 : <span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; bit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>如上所示 :</strong></em></p>
<ul>
<li>
<p>将各个状态封装成联合体类型;</p>
</li>
<li>
<p>联合体里边的成员是一个<code>32bit</code>的 <em><strong>整数</strong></em> 及一个 <em><strong>结构体</strong></em> ，该结构体以 <em><strong>位域</strong></em> 的形式体现。</p>
</li>
<li>
<p><strong>由于每个字段恰好为 1位 ，所以只能为其赋值 1 或 0 。</strong></p>
</li>
<li>
<p>这样就可以方便的操作 <em><strong>每个</strong></em> 状态标志位了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_status.bit.status1 = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也可以直接操作 <em><strong>全部</strong></em> 标志位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_status.all_status = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>补充说明：</font ></p>
<blockquote>
<p><em><strong>位域:</strong></em></p>
<ul>
<li>
<p>C语言允许在一个结构体中 <em><strong>以位为单位来指定其成员所占内存长度</strong></em> ，这种以位为单位的成员称为“<em><strong>位段</strong></em>”或称“<em><strong>位域</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint8_t</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">uint8_t</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint8_t</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用位段能够用较少的位数存储数据， <code>:</code> 后面的数字用来限定成员变量占用的位数。</p>
</li>
</ul>
<br>
<p><em><strong>其他应用:</strong></em></p>
<ul>
<li>
<p>寄存器的封装 , 也是这样通过联合体封装的</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1c316f2c2beb1c1a38f.png" alt="image-20220923222927253" /></p>
</li>
</ul>
</blockquote>
<br>
<hr />
<h4 id="553-数据的拆分组合"><a class="markdownIt-Anchor" href="#553-数据的拆分组合"></a> 5.5.3 数据的拆分组合</h4>
<p>比如想要获取一个整数的 <em><strong>各个字节</strong></em></p>
<br>
<ul>
<li>可以采用 <em><strong>移位</strong></em> 的方式 , 例如:</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">#define	GET_LOW_BYTE0</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt;  0)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第0个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE1</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt;  8)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第1个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE2</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt; 16)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第2个字节 */</span></span><br><span class="line"><span class="attr">#define	GET_LOW_BYTE3</span><span class="comment">(x)</span>	<span class="comment">((x &gt;&gt; 24)</span> &amp; <span class="number">0</span>x<span class="number">000000</span>ff)	<span class="comment">/* 获取第3个字节 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用 <em><strong>联合体</strong></em> 进行拆分:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> byte0;</span><br><span class="line">        <span class="type">uint8_t</span> byte1;</span><br><span class="line">        <span class="type">uint8_t</span> byte2;</span><br><span class="line">        <span class="type">uint8_t</span> byte3;</span><br><span class="line">    &#125;byte;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span> <span class="title">num</span>;</span></span><br><span class="line">    </span><br><span class="line">    num.data = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte0 = 0x%x\n&quot;</span>, num.byte.byte0);	<span class="comment">// 第一位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte1 = 0x%x\n&quot;</span>, num.byte.byte1);	<span class="comment">// 第二位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte2 = 0x%x\n&quot;</span>, num.byte.byte2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;byte3 = 0x%x\n&quot;</span>, num.byte.byte3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>补充说明：</font ></p>
<ul>
<li>
<p>在使用联合体进行数据操作时 , 要明确当前平台的 <em><strong>大小端模式</strong></em></p>
<ul>
<li><strong>大小端</strong> 用于表示数据在存储器中的 <em><strong>存放顺序</strong></em> ：</li>
<li><em><strong>大端模式</strong></em> ，是指数据的低位保存在内存的 高地址 中，而数据的高位，保存在内存的 低地址 中</li>
<li><em><strong>小端模式</strong></em> ，是指数据的低位保存在内存的 低地址 中，而数据的高位，保存在内存的 高地址 中</li>
</ul>
</li>
<li>
<p>同样的,可以使用联合体来进行 <em><strong>数据组合</strong></em>  :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bit32_data</span> <span class="title">num</span>;</span></span><br><span class="line">    </span><br><span class="line">    num.byte.byte0 = <span class="number">0x78</span>;</span><br><span class="line"> 	num.byte.byte1 = <span class="number">0x56</span>;</span><br><span class="line"> 	num.byte.byte2 = <span class="number">0x34</span>;</span><br><span class="line"> 	num.byte.byte3 = <span class="number">0x12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num.data = 0x%x\n&quot;</span>, num.data);	<span class="comment">// num.data即为组合后数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<hr />
<h3 id="56-const关键字"><a class="markdownIt-Anchor" href="#56-const关键字"></a> 5.6 <code>const</code>关键字</h3>
<blockquote>
<p>摘抄自<a target="_blank" rel="noopener" href="https://blog.csdn.net/K_O_R_K/article/details/120579024?spm=1001.2014.3001.5502">嵌入式 C语言 补充</a></p>
</blockquote>
<p>关键字const用来定义常量，如果一个变量被const修饰，那么它的值就不能再被改变，我想一定有人有这样的疑问，C语言中不是有#define吗，干嘛还要用const呢，我想事物的存在一定有它自己的道理，所以说const的存在一定有它的合理性，与预编译指令相比，const修饰符有以下的优点：</p>
<p>预编译指令只是对值进行简单的替换，不能进行类型检查<br />
可以保护被修饰的东西，防止意外修改，增强程序的健壮性<br />
编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。<br />
下面我们从几个方面来说一下const的用法：</p>
<br>
<hr />
<h4 id="561修饰局部变量"><a class="markdownIt-Anchor" href="#561修饰局部变量"></a> 5.6.1修饰局部变量</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">5</span>; <span class="type">int</span> <span class="type">const</span> n=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>这两种写法是一样的，都是表示变量n的值不能被改变了;</li>
<li>需要注意的是，用<code>const</code>修饰变量时，一定要给变量初始化，否则之后就不能再进行赋值了。</li>
</ul>
<br>
<p><code>const</code> 用于修饰常量 <em><strong>静态字符串</strong></em> ，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str=<span class="string">&quot;fdsafdsa&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有 <code>const</code> 的修饰，我们可能会在后面有意无意的写 <code>str[4]=’x’</code> 这样的语句</li>
<li>这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。</li>
<li>有了 <code>const</code> ，这个错误就能在编译期被发现。</li>
</ul>
<br>
<hr />
<h4 id="562常量指针与指针常量"><a class="markdownIt-Anchor" href="#562常量指针与指针常量"></a> 5.6.2常量指针与指针常量</h4>
<p><em><strong>常量指针</strong></em> 是指针指向的内容是常量，可以有一下两种定义方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * n; </span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * n;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>说明：</font ></p>
<ul>
<li>
<p><em><strong>常量指针</strong></em> 说的是不能通过这个指针改变变量的值，但是还是 <em><strong>可以通过其他的引用来改变变量的值的.</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* n=&amp;a; a=<span class="number">6</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><em><strong>常量指针</strong></em> 指向的值不能改变，但是这并不是意味着指针本身不能改变， <em><strong>常量指针可以指向其他的地址。</strong></em></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; <span class="type">int</span> b=<span class="number">6</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* n=&amp;a; n=&amp;b;</span><br></pre></td></tr></table></figure>
<ul>
<li><em><strong>指针常量</strong></em> 是指指针本身是个常量，<em><strong>不能在指向其他的地址</strong></em> ，写法如下：</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> n;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针常量指向的<strong>地址不能改变</strong>，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> n=&amp;a;</span><br><span class="line">*p=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<br>
<p><font face="华文彩云" color=red size=5>注意：</font ></p>
<ul>
<li>区分<strong>常量指针</strong>和<strong>指针常量</strong>的关键就在于星号的位置，以星号为分界线;</li>
<li>如果<code>const</code>在星号的左边，则为<strong>常量指针</strong>; <code>int const *n</code>;是常量指针</li>
<li>如果<code>const</code>在星号的右边则为<strong>指针常量</strong>。<code>int *const n</code>是指针常量</li>
</ul>
<br>
<p><em><strong>指向常量的常指针</strong></em></p>
<ul>
<li>是以上两种的结合，指针 <em><strong>指向的位置不能改变</strong></em> 并且也 <em><strong>不能通过这个指针改变变量的值</strong></em></li>
<li>但是依然可以通过其他的 <em><strong>普通指针改变变量的值</strong></em> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="563-修饰函数的参数"><a class="markdownIt-Anchor" href="#563-修饰函数的参数"></a> 5.6.3 修饰函数的参数</h4>
<p>根据<strong>常量指针</strong>与<strong>指针常量</strong>，<code>const</code>修饰函数的参数也是分为三种情况:</p>
<ul>
<li>
<p>防止修改指针指向的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>strSource</code> 是<strong>输入参数</strong>，<code>strDestination</code> 是<strong>输出参数</strong>。</li>
<li>给 <code>strSource</code> 加上 <code>const</code> 修饰后，如果函数体内的语句试图改动 <code>strSource</code> 的内容，编译器将指出错误</li>
</ul>
</li>
</ul>
<br>
<ul>
<li>
<p>防止修改指针指向的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*指针p1和指针p2指向的地址都不能修改。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span> <span class="params">( <span class="type">int</span> *<span class="type">const</span> p1 , <span class="type">int</span> *<span class="type">const</span> p2 )</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<br>
<ul>
<li>以上两种的结合 , <strong>指针和内容都不能改</strong></li>
</ul>
<br>
<hr />
<h4 id="564-修饰函数的返回值"><a class="markdownIt-Anchor" href="#564-修饰函数的返回值"></a> 5.6.4 修饰函数的返回值</h4>
<p>如果给以“<strong>指针传递</strong>”方式的函数返回值加 <code>const</code> 修饰，那么函数返回值（即指针）的内容<strong>不能被修改</strong>，该返回值只能被赋给加<code>const</code> 修饰的同类型指针。</p>
<br>
<p><font face="华文彩云" color=red size=5>例如：</font ></p>
<p><em><strong>函数原型:</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetString</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如下语句将出现<strong>编译错误</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = GetString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *str = GetString();</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h4 id="565-修饰全局变量"><a class="markdownIt-Anchor" href="#565-修饰全局变量"></a> 5.6.5 修饰全局变量</h4>
<ul>
<li>全局变量的 <em><strong>作用域</strong></em> 是整个文件;</li>
<li>我们应该尽量 <strong>避免使用全局变量</strong>  , 因为一旦有一个函数改变了全局变量的值，它也会影响到其他引用这个变量的函数;</li>
<li>如果一定要用全局变量，我们应该尽量的使用<code>const</code>修饰符进行修饰，这样防止不必要的人为修改，使用的方法与局部变量是相同的。</li>
</ul>
<br>
<h3 id="57-staic关键字"><a class="markdownIt-Anchor" href="#57-staic关键字"></a> 5.7 <code>staic</code>关键字</h3>
<p>static关键字在编写程序时一般有三大类用法：</p>
<ul>
<li>定义局部变量</li>
<li>定义全局变量</li>
<li>定义函数</li>
</ul>
<br>
<hr />
<h4 id="571-static定义局部变量"><a class="markdownIt-Anchor" href="#571-static定义局部变量"></a> 5.7.1 static定义局部变量</h4>
<blockquote>
<p><em><strong>作用域 :</strong></em>  作用域是为代码块内</p>
<p><em><strong>储存属性 :</strong></em> 用<code>static</code>定义的局部变量的生命周期 , 会变成静态储存 , 即全局都存在 ;</p>
<p><strong>储存位置 :</strong> 储存位置由 <em><strong>栈</strong></em> 转移到了 <em><strong>数据段</strong></em> (.data)中</p>
<p><strong>值 :</strong></p>
<ul>
<li>静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0</li>
<li>以后每次调用静态局部变量的时候都用上次调用后的值。</li>
<li>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，<strong>也是唯一的一次初始化</strong>。</li>
</ul>
</blockquote>
<br>
<p><font face="华文彩云" color=red size=5>使用示例：</font ></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> k = <span class="number">4</span>;   <span class="comment">// 在离开这个函数后,k = 4 不会变 ;在下次进入这个函数时 ,k都是4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k = %d&quot;</span>, i );		<span class="comment">// 打印k的值 编译器会报错; 因为k的作用域还是局限在&#123;&#125;中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<hr />
<h5 id="5711-补充-内存空间分布"><a class="markdownIt-Anchor" href="#5711-补充-内存空间分布"></a> 5.7.1.1 补充 —— 内存空间分布</h5>
<p>可执行文件(.o)在被加载到内存中时 , <em><strong>内存空间分布图</strong></em>:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://pic.imgdb.cn/item/632ea1e216f2c2beb1c1c7ed.png" alt="image-20220924001131747" /></p>
<br>
<ul>
<li><em><strong>函数</strong></em> 翻译成二进制指令放在 <em><strong>代码段</strong></em> 中</li>
<li><em><strong>初始化的全局变量</strong></em> 和 <em><strong>静态局部变量</strong></em> 放在 <em><strong>数据段</strong></em> 中(.data)</li>
<li><em><strong>未初始化的全局变量</strong></em> 和 <em><strong>静态变量</strong></em> 放在 <em><strong>BSS段</strong></em> 中(.bss)</li>
<li>函数的 <em><strong>局部变量</strong></em> 保存在 <em><strong>栈</strong></em> 中</li>
<li>使用<code>malloc</code>申请的 <em><strong>动态内存</strong></em> 保存在 <em><strong>堆空间</strong></em> 中</li>
</ul>
<br>
<hr />
<h4 id="572-static定义全局变量"><a class="markdownIt-Anchor" href="#572-static定义全局变量"></a> 5.7.2 static定义全局变量</h4>
<blockquote>
<p><em><strong>作用域：</strong></em> 作用域仅为当前文件 ; 其他文件不可访问 ; 其他文件可以定义与其同名的变量</p>
<p><em><strong>储存属性 :</strong></em> 储存<strong>属性不变</strong> ,  还是 <em><strong>静态储存</strong></em>  , 生命周期为整个程序运行期间</p>
<p><em><strong>储存位置:</strong></em> 储存位置 <em><strong>不变</strong></em>  , 都是在在<code>.data</code>段（已初始化）或者<code>.bss</code>段（未初始化）内</p>
<p><em><strong>说明：</strong></em></p>
<blockquote>
<ul>
<li>用static定义的全局变量称为静态全局变量</li>
<li>在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</li>
</ul>
</blockquote>
</blockquote>
<br>
<hr />
<h4 id="573-static定义函数"><a class="markdownIt-Anchor" href="#573-static定义函数"></a> 5.7.3 static定义函数</h4>
<blockquote>
<p><code>static</code>定义的<strong>函数</strong>与 static定义的<strong>全局变量</strong>特性相似</p>
<p><em><strong>作用域 :</strong></em> static函数的作用域是本源文件 ; 其他文件不能引用该函数 ; 其他文件可以定义 <em><strong>同名函数</strong></em></p>
<p><em><strong>储存属性 :</strong></em> <em><strong>静态储存</strong></em>, 生命周期为整个程序运行期间</p>
<p><em><strong>储存位置 :</strong></em>  储存在<strong>代码段</strong>(.test)中</p>
</blockquote>
<br>
<hr />

    </div>

    
    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------已经到底啦！ <i class="fa fa-paw"></i>-------------</div>
    
</div>

  
</div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> c语言</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
              <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> 单片机</a>
              <a href="/tags/gun/" rel="tag"><i class="fa fa-tag"></i> gun</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/08/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)%E2%80%94%E2%80%94ARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="prev" title="嵌入式C语言学习记录(一) —— ARM指令集与作用域">
                  <i class="fa fa-chevron-left"></i> 嵌入式C语言学习记录(一) —— ARM指令集与作用域
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/08/SystemView%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%A7%BB%E6%A4%8D/" rel="next" title="SystemView 介绍与移植">
                  SystemView 介绍与移植 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">




<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yezhaotin</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->


<!-- <br /> -->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<!-- <span id="times">载入时分秒...</span> -->
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("4/6/2023 8:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); 
        if(String(snum).length ==1 ){snum = "0" + snum;}
        // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/ye2020" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css" integrity="sha256-gMRN4/6qeELzO1wbFa8qQLU8kfuF2dnAPiUoI0ATjx8=" crossorigin="anonymous">





<script type="text/javascript"
    count="150"
    opacity: 1
    src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":250,"height":400,"position":"lift","hOffset":150,"vOffset":-30},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>

</html>


  <!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>